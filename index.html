<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="Lyncien">


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="Lyncien&#39;s homepage">
<meta property="og:url" content="https://lyncien.github.io/index.html">
<meta property="og:site_name" content="Lyncien&#39;s homepage">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lyncien&#39;s homepage">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Lyncien&#39;s homepage" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Lyncien&#39;s homepage</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<script src="/js/head-pic.js" ></script> <!-- head-pic-flash by Lyncien -->
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic" id="head-pic"> <!-- head-pic-flash by Lyncien -->
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Lyncien</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:Lyncien@126.com" title="Email"></a>
                            
                                <a class="fa Leetcode" href="https://leetcode-cn.com/lyncien/" title="Leetcode"></a>
                            
                                <a class="fa GitHub" href="https://github.com/Lyncien" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/COD/">COD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Compiler/">Compiler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DS/">DS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hackergame2018/">Hackergame2018</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MCPS/">MCPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PC/">PC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Verilog/">Verilog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/感想/">感想</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Lyncien</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic" id="head-pic-mobile"> <!-- head-pic-flash by Lyncien -->
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Lyncien</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:Lyncien@126.com" title="Email"></a>
                            
                                <a class="fa Leetcode" target="_blank" href="https://leetcode-cn.com/lyncien/" title="Leetcode"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/Lyncien" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我">
</nav>
      <div class="body-wrap">
  
    <article id="post-article/pc_first_problem" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/02/25/article/pc_first_problem/" class="article-date">
      <time datetime="2019-02-24T16:00:00.000Z" itemprop="datePublished">2019-02-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/25/article/pc_first_problem/">并行计算初探</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>今天是并行计算的第一节课，在介绍完重要性和历史后，老师提了一个问题，作为我们了解并行计算的开始</p>
<blockquote>
<p>如何并行地尽快求解$n$个元素的最大值或排序？</p>
</blockquote>
<p>老师讲解了求最大值的方法，我觉得挺有趣的，在此做个记录</p>
<h4 id="朴素的串行算法"><a href="#朴素的串行算法" class="headerlink" title="朴素的串行算法"></a>朴素的串行算法</h4><p>遍历即可，时间复杂度$O(n)$，需要一个处理器</p>
<h4 id="一般的并行算法"><a href="#一般的并行算法" class="headerlink" title="一般的并行算法"></a>一般的并行算法</h4><p>类似淘汰赛的方式，每两个数用一个处理器进行比较，选出较大的数，在所有选出的数中重复该操作</p>
<p>时间复杂度$O(logn)$，需要处理器个数$O(n/logn)$</p>
<h4 id="不计代价的并行算法"><a href="#不计代价的并行算法" class="headerlink" title="不计代价的并行算法"></a>不计代价的并行算法</h4><p>对于$n$个数，使用$n^2$个处理器，组成方阵，对于处理器$p_{ij}$比较第$i$和第$j$个数的大小，得到结果方阵$A$<br>$$<br>A_{ij} =<br>\begin{align}<br>0 &amp;&amp; N_i \ge N_j \<br>1 &amp;&amp; N_i \lt N_j \<br>\end{align}<br>$$</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">8</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
<th style="text-align:center">0</th>
<th style="text-align:center">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>再使用一个列向量，初始全为$1$</p>
<p>对于$A$的第$i$行，如果$A_{ij} = 0$，置$B_i = 0$ （此处可能有写冲突，但不影响结果）</p>
<table>
<thead>
<tr>
<th style="text-align:center">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>如此，只有最大的那个数对应的行全为$1$，对应B的分量为$1$</p>
<p>时间复杂度为$O(1)$ ！！！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PC/">PC</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-cp/lab_final" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/17/cp/lab_final/" class="article-date">
      <time datetime="2019-01-16T16:00:00.000Z" itemprop="datePublished">2019-01-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/17/cp/lab_final/">编译原理课程实验汇报</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <center><font size="6" color="blue">编译原理课程实验汇报</font></center>

<h2 id="第一部分：小组合作篇"><a href="#第一部分：小组合作篇" class="headerlink" title="第一部分：小组合作篇"></a>第一部分：小组合作篇</h2><h4 id="1-实验内容"><a href="#1-实验内容" class="headerlink" title="1. 实验内容"></a>1. 实验内容</h4><p>在给定框架下，完成一个PL0语言的简单编译器</p>
<ul>
<li>预备实验<ul>
<li>安装Linux系统</li>
<li>安装GCC/Git/CMake</li>
<li>学习使用git命令合作编写代码</li>
</ul>
</li>
<li>Lab1<ul>
<li>熟悉PL0语言词法</li>
<li>实现语法分析部分，对输入的文件实现Token流输出</li>
</ul>
</li>
<li>Lab2<ul>
<li>熟悉PL0语言的语法图</li>
<li>实现语法分析部分</li>
<li>使用递归下降的方式</li>
<li>产生语法树</li>
<li>部分错误的检测</li>
</ul>
</li>
<li>Lab3<ul>
<li>更完整的错误检测与处理</li>
<li>对PL0语言进行拓展</li>
<li>设计并绘制新的语法图</li>
</ul>
</li>
<li>Lab4<ul>
<li>完善Lab3添加的功能</li>
<li>实现生成中间代码（基于特定模型的虚拟机）</li>
</ul>
</li>
</ul>
<h4 id="2-总体设计和实现功能"><a href="#2-总体设计和实现功能" class="headerlink" title="2. 总体设计和实现功能"></a>2. 总体设计和实现功能</h4><ul>
<li>根据助教所给的框架，主要包括以下几部分<ul>
<li>common部分定义了编译器相关的数据结构和全局变量</li>
<li>err部分定义了错误了类型对应的提示信息</li>
<li>lex部分实现词法分析，输入文件字符流，构建一个状态机进行分析，输出Token流</li>
<li>syntax部分实现语法分析和代码生成。调用lex，逐个读取Token，进行递归下降的语法分析，用语法制导的方式生成中间代码</li>
<li>test.c<ul>
<li>使用以上几部分构建编译器</li>
<li>前期用于测试</li>
<li>最后用于生成一个PL0编译器，调用时两个参数分别为输入的PL0源代码文件和输出的中间代码文件，该中间代码可在助教提供的PL0虚拟机上运行</li>
</ul>
</li>
</ul>
</li>
<li>最后在助教的虚拟机上运行得分为124</li>
</ul>
<h4 id="3-小组成员之间的合作形式"><a href="#3-小组成员之间的合作形式" class="headerlink" title="3. 小组成员之间的合作形式"></a>3. 小组成员之间的合作形式</h4><ul>
<li>每次实验我先完成了一大部分</li>
<li>在我的万般催促下，在每周日下午会面讨论，我和组长继续完善代码</li>
<li>DDL前一天由我收尾</li>
</ul>
<h4 id="4-对小组合作效果进行评价"><a href="#4-对小组合作效果进行评价" class="headerlink" title="4. 对小组合作效果进行评价"></a>4. 对小组合作效果进行评价</h4><ul>
<li>合作效果其实不大</li>
<li>组长忙于其他课程，不过与我讨论很多；另一位同学就划水了…-_-</li>
<li>大部分代码都是由我完成</li>
</ul>
<h2 id="第二部分：个人任务篇"><a href="#第二部分：个人任务篇" class="headerlink" title="第二部分：个人任务篇"></a>第二部分：个人任务篇</h2><h4 id="1-我的主要任务"><a href="#1-我的主要任务" class="headerlink" title="1. 我的主要任务"></a>1. 我的主要任务</h4><ul>
<li>词法的<strong>全部</strong>实现</li>
<li>语法的<strong>大部分</strong>实现（除了错误处理的细节）</li>
<li>生成代码部分的<strong>几乎全部</strong>（除了call的一部分代码）</li>
<li>绘制新的语法图</li>
</ul>
<h4 id="2-每一个任务的完成"><a href="#2-每一个任务的完成" class="headerlink" title="2. 每一个任务的完成"></a>2. 每一个任务的完成</h4><ul>
<li><p><strong>词法部分</strong></p>
<ul>
<li><code>PL0Lex_get_token</code>函数每次被调用时，顺序读入文件中的字符，直到得到一个token或着发现语法错误</li>
<li>不进行复杂的判断，而是预先构造状态转换表，实现了一个有限自动机<ul>
<li>包括非接受状态集和接受状态集</li>
<li>一开始进入<code>START</code>状态，然后进入一个while循环，每次读入一个字符后根据状态转换表进行转换</li>
<li>若读取的字符类型为<code>ILLEGAL</code>，直接返回错误类型。</li>
<li>如果进入了接受状态则返回token及其类型，长度，行号，位置</li>
<li>如果进入非接受状态，则循环继续，但要注意对数字和标识符以及长度进行记录，以便后续返回<ul>
<li>如果读取到数字，则进入<code>IN_NUM</code>状态，继续读到数字则保持该状态，读到其他类型字符则进入<code>NUM_AC</code>状态。</li>
<li>如果读取到字母，则进入<code>IN_ID</code>状态，继续读到数字，字母和下划线则保持该状态，读到其他类型字符则进入<code>ID_AC</code>状态。</li>
<li>对于长度为2的symbol<ul>
<li>对于各比较运算符<code>&lt;=</code>和<code>&gt;=</code>，读到第一个字母时，进入一个选择状态，根据下一个字符是否为<code>=</code>来进入相应接受状态，注意是否回退一个字符。</li>
<li>对于<code>!=</code>和<code>:=</code>，读取第一个字符时，分别进入选择状态，如果下一个字符是<code>=</code>，则接受，否则，第一个字符是非法字符，报错。</li>
</ul>
</li>
<li>对于剩下各个长度为1的symbol，读到该字符就进入对应symbol的接受状态</li>
<li>对于注释，读取到<code>/</code>，进入一个选择状态，如果下一个字符是<code>*</code>则进入注释状态，否则接受<code>/</code>。退出注释状态同理。</li>
</ul>
</li>
<li>如果当前的状态是<code>IN_LINECOMMENTS</code>则忽略一切字符直到读取到换行符<code>\n</code></li>
<li>如果当前的状态是<code>IN_BLOCKCOMMENTS</code>则忽略一切字符直到读取到<code>*/</code></li>
</ul>
</li>
<li>关于是否回退一个字符，预先设置一个数组来查询。</li>
<li><p>关于保留字，不在状态表中体现，进入<code>ID_AC</code>后取得一个字符串，此时才与保留字数组进行比较，如果不属于其中任何一个，则认为是标识符。</p>
</li>
<li><p>关于状态转换表</p>
<ul>
<li><p>二维表，实现上面描述的自动机的功能，给定当前状态和输入字符，得到下一个状态</p>
</li>
<li><p>为了使状态表不会太大，对字符进行分类，改为根据当前状态和当前输入的字符<strong>类型</strong>进行转换</p>
<ul>
<li>数字类型</li>
<li>字母类型</li>
<li>分隔符类型</li>
<li>长度为1的symbol字符每种对应一个类型</li>
<li>长度为2的symbol中出现的额外字符<code>!</code>和<code>:</code>也作为两种类型</li>
<li>其他字符均视为非法字符类型。</li>
</ul>
</li>
<li><p>字符类型定义</p>
<pre><code class="C">typedef enum _tCharType{
    LETTER, /* A-Za-z_ */
    DIGIT,  /* 0-9 */
    SPACE,  /* */
    TAB,    /* \t */
    NEWLINE,/* \n */
    PLUS,   /* + */
    MINUS,    /* - */
    TIMES,    /* * */
    SLASH,    /* / */
    EQU,    /* = */
    LES,    /* &lt; */
    GTR,    /* &gt; */
    LPAREN,    /* ( */
    RPAREN,    /* ) */
    COMMA,    /* , */
    SEMICOLON,/* ; */
    PERIOD,    /* . */
    COLON,    /* : */
    EXCLAMA,/* ! */
    AND,    /* &amp; */
    OR,        /* | */
    ILLEGAL    /* other */
} CharType;
</code></pre>
</li>
<li><p>状态定义</p>
<pre><code class="c">typedef enum _tState{
    START,
    SLASH_SEL,
    LES_SEL,
    GTR_SEL,
    IN_NUM,
    IN_ID,
    IN_LINECOMMENTS,
    IN_BLOCKCOMMENTS,
    TO_END_BLOCKCOMMENTS,
    COLON_SEL,
    EXCLAMA_SEL,
    AND_SEL,
    OR_SEL, //以上是中间状态（非接受）
    PLUS_AC,
    MINUS_AC,
    TIMES_AC,
    SLASH_AC,
    EQU_AC,
    NEQ_AC,
    LES_AC,
    LEQ_AC,
    GTR_AC,
    GEQ_AC,
    LPAREN_AC,
    RPAREN_AC,
    COMMA_AC,
    SEMICOLON_AC,
    PERIOD_AC,
    BECOMES_AC,
    NOT_AC,
    AND_AC,
    OR_AC,
    NUM_AC,
    ID_AC, //以上是接受状态
    ERROR1,// &quot;:&quot; expect &quot;=&quot;
    ERROR2,//expect &quot;&amp;&amp;&quot; but find &quot;&amp;&quot;
    ERROR3    //expect &quot;||&quot; but find &quot;|&quot;
} State;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>语法部分</strong></p>
<ul>
<li>使用递归下降的方式</li>
<li>实现拓展语法<ul>
<li>增加逻辑运算符<code>&amp;&amp;</code> <code>||</code> <code>!</code><ul>
<li>将PL/0语言中的“条件”概念一般化 (表达式值非零即为“真”)</li>
<li>短路计算</li>
</ul>
</li>
<li>加入<code>return</code>语句</li>
<li>增加<code>else</code> <code>elif</code></li>
<li>增加<code>do</code> <code>while</code></li>
<li>增加参数传递</li>
<li>在语法分析中引入负数</li>
</ul>
</li>
<li>语法图如下<ul>
<li><img src="//lyncien.github.io/2019/01/17/cp/lab_final/1547603448952.png" alt="1547603448952"></li>
<li><img src="//lyncien.github.io/2019/01/17/cp/lab_final/1547603474286.png" alt="1547603474286"></li>
<li><img src="//lyncien.github.io/2019/01/17/cp/lab_final/1547603515703.png" alt="1547603515703"></li>
<li><img src="//lyncien.github.io/2019/01/17/cp/lab_final/1547603534249.png" alt="1547603534249"></li>
</ul>
</li>
<li>根据语法图实现上述非终结符对应的函数<ul>
<li><code>program</code></li>
<li><code>program_block</code></li>
<li><code>var_declaration</code></li>
<li><code>const_declaration</code></li>
<li><code>statement</code></li>
<li><code>or_expression</code></li>
<li><code>and_expression</code></li>
<li><code>relation_expression</code></li>
<li><code>arithmetic_expression</code></li>
<li><code>term</code></li>
<li><code>factor</code></li>
</ul>
</li>
<li>其他函数<ul>
<li><code>gettoken</code>：调用词法分析器，获取一个Token</li>
<li><code>match</code>：比较当前Token与预期的(通过参数传入)是否一致</li>
<li><code>table_append</code>：将一个标识符加入全局表中</li>
<li><code>table_append2</code>：将一个标识符(参数)加入另一个全局表中</li>
<li><code>intable</code>：查找一个标识符在上面两个表中的下标，包括变量/常量/过程名/参数名</li>
</ul>
</li>
<li>错误检测恢复的实现<ul>
<li>发现当前Token不是预期的时候，即跳过后面的若干个Token，直到下一个可以正确地跟随当前正在分析的句子结构的符号为止。</li>
<li>对于上面的每个函数（对应语法图的每一个分析过程），调用时提供一个显式参数（一个集合），它指明当前活动结点的可能的后继符号集合，这个集合由上层的函数计算。</li>
<li>后继符号集合计算<ul>
<li>在最上层先用一些明显的关键符号给它赋初值</li>
<li>随着分析的层次深入，逐步补充别的合法符号</li>
</ul>
</li>
<li>在<code>statement</code>和<code>factor</code>的开始和结束时进行检测（调用check函数）<ul>
<li>因为这两个函数出现大量分支，需要对开始符号进行检测。</li>
<li>其他层次的函数最终都会通过层层次调用在这两个函数里发现错误。</li>
</ul>
</li>
<li><code>check</code> 函数实现<ul>
<li>有三个参数：<ul>
<li>允许的下一个符号集合S1</li>
<li>另加的停止符号集合S2，有些符号的出现，虽然无疑是错的，但绝不应被忽略而跳过</li>
<li>应该报的错误信息</li>
</ul>
</li>
<li>如果当前Token不在集合S1中，即报错，此时合并S1和S2为S，继续读取Token，直到找到一个Token在S中</li>
<li>这个函数可使分析程序不会<strong>盲目地</strong>跳过后面的符号</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>生成代码部分</strong></p>
<ul>
<li><p>全局数组<code>codes</code>，存储全部代码</p>
<ul>
<li><p>每条代码有两个参数，第一个参数是指令名称，第二个参数用于<code>PUT</code>的常数或者<code>JMP</code>的目标地址，其他指令的第二个参数为NONE（预先定义的一个值）</p>
</li>
<li><pre><code class="c">typedef struct _code{
    char ins[4];
    int para;
}code;
</code></pre>
</li>
</ul>
</li>
<li><p><code>gen</code>函数，用于每次生成一条代码</p>
</li>
<li><p>PL0虚拟机包括3部分，codeheap/stack/memory</p>
<ul>
<li><p>这里，stack只作为运算使用，当前运算总是对stack顶端的一个或两个值进行操作(虚拟机指令决定了这个特性)</p>
</li>
<li><p>memory被划分为两部分，从低地址端memory[1]开始增长作为模拟的运行栈(runstack)，从高地址端memory[1023]开始递减作为寄存器</p>
<p><code>`</code><br>————–men[0]<br>|null<br>|runstack<br>|..<br>|..            &lt;– runstack’s top(REG_SP)<br>|<br>|reg4 //REG_SP<br>|reg3 //REG_BP<br>|reg2 //REG_BX<br>|reg1 //REG_AX<br>————–men[1023]</p>
<p>a record in runstack (running)<br>————–low address<br>|return value<br>|return address(in codeheap)<br>|parameters<br>|old base                    &lt;—base (REG_BP)<br>|local id(var/const/procedure)<br>————–high address  &lt;—top (REG_SP)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>  ```
</code></pre><ul>
<li><p>用虚拟机的指令以及memory模拟一个运行栈和寄存器组，实现以下函数</p>
<ul>
<li><code>gen_savereg(REG regid)</code>函数，将stack栈顶值保存到上面的某个寄存器</li>
<li><code>gen_loadreg(REG regid)</code>函数，将上面的某个寄存器的值读取到stack栈顶</li>
<li><code>gen_runstack_push</code>，包括3个函数，向运行栈中压入一个值，这个值可以是立即数/来自寄存器/来自stack栈顶</li>
<li><code>gen_runstack_pop</code>，包括2个函数，从运行栈取出栈顶值，这个值可以被扔掉/保存到寄存器</li>
<li><code>gen_exchangestacktop</code>，交换stack栈顶的两个值<ul>
<li>先存到”寄存器“</li>
<li>再反序压入</li>
</ul>
</li>
<li><code>gen_int2bool</code>，将stack栈顶值转为bool值<ul>
<li>非0值即为1</li>
<li>实现：先<code>PUT 0</code>，再<code>EQ</code>，最后<code>NOT</code></li>
</ul>
</li>
<li><code>gen_id_addr(int index)</code>，根据标识符表/参数表的下标，动态生成某个变量/常量/参数在运行栈中相对基址的偏移量，然后加上基址，得到在memory中的地址，将这个地址放到stack栈顶<ul>
<li>基址是随程序运行栈的变化而变化的</li>
<li>偏移量在生成代码时就算好了，根据语法分析时加入变量表和参数表的下标<ul>
<li>运行栈中当前基址之下是参数（偏移量为负）</li>
<li>运行栈中当前基址之上是局部变量（偏移量为正）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>主要功能与拓展功能的实现</p>
<ul>
<li>增加逻辑运算符 <code>&amp;&amp;</code>  <code>||</code> <code>!</code> <ul>
<li>上面语法部分把<code>expression</code>和<code>condition</code>拓展为4个层次<code>or_expression</code>，<code>and_expression</code>，<code>relation_expression</code>，<code>arithmetic_expression</code></li>
<li>将PL/0语言中的“条件”概念一般化 (表达式值非零即为“真”)<ul>
<li><code>arithmetic_expression</code>计算算术表达式得到的值向上面3层传递时</li>
<li>如果上面3层只有都一个运算数，这个值被保留，即作为最终or_expression的值</li>
<li>如果某层有多个参数，则转换为bool值(0/1)再继续运算，调用<code>gen_int2bool</code>实现</li>
</ul>
</li>
<li>短路计算<ul>
<li><code>or_expression</code>第一个数为1时，生成<code>JMP</code>指令（参数先空着），跳过之后多个值的计算，这里使用回填技术，在生成后面的计算代码后，再将代码所在的行填到这里JMP的参数</li>
<li><code>and_expression</code>第一个数为0时，同理</li>
</ul>
</li>
</ul>
</li>
<li>加入<code>return</code>语句，增加参数传递<ul>
<li><code>factor</code>和<code>statement</code>中分析<code>call</code>时，利用<code>gen_runstack_push</code>函数完成<ul>
<li>生成<em>“将返回地址(当前代码下标+1)压入运行栈”</em>的代码</li>
<li>再生成<em>“将参数依次压入运行栈”</em>，记下参数个数</li>
<li>然后生成<em>“跳转到子过程开始处”</em>的代码</li>
<li>最后按个数生成<em>“将参数依次弹出运行栈”</em>的代码。此时返回值正好在stack顶部</li>
</ul>
</li>
<li><code>procedure</code>部分，扫描到参数全部添加进另一个参数表(专门存放参数)，同时将过程名称和当前代码地址加入标识符表</li>
<li><code>statement</code>中的<code>return</code>语句，将返回值压栈，交换栈顶两个值，则栈顶值是返回地址，生成跳转代码即可</li>
</ul>
</li>
<li>增加<code>else</code> <code>elif</code><ul>
<li>利用<code>JPC</code>和<code>JMP</code>指令，依然使用回填技术，很简单</li>
</ul>
</li>
<li>增加<code>do</code> <code>while</code><ul>
<li>同上</li>
</ul>
</li>
<li>负数<ul>
<li>不在词法分析中实现</li>
<li><code>const_declaration</code>取得常量数字Token时，如果前面一个Token是减号，则数取反后再存入加入标识符表</li>
<li><code>factor</code>中，根据语法图，识别到负号时，再次调用<code>factor</code>，结果在栈顶，此时再生成两条代码<code>PUT 0; SUB;</code>实现将栈顶值取反</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-遇到的困难及解决"><a href="#3-遇到的困难及解决" class="headerlink" title="3. 遇到的困难及解决"></a>3. 遇到的困难及解决</h4><ul>
<li>行号的计算问题<ul>
<li>通过识别<code>\n</code>，遇到就增加</li>
<li>但出现现象：对于某些行，行号增加了两次</li>
<li>这种情况出现在标识符是该行的最后一个Token且标识符之后就是换行符，这样，在标识符结束时会有一个回退一个字符的动作，导致<code>\n</code>被扫描两次，则行号也被增加了两次。</li>
<li>为了避免回退导致<code>\n</code>出现两次，应该限制<code>\n</code>扫描后是在<code>START</code>状态下，也是不回退的情况下，判断此行结束，所以判断条件改为<code>if(ch==&#39;\n&#39; &amp;&amp; state==START)</code></li>
<li>考虑到还有块注释的情况，应该改为<code>if(ch==&#39;\n&#39; &amp;&amp; (state==START || state==IN_BLOCKCOMMENTS))</code></li>
</ul>
</li>
<li>打印错误所在行的文本<ul>
<li>最后一次实验需要打印错误所在行的文本，而之前词法分析时是每次用<code>fgetc</code>读取一个字符，并没有保存当前行</li>
<li>修改读取方式，一开始用<code>fgets</code>读取一行，缓存至<code>linebuf</code>中，每次用<code>pos</code>偏移获取一个字符放在全局变量<code>ch</code>中，如果<code>ch==0</code>，即读取到<code>linebuf</code>结束时，再使用<code>fgets</code>读取一行。</li>
<li><code>linebuf</code>定义在在<code>lex</code>结构体中，语法分析时调用错误函数时可以使用。</li>
</ul>
</li>
<li>错误恢复分析问题<ul>
<li>一开始不知道如何下手</li>
<li>认真阅读课本中关于错误处理的部分，然后查阅了很多资料之后才大概明白如何处理</li>
</ul>
</li>
<li>一些细节问题<ul>
<li>有时候遇到某个错误时，反复报同一个错：处理完一个Token忘了<code>gettoken</code></li>
<li>注意虚拟机的一些特性<ul>
<li>比如<code>DIV</code>和<code>SUB</code>取操作数的顺序和语法分析时的顺序时相反的，需要自行交换栈顶两个数</li>
<li>调用虚拟机打印栈顶值后并不会弹出栈顶值</li>
<li><code>NOT</code>，<code>AND</code>，<code>OR</code>只能实现对0和1的运算，数值到布尔值的运算需要自行实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-亮点"><a href="#4-亮点" class="headerlink" title="4. 亮点"></a>4. 亮点</h4><ul>
<li>状态表的压缩（详见上面总体设计）<ul>
<li>合并输入符号的类型</li>
</ul>
</li>
<li>集合的表示<ul>
<li>没有使用任何数据结构</li>
<li>因为集合元素是有限的Token类型，故集合大小有上限</li>
<li>直接用长整型数表示集合，每个位表示一种Token类型(类似独热编码)<ul>
<li>将Token_Type（枚举类型）用2的幂映射到一个长整数</li>
</ul>
</li>
<li>用位运算实现集合操作<ul>
<li>创建集合：直接定义一个长整型数为0</li>
<li>合并集合：位或运算</li>
<li>元素是否在集合中：位与运算</li>
</ul>
</li>
</ul>
</li>
<li>错误处理<ul>
<li>动态生成可能的后续符号集合</li>
<li>有选择地跳过非预期的符号</li>
<li>较好地实现错误跳过并继续分析</li>
</ul>
</li>
<li>模型运行栈和寄存器<ul>
<li>虚拟机提供的栈只能实现简单运算，无法深入到栈中获取数据</li>
<li>在内存中模拟运行栈，用生成的代码去<strong>”操作“</strong>运行栈</li>
<li>动态地在向栈中加入活动记录，实现过程的递归调用</li>
</ul>
</li>
</ul>
<h4 id="5-总结与心得体会"><a href="#5-总结与心得体会" class="headerlink" title="5. 总结与心得体会"></a>5. 总结与心得体会</h4><ul>
<li>通过实验，我能更深入理解上课所学的理论知识<ul>
<li>词法：有限状态机</li>
<li>语法：递归下降预测分析</li>
<li>生成代码：语法制导的翻译，回填技术</li>
<li>错误处理：First集，Follow集</li>
</ul>
</li>
<li>熟悉了git的使用</li>
<li>体会到了编译器编写的困难<ul>
<li>检测到错误之后要能继续分析，lab2和lab3大部分时间都在想这个问题</li>
<li>这只是一个小小的实验，实现前端的一些简陋功能，但它已经花费了很长时间</li>
<li>如果面对更复杂的语法，就需要借助生成器，如书上所讲的Yacc</li>
<li>如果再考虑语言的各种特性（面向对象、多态、重载），那就更困难了</li>
<li>编译器生成代码要针对”体系结构“，这里就是助教提供的虚拟机</li>
</ul>
</li>
<li>体会到大型工程管理不易<ul>
<li>需要编织好划分好每个文件的功能</li>
<li>处理好全局变量、外部变量，避免重复定义，功能冗余</li>
</ul>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Compiler/">Compiler</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-article/tea_and_health" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/10/article/tea_and_health/" class="article-date">
      <time datetime="2018-12-09T16:00:00.000Z" itemprop="datePublished">2018-12-10</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/10/article/tea_and_health/">茶与健康</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="茶与健康"><a href="#茶与健康" class="headerlink" title="茶与健康"></a>茶与健康</h2><p>这学期有幸选中全校最热门的公选课——茶与健康。之前每学期都是1000+人选28人，在周一晚上上课，从上学期开始每周多开一次下午的课（这个时间选择人数较少），正好我这学期周一下午没课，就来碰碰运气，没想到真的抽中了。这门课之所以这么火，主要是因为上课就是喝喝茶，发表自己的感想，听老师讲述茶文化，期末交一篇论文就可以了，虽然可能被卡优秀率，但只有1学分，花点GPA喝喝茶还是很值得的。</p>
<h3 id="18-09-03"><a href="#18-09-03" class="headerlink" title="18.09.03"></a>18.09.03</h3><p>今天是第一次上茶与健康课，由周先稠老师上课。老师是真·文化人，他说自己改革开放的第一批大学生，是受益者，也是开拓者践行者。今天，我们科技已经很发达，但却<strong>失去了一些内在的东西</strong>。他会在这门课慢慢讲述。虽然是老年人思维，不过有一些的确是<strong>时间沉淀之下的肺腑之言</strong>。老师确实用心在上这门课，我之前就听说曾经凌晨到肥西县的产茶地挑选刚刚产出的茶叶。比较神奇的是，他不用任何现代通讯设备，要找到他只能去办公室。</p>
<p>今天，老师主要介绍了这门课的来源，他说这门茶艺课已经开了10几年了，和王祥老师的陶艺课一样很受欢迎。本来还要开一门食艺课，但是经费不足。。。对了，他还同时开了一门养生课。果然是养生大师，老师已经60多岁了，但还满头浓密的黑发，一看像是不到50岁的样子。</p>
<p>这门课是在体育教学中心的301室上课，外门的装潢与其他教室并无两样，但一进门，经过短短的通道，进入另一扇门，就是另一番景象了，圆形的内室，木质地板，悬吊的灯笼，古朴的屏风围绕在几张茶几和靠椅周围，我简直不敢相信科大有这样的地方。老师说这个室内装修的材料是他亲自挑选的，但装修工人太不懂他的意思了。他讲要天圆地方，但结果地是圆的，而头上是纵横交错的横梁；他说古人讲究头顶为浅色有开阔感，地上为深色有厚重感（我怎么记得应该是“天玄地黄”，天是黑的，地是黄的），结果地板是淡黄色，头上横梁是深褐色；他讲墙边要一点中国传统风格的围栏，结果建筑工搞了罗马柱。还有水管也被漆成银色，后来他和几个学生一起用褐色麻绳缠绕了水管表面。</p>
<p>老师讲了：</p>
<blockquote>
<p>“上这门课，我就是给你们倒茶喝的，你们在家里都会比较放肆，在外面比较收敛，在这里你们只要比在家稍微收敛一点就行了，不要太紧张和拘束。我们科大理工科课程压力大，这里就是给你们放松的机会。但是，我希望你们不要玩手机，而是用心去品茶，<strong>每节课只要有5秒钟是属于你自己的</strong>，我就满足了。”</p>
</blockquote>
<h3 id="18-09-10"><a href="#18-09-10" class="headerlink" title="18.09.10"></a>18.09.10</h3><p>今天喝的茶闻着清香，但入口即为苦味。老师并没有告诉我们今天喝的是什么品种的茶。</p>
<p>这节课还讲茶的起源。</p>
<ul>
<li><p>茶，古时又称“茗”,“贾”,“芟”。</p>
</li>
<li><p>茶文化起源于中国的礼乐时代，茶文化中讲究的“敬”与“和”都蕴含丰富的礼乐精神。茶的饮用最初在西南的巴蜀地区，魏晋南北朝时的民族融合促进茶的传播，但主体仍是上层社会的生活方式。</p>
</li>
<li><p>唐代时，社会经济文化繁荣，禅宗的兴起，禁酒令导致的以茶代酒使得茶文化广泛地深入寻常百姓家。</p>
</li>
<li><p>宋代时对精致文化，高雅生活的极致追求，产生了许多茶文化相关的诗词绘画。</p>
</li>
<li><p>茶文化传入日本后，较好地保留和传承，形成“和、敬、淸、寂”的茶道，但根脉还是在中国。“和、敬、淸、寂”既是一种美学认知，也是一种人生态度。</p>
</li>
</ul>
<p><em>今天我们已经形成高频的工商信息社会，在生活节奏加快的大趋势下，我们似乎没有时间关心自己的生活是否优雅，付出是否值得，所得是否即是所需。我们没有时间考虑太多，只希望“只争朝夕”，为自己和家庭争取更多的资源。人们若想从中国传统文化中寻觅一些日常生活中缺失的东西，茶艺是一个很好的切入点。将茶艺变成个人化的爱好，可以少一点忽悠，多一点真实的体验，不需要太过在意茶艺的形式和茶具的精美，直接与茶叶和水接触，回归一种质朴的生活风范，或许我们能从中得到一份安详淡定的心境。</em></p>
<h3 id="18-09-17"><a href="#18-09-17" class="headerlink" title="18.09.17"></a>18.09.17</h3><p>这节课讲茶的分类，根据氧化程度，分为：绿茶、红茶、青茶、黄茶、黑茶、白茶。</p>
<p>绿茶是不发酵茶，是中国最主要的茶类，其工艺相对稳定：杀青、揉捻、干燥。<strong>茶叶的香味最大程度地被保留。</strong></p>
<p>红茶是完全发酵茶，发源地是福建。其工艺多了一步发酵。</p>
<p>还有半发酵茶乌龙茶。</p>
<p>茶还可分为清香型、浓香型、陈香型。清香型香气纯正，鲜醇爽口。浓香型韵味足，耐冲泡。陈香型都是经过了长期存放的老茶，如普洱茶。</p>
<p>最后老师告诉我们这节课喝的茶是桐城兰花，原产于安徽桐城，初闻无甚味道，入口稍苦，但片刻后舌尖有些许甘甜。另外，上次课喝的是黄山毛峰，这两种都属于绿茶，是不发酵的茶。</p>
<h3 id="18-09-24-中秋休假"><a href="#18-09-24-中秋休假" class="headerlink" title="18.09.24(中秋休假)"></a>18.09.24(中秋休假)</h3><h3 id="18-10-01-国庆休假"><a href="#18-10-01-国庆休假" class="headerlink" title="18.10.01(国庆休假)"></a>18.10.01(国庆休假)</h3><h3 id="18-10-08"><a href="#18-10-08" class="headerlink" title="18.10.08"></a>18.10.08</h3><p>这节课讲茶的功效。</p>
<ul>
<li><p>提神。喝完茶后，晚上会特别精神。</p>
</li>
<li><p>促消化、利尿解毒。</p>
</li>
<li><p>治癌。老师讲：“这里面有茶多酚，在实验中对离体癌细胞有破坏力，有类似作用的还有红豆杉、西洋参，但功效不算太大，一两吨也治不好一个人，而且对于活体中的癌细胞依然无效。”</p>
</li>
</ul>
<p>这节课喝的是太平猴魁，是老师在凌晨到达太平镇，趁着黎明让采茶女采下的茶叶剩下的茶叶梗。老师讲，这节课不评价这个茶，因为不是原产地的，是产地郊外10几公里的，大概算是“假茶”，确实，这次放了很多茶叶，但依然无甚味道，冲泡几次便与开水无异了。</p>
<h3 id="18-10-15"><a href="#18-10-15" class="headerlink" title="18.10.15"></a>18.10.15</h3><p>今天喝的还是黄山毛峰，但是已经不像第一次那样清香了，是残枝败叶的“假茶”。</p>
<p>老师讲，50元的茶和500元的茶，只需要一位专家来科普5分钟，大家就能分辨出来了；500元和5000元的茶，如果你不能凝神静心，是很难感受出区别的，之前有电视采访节目，让人现场判断茶的品质，结果是那些有经验的饮茶者反而不能正确判断，就是因为这种临时场合很难静下心来；至于5000元和50000元的茶，那就需要灵性和天赋了。</p>
<h3 id="18-10-22"><a href="#18-10-22" class="headerlink" title="18.10.22"></a>18.10.22</h3><p>今天喝了两种茶，同学们都说味道都不是很好，有种中药的苦涩味，与绿茶的本该有的清香相去甚远。不过由于我心情很糟糕，好像没有喝出味道。</p>
<p>老师讲解的时候，提到其中一种是野兰香茶，原产于皖南山区宁国市。虽然这原本是一种好茶，但由于保管环境的问题（交替在冰箱和太阳下放了一个暑假），品质败坏了。人也是如此，后天带来的影响极为重要。</p>
<p>老师说下节课将给我们讲一种好茶所需要的六种因素：<strong>产地、产时、保管、研制、水、空气。</strong></p>
<h3 id="18-10-29"><a href="#18-10-29" class="headerlink" title="18.10.29"></a>18.10.29</h3><p>今天喝的茶，初一看，枝叶颜色比先前的深沉得多，一闻，味道甚是厚重，没猜错的话，这应该是发酵茶，至少不是绿茶。入喉，果然重口味，但仔细斟酌，这又不是苦位，并且味道只在入口一瞬，而不会将苦涩之感沉淀在口腔里。</p>
<p>最后得知是祁门红茶。这种茶最初产地只有三个小镇，但是由于近年经济发展所需，周围地区也大量种植这种茶。在大量使用化肥农药后，茶的品质已大大不如原厂地。如今市面上包装精美的所谓“精品茶”就是这些地方产出的。</p>
<p>今天还讲了茶的产地对品质的影响。古语云“上者生烂石,中者生砾壤,下者生黄土”，意为上等之茶生长在岩石悬崖上，中等之茶生长在沙砾、沙土中，下等之茶则生长在泥土中。如今，我们已经很难得到上等茶，那只能是理想中的环境。</p>
<h3 id="18-11-05"><a href="#18-11-05" class="headerlink" title="18.11.05"></a>18.11.05</h3><p>今天喝了两种茶，均为红茶，但要求用温水冲泡，并且浸泡5秒就应该马上将茶水和茶叶分离。</p>
<p>第一种茶叶是依然是祁门红茶，颜色褐黄，枝叶嫩小，香味浓重，温水尚未倒完就已经浓香四溢，一种发酵带来的厚重感。我们暗数5秒钟，一看茶水颜色已经泛黄，赶紧将茶倒入公道杯中，分而品之。味苦而不涩，数秒后是苦尽甘来之快感。冲泡数遍，茶香愈发浓重。</p>
<p>第二种茶叶是宜兴的红茶。颜色接近黑色，体验和第一种茶接近。</p>
<h3 id="18-11-12"><a href="#18-11-12" class="headerlink" title="18.11.12"></a>18.11.12</h3><p>今天喝的仍然是红茶，总共有两种，但每桌只能拿到一种。</p>
<p>没有特别的感觉，可能红茶味道都差不多吧。</p>
<p>关于茶点，他不告诉我们应该要带什么样的茶点，否则我们就像记住知识一样，也就只会带这些过来了，老师说不过多干涉我们的感觉，让我们把握当下的感觉。</p>
<p>还讲了茶叶的产时：</p>
<blockquote>
<p><em>明前茶，</em>是清明节前采制的<em>茶叶</em>，受虫害侵扰少，芽叶细嫩，色翠香幽，味醇形美，是茶中佳品。</p>
<p><em>雨前茶</em>，雨前，即谷雨前，即4月5日以后至4月20日左右采制用细嫩芽尖制成的茶叶称雨前茶。</p>
</blockquote>
<p>明前茶是上等茶，刚刚冒芽，茶农一般舍不得摘下，这时的茶是之后各代茶的“祖先”。</p>
<p>而世面上大多好茶其实是多代“子孙”了，其品质远不如源头好，但是经过包装后就买了好价钱。</p>
<p>老师告诉我们，当前社会风气浮夸，各种事物经过层层包装，已经不像中国古时那样展现其本质。</p>
<h3 id="18-11-19"><a href="#18-11-19" class="headerlink" title="18.11.19"></a>18.11.19</h3><p>今天喝的是普洱茶，是一位同学从家乡带来的。茶叶呈黑色块状/饼状，是经过压制的，不过冲泡后味道不重。</p>
<p>老师告诉我们，普洱茶本来是一种普通的茶，但自从人们开始注重资产增值后，普洱茶就像房地产一样被炒起来了，价格虚高。</p>
<blockquote>
<p>普洱茶是发酵茶，但并没有发酵到极点。茶并不是放得越久也好，也不是发酵的程度越深越好，而是<strong>恰如其分</strong>。</p>
</blockquote>
<p>什么是<strong>恰如其分</strong>？老师又举了几个例子</p>
<blockquote>
<p>正如吃大虾沾麻油一样，两滴，让人回味无穷，太少了，没味道，太多了，满嘴是油。</p>
</blockquote>
<blockquote>
<p>又如所谓20年30年老窖，其实是勾兑酒，10斤老酒可以兑3000斤新酒，这种酒给人的感觉刚刚好。</p>
</blockquote>
<blockquote>
<p>古代乐器，丝和竹，弦绷太紧，演奏出来鬼哭狼嚎，弦太松，又听起来低沉。</p>
</blockquote>
<p>关于茶点，老师说他继续以批判的眼光来评价我们，但只是他个人看法，让我们自己权衡。</p>
<p>他先讲了中国的饮食。</p>
<blockquote>
<p>中国饮食发展至今，虽然分为八大菜系，但都讲究一个字 ”<strong>平</strong>“，就像天平一样，这边重了，另一边也要加重保持平衡。</p>
</blockquote>
<blockquote>
<p>比如吃螃蟹总要吃生姜，螃蟹是大寒之物，而姜是暖的，二者一合，就平了。</p>
</blockquote>
<blockquote>
<p>再比如，即使你们天天吃麦当劳/肯德基等洋快餐，等你们中年之后，总会有一天，在家自己做饭蒸煮各种营养的食物，这就是人的自我平衡。</p>
</blockquote>
<blockquote>
<p>茶点也是如此，红茶对应的茶点是应该是甜的。日本茶道中的茶点就是一块小方糖，甜甜的，软绵绵的，表面沾有糖浆，入口即化。</p>
</blockquote>
<p>老师补充了一些饮食的看法.</p>
<blockquote>
<p>有人说：”我最近营养不足，得多补补。“</p>
<p>其实不对，饮食习惯是慢慢养成的，如果等到缺的时候再一口气补，不如不要。</p>
<p>我有同事，儿子摔伤了，生活不能自理，医院都下病危通知书了，同事还决定给儿子补补身体，每天各种肉，我说都这样了，补是没有用的，反而加重。你就每天给他熬萝卜汤喝，然后用热水从上到下擦拭身体。后来真的好了。</p>
</blockquote>
<h3 id="18-11-26"><a href="#18-11-26" class="headerlink" title="18.11.26"></a>18.11.26</h3><p>今天喝的茶是“安茶”。</p>
<p>“安茶”又称“六(liu4)安茶”，但产地并非安徽六(lu4)安，而是之前说的祁门县。这种茶不仅可饮用，还能药用，具有祛湿解毒之效，在东南亚一带为人称道，“六安”就是指安定五脏六腑。</p>
<p>安茶颜色黑呦，人们往往认为是黑茶，其实是介于红茶、绿茶之间的后期半发酵紧压茶，不属于传统分类的六种茶。</p>
<blockquote>
<p>安茶有着极为独特的“日晒夜露”工艺——白天晒太阳晚上吸收露水，或因“汲日月精华”之义，使它与众不同。很多人喝到安茶，弄不懂这是什么茶类，像岩茶又像黑茶，又像绿茶。这是因为安茶的工艺太复杂，太讲究。除了日晒夜露，安茶在制作工艺中还需要多道炭火烘焙，这工艺像极了传统的乌龙茶。安茶的前期炒青工艺使它像绿茶；其后期的蒸压与存储发酵，喝起来的滋味红浓醇陈，带着特殊的粽叶炭火香，故又似黑茶。</p>
<p>安茶性温凉，尤其是陈年安茶，火气退尽，茶性更温，味涩生津，能够祛湿解暑，特别适合广东、南洋一带多湿热地区。</p>
</blockquote>
<p>老师往茶壶里放茶的时候，还从装茶的篮子边缘扯下了些许叶片，我们以为那是编竹篮的竹条，后来知道这是箬叶（即粽叶）。</p>
<blockquote>
<p>安茶的包装也别出心裁，祁门安茶是用竹篓包装。</p>
<p>将安茶压紧装入竹篓内，放入烘橱内烘干，</p>
<p>凝结成椭圆形块状，然后依竹篓容量成型。</p>
</blockquote>
<p><img src="//lyncien.github.io/2018/12/10/article/tea_and_health/f124901ddc0c4039b75c207f6678d032_th.jpeg" alt="img"></p>
<p>关于安茶，有一段坎坷的经历，几近失传。</p>
<blockquote>
<p>百年前影响世界的安茶，从1937年日军侵华、水路停运导致停产，消失的时间太长了，整整半个多世纪，对于安茶，人们已经淡漠或遗忘，留下了只有东南亚一带的压在茶箱里的一抹陈香。</p>
</blockquote>
<blockquote>
<p>1983年，有一个人也是为了寻访安茶，从香港写信并专程寄了篓老安茶过来，这是香港茶叶发展基金会的关奋发老先生。在香港广东一带，海边渔民喝海水后腹胀，把茶叶放在炉子上煮一煮，喝一碗，病就好了。百年前，岭南的医生曾以安茶入药，治好了广东一带流行的瘟疫。因为安茶的药效，被人们称为“圣茶”，但此茶久已湮没，存世仅有少量的老茶。关奋发老人来信，希望茶区能再现半个世纪前的茶香，于是，安徽省茶叶公司一路问到祁门县茶叶局，最后问到芦溪乡。</p>
</blockquote>
<blockquote>
<p>只是那时，大家对安茶已经太陌生了，整个祁门没有一片茶园用于生产安茶。当人们看到早期的茶叶与斑驳的茶票，以为只是一种粗老的茶，凭想象收了些下脚料来做安茶，却怎么也做不出安茶的味道来。</p>
</blockquote>
<blockquote>
<p>汪镇响当时担任芦溪乡企业办主任，也在祁门县茶科所学习祁门红茶的制作，他开始关注并尝试更好的安茶的制作。到了1989年、1990年，通过拜访早期孙义顺茶号的传人汪寿康老人，汪镇响对工艺做了更大改进，特地使用了祁门的槠叶种，采用雨前上等贡尖，一等嫩芽，通过安徽省茶叶公司送到香港。香港方面反馈说比以前有进步，但工艺上还有些不到位。后来，一心想恢复安茶工艺的汪镇响，诚心诚意把汪寿康老人请到茶厂来指导生产，让老人回顾安茶工艺更细节的技术，又不断拜访其他几个健在的老师傅，安茶终于得到重生的希望。到了1991年送样，香港方面特别高兴，说很好喝了。1992年，就有了江南春茶厂，复产安茶成功。从那几年开始，安茶开始在广东佛山等地引起了反响。1997年，根据广东省土畜产进出口公司的一位陈经理建议，“孙义顺”的商标开始申请注册，1998年正式启用。但那一段时间，安茶并不是很好卖，市场还是很有压力。安茶销售的机遇，出现在2003年的非典期间——在广东当地，安茶被当作药方，市场由此开始突破。</p>
</blockquote>
<p>汪镇响老先生是老师的朋友，老师拜访他时，他的外孙子才十几岁。如今，老先生已离世，这位20几岁的小伙子也承担起传承安茶的重任，老师便告诫他一定要保证茶的质量，不要被当今高频的工商信息社会所影响。</p>
<p>这有个纪录片，祁门《安茶事纪》</p>
<video src="http://m.qmhtea.com/video/%E7%A5%81%E9%97%A8%E3%80%8A%E5%AE%89%E8%8C%B6%E4%BA%8B%E7%BA%AA%E3%80%8B.mp4"></video>



<h3 id="18-12-03"><a href="#18-12-03" class="headerlink" title="18.12.03"></a>18.12.03</h3><p>今天老师有事没能来上课，由一位博士生来分发茶叶，这次所喝正是上节课所提的安茶。</p>
<h3 id="18-12-10"><a href="#18-12-10" class="headerlink" title="18.12.10"></a>18.12.10</h3><p>今天喝的是太平猴魁，这已经是第三次了。在连续喝了几次红茶后，又回归绿茶，重新体会到当初的苦涩感。</p>
<p>然而，今天的重点不是喝茶，老师让我们先”好自为之“，然后他给我们讲两个故事。</p>
<p>先是讲了梁漱溟闭关看《西方哲学》以及他与毛泽东的故事，再讲了一个制茶大师带男女弟子双休的故事。。</p>
<p>下面是穿插其中的一些话语。</p>
<blockquote>
<p>喝茶，要虚实交替，动静相接，如果我们都实实在在，把活的感觉都变成知识，那会很可悲。</p>
</blockquote>
<blockquote>
<p>现实没有错，不要过分于现实，不要全力于现实，要留一点精神自我，要留一点空间给自己，正如第一次茶艺课所说。</p>
</blockquote>
<blockquote>
<p>你把这些感觉弄丢了，然后去研究什么《易经》，那么不是装神就是弄鬼。科大有的学生，学习成绩不好，就再那卖弄，说自己对《易经》很有研究，”易经是万经之首，经中之王“，前几年我就抓到几个易经大师，都是本科生。</p>
</blockquote>
<blockquote>
<p>你们今天好好养护自己的身体，比起成绩/保研/郭沫若奖，我个人认为，更加重要。</p>
</blockquote>
<blockquote>
<p>与人相处，有的人内心阳光，有的人内心相对狭隘，但如果你真正的开心，那么周围的人也会被你影响。你什么样的心态，就伴随你四年的科大生活，如何编织这一过程，都只能靠你们自己。</p>
<p>绵里藏针，暗藏杀机，你们好自为之。</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/感想/">感想</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-alg/lab5" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/09/alg/lab5/" class="article-date">
      <time datetime="2018-12-08T16:00:00.000Z" itemprop="datePublished">2018-12-09</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/09/alg/lab5/">算法基础上机实验五 图搜索BFS算法及存储优化</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>图搜索BFS算法及存储优化</p>
<blockquote>
<h5 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a>实验要求：</h5><p>1.模拟数据集</p>
<p>自己随机生成有向图，边数的规模为10，100，1000，10000，100000；</p>
<p>进行BFS搜索，记录程序完成时间和所需内存空间大小。</p>
<p>2.真实数据集</p>
<p><a href="https://pan.baidu.com/s/1pvfphiywjSXohO-bSnL1HA" target="_blank" rel="noopener">https://pan.baidu.com/s/1pvfphiywjSXohO-bSnL1HA</a></p>
<p>数据集说明：均为twitter真实数据集，数据集规模如下：</p>
<p>twitter_small: Nodes 81306, Edges 1768149, 有向图；</p>
<p>twitter_large: Nodes 11316811, Edges 85331846, 有向图。</p>
<p>进行BFS搜索，设计存储优化方案和加速方案，记录程序时间和内存空间大小。</p>
<h5 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h5><p>1）编程语言和实验平台不限，可考虑并行（i.e., GPU/OpenMP/MapReduce）；</p>
<p>2）至少需完成模拟数据集和twitter_small数据集的实验，twitter_large数据集为加分题。 </p>
</blockquote>
<h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><h4 id="BFS算法"><a href="#BFS算法" class="headerlink" title="BFS算法"></a>BFS算法</h4><p>BFS（Breadth First Search），即广度优先搜索，从某个结点s开始，自始至终一直通过已找到和未找到顶点之间的边界向外扩展，就是说，算法首先搜索和s距离为k的所有顶点，然后再去搜索和S距离为k+l的其他顶点。该算法需要一个先进先出队列，只要队列不为空，就从队首取出一个结点n，访问它的所有邻居，如果某个邻居未被标记为已访问（visit=0），则将该邻居加入到队列尾，最后将该结点n标记为已访问（visit=1）。</p>
<p>BFS的时间复杂度为O(V+E)，V为结点数，E为边数。因为每个结点都进入队列一次，访问邻居时每条边至多被扫描一遍。</p>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>由于结点数很多且边稀疏，故采用邻接表进行存储，定义两种结构体：</p>
<ul>
<li><p>nbnode，表示一个结点的某个邻居</p>
<ul>
<li>p，int类型，该邻居在结点数组中的下标</li>
<li>next，nbnode*类型，指向下一个邻居</li>
</ul>
</li>
<li><p>node，表示一个结点</p>
<ul>
<li>id，int类型，表示从文件中读取到的结点ID</li>
<li>visit，char类型（节省存储），-1表示不存在该结点，0表示结点存在但未访问，1表示存在且已访问。</li>
<li>nblisthead，nbnode*类型，指向第一个邻居</li>
</ul>
</li>
</ul>
<p>全局开设一个node结点数组arr</p>
<ul>
<li><p>对于twitter_small.txt文件，81306个结点，其id最大达到九位数，且不连续，直接作为数组下标将造成数组过大，空间浪费多，因此使用c++的map容器，将id映射到数组下标p，每次读入一个id时，用map查询是否存在，若不存在，将该id和当前未分配的最小数组下标(即nodecount)加入map，然后nodecount++。另外，该文件中有重复边，每次为一个结点添加邻居之前先遍历链表判断是否已存在。在BFS时，访问数组直接使用下标，不再使用id。</p>
</li>
<li><p>对于twitter_large.txt，其id最大值等于结点数11316811，id连续，可以直接作为数组下标，且文件中无重复边，可以直接添加邻居无需判断重复。为了实现对node的计数，起使时visit设为-1，读取文件时，如果该结点visit=-1,则nodecount++，并且让visit=0，表示该结点存在（但未访问）。</p>
</li>
</ul>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><h5 id="使用bfs-random-cpp测试10-txt-100-txt-1000-txt-10000-txt-100000-txt"><a href="#使用bfs-random-cpp测试10-txt-100-txt-1000-txt-10000-txt-100000-txt" class="headerlink" title="使用bfs_random.cpp测试10.txt 100.txt 1000.txt 10000.txt 100000.txt"></a>使用bfs_random.cpp测试10.txt 100.txt 1000.txt 10000.txt 100000.txt</h5><p>以上5个文件由GenGraph.py生成。</p>
<p>100000.txt结果如下</p>
<p>读取时间0.019秒，bfs时间几乎为0，内存为5.8MB(不准确，这是包括运行窗口等其他资源使用的内存)</p>
<p><img src="//lyncien.github.io/2018/12/09/alg/lab5/clip_image002.jpg" alt="img"></p>
<p><img src="//lyncien.github.io/2018/12/09/alg/lab5/clip_image004.jpg" alt="img"></p>
<h5 id="使用bfs-cpp测试twitter-small-txt"><a href="#使用bfs-cpp测试twitter-small-txt" class="headerlink" title="使用bfs.cpp测试twitter_small.txt"></a>使用bfs.cpp测试twitter_small.txt</h5><p>​     文件有重复边，序号连续，81306个结点（序号最大有9位数），1768149条边（但文件有2000000多行）</p>
<p>​    结果如下</p>
<p>4.5秒完成（其中读取4.4秒，bfs小于0.1秒）</p>
<p>内存约36MB</p>
<p><img src="//lyncien.github.io/2018/12/09/alg/lab5/clip_image006.jpg" alt="img"></p>
<p><img src="//lyncien.github.io/2018/12/09/alg/lab5/clip_image008.png" alt="img"></p>
<h5 id="使用bfs-large-2-cpp测试twitter-large-txt"><a href="#使用bfs-large-2-cpp测试twitter-large-txt" class="headerlink" title="使用bfs_large_2.cpp测试twitter_large.txt"></a>使用bfs_large_2.cpp测试twitter_large.txt</h5><p>文件无重复边，序号连续，11316811个结点（最大序号就是11316811），85331845条边</p>
<p>结果如下</p>
<p>42秒完成（其中读取29秒，bfs13秒）</p>
<p>内存约1466MB</p>
<p><img src="//lyncien.github.io/2018/12/09/alg/lab5/clip_image010.png" alt="img"></p>
<p><img src="//lyncien.github.io/2018/12/09/alg/lab5/clip_image012.png" alt="img"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h5 id="small"><a href="#small" class="headerlink" title="small"></a>small</h5><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
using namespace std;
typedef struct _nbnode{
    int p;//该邻居在表中的下标
    struct _nbnode *next;
    _nbnode(int _p):p(_p){}
}nbnode,*nblist;
typedef struct _node{
    int id;
    char visit;
    nblist nblisthead;
    _node(){
        visit = 0;
        nblisthead = NULL;
    }
}node;

node *arr = new node[90000];//结点表
map&lt;int,int&gt; nodemap; //id 映射到 p
int edgecount = 0,nodecount = 0;

void bfs(int p){
    queue&lt;int&gt; q;
    q.push(p);
    arr[p].visit = 1;
    while(!q.empty()){
        nbnode *nb = arr[q.front()].nblisthead;
        while(nb != NULL){
            if(!arr[nb-&gt;p].visit){
                q.push(nb-&gt;p);
                arr[nb-&gt;p].visit = 1;
            }
            nb = nb-&gt;next;
        }
        q.pop();
    }
}
void BFS(){
    int componentcount = 0;
    for(int i = 0;i &lt; nodecount;i++){
        if (arr[i].visit == 0){
            bfs(i);
            componentcount++;
        }
    }
    printf(&quot;component: %d\n&quot;,componentcount);
}
void Load(){
    FILE *fp = fopen(&quot;twitter_small.txt&quot;,&quot;r+&quot;);
    nbnode *nb;
    int ida,idb,pa,pb;
    map&lt;int,int&gt;::iterator itera,iterb;
    while(fscanf(fp,&quot;%d&quot;,&amp;ida) != EOF){
        fscanf(fp,&quot;%d&quot;,&amp;idb);
        if((itera = nodemap.find(ida)) != nodemap.end()){
            pa = itera-&gt;second;
        }
        else{
            nodemap[ida] = nodecount;//向map中插入(ida,nodecount)
            pa = nodecount++;
            arr[pa].id = ida;
        }
        if((iterb = nodemap.find(idb)) != nodemap.end()){
            pb = iterb-&gt;second;
        }
        else{
            nodemap[idb] = nodecount;
            pb = nodecount++;
            arr[pb].id = idb;
        }
        nb = arr[pa].nblisthead;
        while(nb != NULL){
            if(nb-&gt;p == pb)//该边已存在
                goto LABEL;
            nb = nb-&gt;next;
        }
        nb = arr[pa].nblisthead;
        arr[pa].nblisthead = new nbnode(pb);
        arr[pa].nblisthead-&gt;next = nb;
        edgecount++;
        LABEL:;
    }
    printf(&quot;node: %d\n&quot;,nodecount);
    printf(&quot;edge: %d\n&quot;,edgecount);
}
int main(){
    clock_t t1,t2,t3,t4;
    t1 = clock();
    Load();
    t2 = clock();
    printf(&quot;Load time: %lf s\n&quot;,(double)(t2-t1)/CLK_TCK);
    printf(&quot;------------------------\n&quot;);
    t3 = clock();
    BFS();
    t4 = clock();
    printf(&quot;BFS time: %lf s\n&quot;,(double)(t4-t3)/CLK_TCK);
    return 0;
}
</code></pre>
<h5 id="large"><a href="#large" class="headerlink" title="large"></a>large</h5><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;
#include &lt;queue&gt;
using namespace std;
typedef struct _nbnode{
    int p;//该邻居在表中的下标
    struct _nbnode *next;
    _nbnode(int _p):p(_p){}
}nbnode,*nblist;
typedef struct _node{
    int id;
    char visit;
    nblist nblisthead;
    _node(){
        visit = -1;//-1不存在该结点，0存在但未访问，1，已访问
        nblisthead = NULL;
    }
}node;

node *arr = new node[11500000];//结点表
int edgecount = 0,nodecount = 0;

void bfs(int p){
    queue&lt;int&gt; q;
    q.push(p);
    arr[p].visit = 1;
    while(!q.empty()){
        nbnode *nb = arr[q.front()].nblisthead;
        while(nb != NULL){
            if(!arr[nb-&gt;p].visit){
                q.push(nb-&gt;p);
                arr[nb-&gt;p].visit = 1;
            }
            nb = nb-&gt;next;
        }

        q.pop();
    }
}
void BFS(){

    int componentcount = 0;
    for(int i = 0;i &lt; nodecount;i++){
        if (arr[i].visit == 0){
            bfs(i);
            componentcount++;
        }
    }
    printf(&quot;component: %d\n&quot;,componentcount);
}
void Load(){
    FILE *fp = fopen(&quot;twitter_large.txt&quot;,&quot;r+&quot;);
    nbnode *nb;
    int ida,idb,pa,pb;
    while(fscanf(fp,&quot;%d,%d&quot;,&amp;ida,&amp;idb) != EOF){
        pa = ida;
        pb = idb;
        if(arr[pa].visit == -1){
            nodecount++;
            arr[pa].visit = 0;
        }
        if(arr[pb].visit == -1){
            nodecount++;
            arr[pb].visit = 0;
        }
        nb = arr[pa].nblisthead;
        arr[pa].nblisthead = new nbnode(pb);
        arr[pa].nblisthead-&gt;next = nb;
        edgecount++;
    }
    printf(&quot;node: %d\n&quot;,nodecount);
    printf(&quot;edge: %d\n&quot;,edgecount);
}
int main(){
    clock_t t1,t2,t3,t4;
    t1 = clock();
    Load();
    t2 = clock();
    printf(&quot;Load time: %lf s\n&quot;,(double)(t2-t1)/CLK_TCK);
    printf(&quot;------------------------\n&quot;);
    t3 = clock();
    BFS();
    t4 = clock();
    printf(&quot;BFS time: %lf s\n&quot;,(double)(t4-t3)/CLK_TCK);
    return 0;
}
</code></pre>
<h5 id="random"><a href="#random" class="headerlink" title="random"></a>random</h5><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;
#include &lt;queue&gt;
using namespace std;
typedef struct _nbnode{
    int p;//该邻居在表中的下标
    struct _nbnode *next;
    _nbnode(int _p):p(_p){}
}nbnode,*nblist;
typedef struct _node{
    int id;
    char visit;
    nblist nblisthead;
    _node(){
        visit = -1;//-1不存在该结点，0存在但未访问，1，已访问
        nblisthead = NULL;
    }
}node;

node *arr = new node[100010];//结点表
int edgecount = 0,nodecount = 0;

void bfs(int p){
    queue&lt;int&gt; q;
    q.push(p);
    arr[p].visit = 1;
    while(!q.empty()){
        nbnode *nb = arr[q.front()].nblisthead;
        while(nb != NULL){
            if(!arr[nb-&gt;p].visit){
                q.push(nb-&gt;p);
                arr[nb-&gt;p].visit = 1;
            }
            nb = nb-&gt;next;
        }

        q.pop();
    }
}
void BFS(){

    int componentcount = 0;
    for(int i = 0;i &lt; nodecount;i++){
        if (arr[i].visit == 0){
            bfs(i);
            componentcount++;
        }
    }
    printf(&quot;component: %d\n&quot;,componentcount);
}
void Load(){
    FILE *fp = fopen(&quot;100000.txt&quot;,&quot;r+&quot;);
    nbnode *nb;
    int ida,idb,pa,pb;
    while(fscanf(fp,&quot;%d %d&quot;,&amp;ida,&amp;idb) != EOF){
        pa = ida;
        pb = idb;
        if(arr[pa].visit == -1){
            nodecount++;
            arr[pa].visit = 0;
        }
        if(arr[pb].visit == -1){
            nodecount++;
            arr[pb].visit = 0;
        }
        nb = arr[pa].nblisthead;
        arr[pa].nblisthead = new nbnode(pb);
        arr[pa].nblisthead-&gt;next = nb;
        edgecount++;
        if(edgecount % 1000000 == 0) printf(&quot;%d\n&quot;,edgecount);
        LABEL:;
    }
    printf(&quot;node: %d\n&quot;,nodecount);
    printf(&quot;edge: %d\n&quot;,edgecount);
}
int main(){
    clock_t t1,t2,t3,t4;
    t1 = clock();
    Load();
    t2 = clock();
    printf(&quot;Load time: %lf s\n&quot;,(double)(t2-t1)/CLK_TCK);
    printf(&quot;------------------------\n&quot;);
    t3 = clock();
    BFS();
    t4 = clock();
    printf(&quot;BFS time: %lf s\n&quot;,(double)(t4-t3)/CLK_TCK);
    return 0;
}


GenGraph.py

import random
for n in [10,100,1000,10000,100000]:
    s = set()
    while len(s) &lt; n:
        a = random.randint(1,int(n/3))
        b = random.randint(1,int(n/3))
        while a == b :
            b = random.randint(1,10)
        s.add((a,b))
    f = open(str(n)+&quot;.txt&quot;,&quot;w&quot;)
    for e in s:
        f.write(str(e[0])+&quot; &quot;+str(e[1])+&quot;\n&quot;)
    f.close()
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-mcps/lab_res" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/05/mcps/lab_res/" class="article-date">
      <time datetime="2018-12-04T16:00:00.000Z" itemprop="datePublished">2018-12-05</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/05/mcps/lab_res/">汇编上机资源</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><ol>
<li><p>使用<a href="./lab_res/emu8086setup.exe">Emu8086</a>仿真(支持DOS16位程序)</p>
<ul>
<li>emu8086不能用：<ol>
<li>32位寄存器</li>
<li>INVOKE </li>
<li>USES </li>
<li>.IF .ENDIF .ELSEIF</li>
<li>.REPEAT  .UNTIL</li>
</ol>
</li>
</ul>
</li>
<li><p>或者<a href="./lab_res/MASM_PLUS_1.2.exe">MASMPlus</a>+<a href="./lab_res/DOSBox0.74-2-win32-installer.exe">DOSBOX</a>(支持DOS16位或32位程序)</p>
<ul>
<li><p>详解从零开始配置汇编开发环境(DosBox,MasmPlus)</p>
<p><a href="https://blog.csdn.net/yongf2014/article/details/46273949" target="_blank" rel="noopener">https://blog.csdn.net/yongf2014/article/details/46273949</a></p>
</li>
<li><p>DOSBOX使用:<br>窗口太小问题<br><a href="https://blog.csdn.net/m0_37822685/article/details/80241598" target="_blank" rel="noopener">https://blog.csdn.net/m0_37822685/article/details/80241598</a><br>挂载指定目录<br><a href="https://jingyan.baidu.com/article/ce09321b7649012bff858f32.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/ce09321b7649012bff858f32.html</a></p>
</li>
</ul>
</li>
</ol>
<h3 id="Docs"><a href="#Docs" class="headerlink" title="Docs"></a>Docs</h3><ul>
<li><p><a href="./lab_res/DOS_Interrupts.html">DOS_Interrupts</a></p>
</li>
<li><p><a href="./lab_res/DOS_Error_Codes.html">DOS_Error_Codes</a></p>
</li>
<li><p>Win32汇编–使用 MASM<br><a href="https://www.cnblogs.com/poli/p/4737352.html" target="_blank" rel="noopener">https://www.cnblogs.com/poli/p/4737352.html</a></p>
</li>
</ul>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ul>
<li><p>PROC里记得RET，否则调用过程后不返回，将顺序执行</p>
</li>
<li><p>MACRO里的LABEL使用前用LOCAL限制在局部，否则多次调用宏会报重复</p>
</li>
<li><p>NUMS是WORD（字）数组，MOV NUMS[BX],AX 后BX应该加2才能下一次使用，如果加1，下一次是存在下一字节，而不是下一字，可能会覆盖之前的数据</p>
</li>
<li><p>int 21h是只能在DOS下使用，但不是只能16位模式，.386开关开启后仍可以使用</p>
</li>
<li><p>masmplus相关</p>
<ul>
<li><p>在dos上想使用32位寄存器的话<br>那就要 &gt;= .386</p>
</li>
<li><p>.386 ;指明指令集<br>.model flat,stdcall 程序工作模式,<br>flat为Windows程序使用的模式(代码和数据使用同一个4GB段),<br>stdcall为API调用时右边的参数先入栈</p>
<p>option casemap:none ;指明大小写敏感</p>
</li>
<li><p>过程结束不能只写<code>ENDP</code>,要完整<code>PROCNAME ENDP</code></p>
</li>
<li><p>调用没有参数的PROC时可直接CALL</p>
<p>有参数的应该用<code>INVOKE</code></p>
<pre><code class="assembly">INVOKE FGETN,FILEHANDLE,DNUMS[BX]
</code></pre>
<p>INVOKE格式</p>
<pre><code>invoke procedure, parameter1, parameter2, parameter3 
</code></pre><p>等价于手动PUSH参数，然后用CALL</p>
<pre><code>push parameter3
push parameter2
push parameter1
call procedure 
</code></pre></li>
<li><p>在masmplus中编译</p>
<pre><code class="assembly">CALC:
   BIGMUL D_N_FAC,D_TMP,D_I
   MOV8 D_TMP,D_N_FAC  
   CALL PRINTNHEX 
   PRINTNEWLINE
   INC D_I[0]  ;I++
   LOOP CALC 
</code></pre>
<p>提示</p>
<blockquote>
<p>error A2075: jump destination too far : by 22 byte(s)</p>
</blockquote>
<p>stackoverflow上查得原因是</p>
<blockquote>
<p><code>loop</code> has limited range. It can only jump up to 127 bytes ahead or 128 back in the instruction stream measured from the start of the following instruction.</p>
</blockquote>
<p>前面几条宏展开后指令非常长</p>
<p>把LOOP改用</p>
<pre><code class="assembly">DEC CX
CMP CX,0
JNE CALC
</code></pre>
<p>就行了 </p>
</li>
</ul>
</li>
<li><p>使用64位寄存器</p>
<ul>
<li><p><a href="https://www.cnblogs.com/DennyChen/p/8143629.html" target="_blank" rel="noopener">https://www.cnblogs.com/DennyChen/p/8143629.html</a><br>64位汇编要用ml64.exe</p>
<p><a href="https://bbs.csdn.net/topics/392154763?page=1" target="_blank" rel="noopener">https://bbs.csdn.net/topics/392154763?page=1</a><br>64位寄存器使用问题</p>
<p><a href="https://blog.csdn.net/cosmoslife/article/details/15020181" target="_blank" rel="noopener">https://blog.csdn.net/cosmoslife/article/details/15020181</a><br>x64汇编</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MCPS/">MCPS</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-mcps/lab4" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/03/mcps/lab4/" class="article-date">
      <time datetime="2018-12-02T16:00:00.000Z" itemprop="datePublished">2018-12-03</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/03/mcps/lab4/">汇编上机题4</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>编程计算任一整数加减运算表达式，其中，表达式长度不超过1024个字节，从键盘输入，可带括号，操作数为字数据</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="assembly">;思路
;(1)读一个取输入字符(存在CHARS数组)
;(2)读到&#39;(&#39;，记下位置，存在POS_LPAREN数组中，同时记下数量NUM_LPAREN，继续读字符
;(3)读到&#39;=&#39;，结束读,转(5)
;(4)如果遇到非法字符，报错，退出
;(5)开始一轮计算，从最右的左括号开始计算
;(6)GET_NUM1
;(7)GET_OP,若是&#39;)&#39;或&#39;=&#39;完成本轮计算，回填结果到CHARS数组，转(5)
;(8)GET_NUM2
;(9)NUM1 = NUM1 OP NUM2,转(7) 
;计算过程中已算过的部分用&#39;$&#39;填充，以后读取到直接跳过
.MODEL SMALL
    .STACK 100H
    .DATA       
    CHARS DB 1024 DUP(0)   ;输入串
    POS_LPAREN DB  512 DUP(0) ;左括号位置数组
    NUM_LPAREN DB 0            ;左括号数量
    NUM_LPAREN_UNMATCH DB 0            ;未配对的左括号数量
    LENGTH DW 0   ;输入串总长度
    OP DB 0
    CHAR DB 0
    TEMP1 DW 0
    TEMP2 DW 0
    ADDR DW 0    ;记录每次运算中左括号在CHARS的位置，便于存储
    ERRMSG1 DB 0DH,0AH,&quot;ILLEGAL CHAR!!!&quot;,&#39;$&#39;
    ERRMSG2 DB 0DH,0AH,&quot;UNMATCHED BRACKET!!!&quot;,&#39;$&#39;    
    ERRMSG3 DB 0DH,0AH,&quot;OPERATOR ERROR!!!&quot;,&#39;$&#39;
    INPUTFLAG DB 0 ;记录上一个输入字符的类型，1为数字，2为+或-
.CODE
.STARTUP  

;=====================================================================
GETCHAR MACRO  ;获取当前输入字符，存在AL
    MOV    AH, 1
    INT    21H
ENDM

PRINTS MACRO _PSTRING ;打印字符串
    PUSH AX
    PUSH DX
    MOV AH,9H
    LEA DX,_PSTRING
    INT 21H
    POP DX
    POP AX
ENDM

PRINTCHAR MACRO CHAR ;打印一个字符
    PUSH AX
    PUSH DX
    MOV    AH, 2
    MOV DL,CHAR
    INT    21H
    POP DX
    POP AX
ENDM

PRINTNUM MACRO NUM    ;打印一个16位整数,AX
    PUSH AX
    PUSH BX
    PUSH CX
    PUSH DX
    ;----------------  
    MOV AX,NUM
    MOV BX,10
    MOV CX,0
DPUSH:
    MOV DX,0
    DIV BX   ;DX:AX/10,即AX/10 商在AX，余数在DX
    PUSH DX ;余数即最低位，压栈
    INC CX  ;统计位数  
    CMP AX,0
    JZ DPOP  ;商为0，已经是最高位，开始出栈   
    JMP DPUSH    
DPOP:
    POP DX
    ADD DL,30H
    MOV AH,2H            
    INT 21H  ;打印栈顶的位        
    LOOP DPOP
    ;----------------
    POP DX
    POP CX
    POP BX
    POP AX
PRINTN ENDM

;=====================================================================



    LEA BX,CHARS 
    MOV CX,0 
    LEA DI,POS_LPAREN 
    INC DI    ;POS_LPAREN[0]不存储，从POS_LPAREN[1]开始
GETC:
    GETCHAR
    MOV [BX],AL         ;当前字符存进CHARS数组
    INC BX

    CMP AL,3DH
    JE  GETC_END        ;是&#39;=&#39;,

    CMP AL,&#39;(&#39;
    JNE GETC1           ;不是&#39;(&#39;,继续判断
    ;----------
    MOV [DI],CL         ;是&#39;(&#39; 存下当前&#39;(&#39;的位置
    INC DI 
    INC NUM_LPAREN      ;&#39;(&#39;数量++
    INC NUM_LPAREN_UNMATCH
    MOV INPUTFLAG,0 
    JMP GETC_CONTINUE
    ;---------- 
GETC1:  
    CMP AL,&#39;)&#39;
    JNE GETC2           ;不是&#39;)&#39;,继续判断
    ;----------
    DEC NUM_LPAREN_UNMATCH ;是&#39;)&#39;,减少未配对的&#39;(&#39;数
    MOV INPUTFLAG,0
    JMP GETC_CONTINUE
    ;---------- 
GETC2:
    CMP AL,&#39;+&#39;
    JZ GETC_OP_CHECK
    ;---------------    
    CMP AL,&#39;-&#39;
    JZ GETC_OP_CHECK
    ;---------------
    CMP AL,&#39;0&#39;
    JL ERROR1  ;非法字符
    CMP AL,&#39;9&#39;
    JG ERROR1  ;非法字符
    MOV INPUTFLAG,1 ;记录当前输入字符是数字
    JMP GETC_CONTINUE
GETC_OP_CHECK:
    CMP INPUTFLAG,2 
    JZ ERROR3  ;上一个输入字符是+或-,报错
    MOV INPUTFLAG,2 ;记录当前输入字符是+或-     
GETC_CONTINUE:  
    INC CX
    JMP GETC  
GETC_END: 
    INC CX
    MOV LENGTH,CX
    CMP NUM_LPAREN_UNMATCH,0
    JNZ ERROR2
    JMP CAL_PAREN
;----------------------------------------------------------
CAL_PAREN:  ;从当前最右的&#39;(&#39;开始计算
    LEA DI,POS_LPAREN 
    MOV BL,NUM_LPAREN  
    MOV BH,0
    ADD DI,BX     
    MOV AL,[DI]    ;读出ARRAY[num] ;AL=最右的即第NUM_LPAREN个&#39;(&#39;的位置
    MOV AH,0
    LEA DI,CHARS
    ADD DI,AX      ;DI加上偏移地址，得到左括号位置，即本轮开始读取的位置 
    MOV ADDR,DI    ;记下该位置，本轮结束后从这开始存结果
    ;-----------
    MOV DH,[DI]
    CMP DH,28H 
    JNE START_CAL  
    MOV DH,24H
    MOV [DI],DH
    INC DI
    JMP START_CAL

;-----------------------------------------------------------    
START_CAL:   

    PUSH AX 
    PUSH CX
    PUSH DX 
    MOV AX,0
    MOV CX,0
    MOV DX,0

GET_NUM1:
    MOV DH,[DI]    
    CMP DH,24H      ;读到$继续读 
    JE L3
    CMP DH,3DH      ;读到=输出
    MOV TEMP1,AX
    JE PRINTRESULT 
    CMP DH,24H
    JNE L2
L3:
    INC DI
    MOV DH,[DI]
    CMP DH,3DH  ;读到=输出 
    JE PRINTRESULT 
    CMP DH,28H  ;读到（就再读一位
    JE L3
    CMP DH,24H   ;读到$再读一位
    JE L3  
    JNE L2

L2: 
    MOV [DI],24H  ; 将$填入 
    INC DI  
    CMP DH,2DH     
    MOV CHAR,DH    ;每个字符存入CHAR，若为算符就跳入存进OP
    JLE RETU1     ;小于&#39;-&#39;，即不是数字，该整数已完成读取
    ;继续该数的读取           
    SUB DH,30H       ;计算第一个数字TEMP1；就每读一个字符（ASCII)，减去30H ，若下一个字符还是数字，就将这个数字乘10再加上下一个字符，依次进行 
    MOV DL,DH
    MOV DH,0 
    PUSH DX
    MOV CX,10
    MUL CX 
    POP DX
    ADD AX,DX 
    JMP GET_NUM1   

RETU1:
    MOV TEMP1,AX    ;存入TEMP1 
    JMP GET_OP 
;-----------------------------------        
GET_OP: 
    MOV DH,CHAR      
    CMP DH,3DH       ;若为=则输出，
    JE PRINTRESULT 
    CMP DH,29H        ;若为）则完成本轮计算 
    JE  FINISH_CAL
    MOV OP,DH   
    MOV AX,0
    JMP GET_NUM2
;-----------------------------------  
JUDGE_OP:         ;读到&amp;就再读一个字符，一定为- 
    INC DI
    MOV DH,[DI]
    INC DI
    CMP DH,OP       ;与读取NUM2前的OP进行比较，+-为负，--为正
    JNE L14 
    MOV DH,28H        ;OP更换为+ 
    MOV OP,DH
    JMP GET_NUM2      
L14:
    MOV OP,DH        ;OP更换为- 
    JMP GET_NUM2
;-----------------------------------      
GET_NUM2: ;类似GET_NUM1，一轮中GET_NUM1后，不断GET_OP GET_NUM2
    MOV DH,[DI] 
    MOV CHAR,DH
    CMP DH,3DH   ;&#39;=&#39; 
    JE RETU2
    CMP DH,26H   ;&#39;&amp;&#39;
    JE JUDGE_OP
    CMP DH,24H   ;&#39;$&#39;
    JNE L4
L5:
    INC DI
    MOV DH,[DI] 
    CMP DH,3DH   ;&#39;=&#39;
    JE RETU2  
    CMP DH,28H   ;&#39;(&#39;
    JE L5
    CMP DH,24H   ;&#39;$&#39;
    JNE L4
    JE L5
L4:
    MOV [DI],24H ; 将$填入
    INC DI
    CMP DH,2DH   ;&#39;-&#39;
    MOV CHAR,DH 
    JLE RETU2    ;小于&#39;-&#39;，即不是数字，该整数已完成读取
    ;继续该整数的读取，-30H，AX*10再加该位 
    SUB DH,30H
    MOV DL,DH
    MOV DH,0
    MOV CX,10 
    PUSH DX
    MUL CX  
    POP DX
    ADD AX,DX 
    JMP GET_NUM2   

RETU2:
    MOV TEMP2,AX
    JMP CAL1
;----------------------------------------------------------    
CAL1:
    CMP OP,2DH ;&#39;-&#39; 
    MOV AX,0
    JE TOSUB
    JNE TOADD      
TOSUB:
    MOV DX,TEMP2
    SUB TEMP1,DX 
    MOV TEMP2,0
    JMP GET_OP  
TOADD:
    MOV DX,TEMP2
    ADD TEMP1,DX
    MOV TEMP2,0 
    JMP GET_OP
;--------------------------------------------------------- 

FINISH_CAL: 
    MOV AX,TEMP1  
    MOV DI,ADDR ;本轮开始读取的位置，从这开始存结果 
    CMP AX,0
    JGE SAVETEMP1   ;TEMP1大于0,直接存 
    ;若TEMP1小于0，则先存入&amp;，再存入- 
    MOV [DI],26H
    INC DI
    MOV [DI],2DH
    INC DI
    ;--------取正TEMP1，用0-TEMP1使其变正
    MOV CX,0 
    SUB CX,AX
    MOV AX,CX

SAVETEMP1:;将（取正后的）TEMP1以字符串存进CHARS数组，
    PUSH BX
    PUSH CX
    PUSH DX
    ;----------------  
    MOV BX,10
    MOV CX,0
DPUSH1:
    MOV DX,0
    DIV BX   ;DX:AX/10,即AX/10 商在AX，余数在DX
    PUSH DX ;余数即最低位，压栈
    INC CX  ;统计位数  
    CMP AX,0
    JZ DPOP1  ;商为0，已经是最高位，开始出栈   
    JMP DPUSH1    
DPOP1:
    POP DX
    ADD DL,30H
    MOV [DI],DL
    INC DI    
    LOOP DPOP1
    ;----------------
    POP DX
    POP CX
    POP BX
    ;---------------- 

    DEC NUM_LPAREN  
    POP DX
    POP CX
    POP AX



;-----------------------------------------------------------     
ENDJUDGE:
    CMP NUM_LPAREN,0
    JGE CAL_PAREN ;&#39;(&#39;数量&gt;0，开始新的一轮计算
    JMP PRINTRESULT ;结束，打印

;--------------------------------下面是结果输出 

PRINTRESULT:
    MOV AX,TEMP1    
    CMP AX,0 
    JGE POSTIVE  ;大于等于0，直接开始打印
    MOV CX,0 
    SUB CX,AX    
    MOV AX,CX    ;小于0，取出正数
    PRINTCHAR 2DH ;打印‘-’
POSTIVE:
    PRINTNUM AX

    JMP CEND


ERROR1:
    PRINTS ERRMSG1
    JMP CEND
ERROR2:
    PRINTS ERRMSG2
    JMP CEND   
ERROR3:
    PRINTS ERRMSG3
    JMP CEND 
CEND:

.EXIT
END
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MCPS/">MCPS</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-alg/lab4" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/02/alg/lab4/" class="article-date">
      <time datetime="2018-12-01T16:00:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/02/alg/lab4/">算法基础上机实验四 最佳调度问题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>最佳调度问题</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>设有n个任务由k个可并行工作的机器来完成，完成任务i需要时间为ti。试设计一个算法找出完成这n个任务的最佳调度，使完成全部任务的时间最早。（要求给出调度方案）</p>
<p>完成全部任务的时间为运行时间最长的机器上运行的总时间，所有机器都是相同的。一个任务只能在一个机器上完成，且在完成之前不会被其他任务抢占。</p>
<h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><h5 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h5><p>回溯法是一个既带有系统性又带有跳跃性的搜索算法。</p>
<ul>
<li><p>系统性：它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。</p>
</li>
<li><p>跳跃性：算法搜索至解空间树的任一结点时，判断该结点为根的子树是否包含问题的解，如果肯定不包含，则跳过以该结点为根的子树的搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。</p>
</li>
</ul>
<p>这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。</p>
<p>提高回溯法效率的二种方法</p>
<ul>
<li><p>用约束函数剪去不满足约束的子树；</p>
</li>
<li><p>用限界函数剪去不能得到最优解的子树。</p>
</li>
</ul>
<p>最佳调度问题可以用回溯法解决，并且是属于子集树回溯法。对于每个任务i，都可能分配到k台机器的任意一台上，解空间为<img src="//lyncien.github.io/2018/12/02/alg/lab4/clip_image002.png" alt="img">，现在要求的是使得最长机器时间最短的解。</p>
<p>回溯算法伪代码如下：</p>
<pre><code>BackTrack(int task,int spendtime){
    if (task == n){ //分配完毕
        if(spendtime &lt; besttime){
            besttime = spendtime;
            记下当前最优解的方案;
        }
        return ;
    }
    for(每台机器j){
        将任务task分配给当前机器j;
        机器j的时间 += 任务task的时间;
        BackTrack(task + 1,max(spendtime,机器j的时间));
        回溯，不将任务task分配给当前机器j，用0表示未分配;
        机器j的时间 -= 任务task的时间;
    }
    return ;
}
</code></pre><p>初始时调用BackTrack(1,0);</p>
<p>如果只是简单的回溯，解空间随着n和k的增大呈指数级增长，时间复杂度达O(k^n)，为此，这里进行了几处优化：</p>
<ul>
<li><p>最优化剪枝——如果当前各个机器时间中的最长时间，即spendtime已经大于最佳方案的时间（besttime），则不再继续向下一层搜索。</p>
</li>
<li><p>初始解——使用贪心的方法求得一个初始解，即得到一个初始的besttime，这样可以让besttime尽快地减少至接近最后的结果，使得上面的剪枝能更早地抛弃不需要的子树。贪心的策略是，每次分配当前任务都选择最短时间的机器。</p>
</li>
<li><p>预排序——初始时，任务按时间降序排列，即从时间最长的任务开始分配，这样可以加强上面的剪枝，减少不必要的搜索层次</p>
</li>
<li><p>去除重复的搜索——由于机器之间是无差别的，而一台机器分配的任务也是无序的。对于某个方案，对所有机器进行重新排列，以及对一台机器的任务重新排列，得到的任意一个方案对于这个问题都是等价的（最佳调度时间相同）。因此，搜索时，只考虑按每台机器的最长的任务的时间降序排列的那种方案。由于任务分配前已按时间降序排列，故放入一台空机器的第一个任务就是该机器的最长时间的任务。如果当前要放入一台空机器的任务时间大于前一台机器的最长任务的时间就说明情况重复了，不用继续搜索。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li>
</ul>
<pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#define MAXTASK 100           //最大任务数
#define MAXMACHINE 100          //最大机器数
using namespace std;
int n,k;                    //n：任务数，k:机器数
int times[MAXTASK];         //每个任务对应的时间
int schedule[MAXTASK];      //当前调度方案，每个任务分配的机器号，取0表示还未分配
int machinetime[MAXMACHINE] = {};    //每个机器工作的总时间,机器下标从1开始算
int machinemaxtasktime[MAXMACHINE] = {};

int besttime = 999999999;     //最优解，即完成全部任务最短时间，初始化为无穷大
int bestschedule[MAXTASK];   //最优解的调度方案
int max(int a,int b){
    return a &gt; b ? a : b;
}
bool cmp(int a,int b) {
    return a &gt; b;
}
int init(){//贪心地求出初始解
    int tmpmachinetime[MAXMACHINE]={};
    int minmachine,mintime = 999999999;
    int spendtime = 0;
    for(int i = 1;i &lt;= k;i++){
        tmpmachinetime[i] = times[i];//前k个任务分配给k个机器
    }
    for(int i = k + 1;i &lt;= n;i++){
        for(int j = 1;j &lt;= k;j++){
            if(tmpmachinetime[j] &lt; mintime){
                mintime = tmpmachinetime[j];
                minmachine = j;
            }
        }
        tmpmachinetime[minmachine] += times[i];
        spendtime = max(spendtime,tmpmachinetime[minmachine]);
    }
    return spendtime;
}
void BackTrack(int task,int spendtime){ //子集树回溯法
    if (task == n){ //分配完毕
        if(spendtime &lt; besttime){           //可行解与当前最优解进行比较
            besttime = spendtime;
            for(int i = 0;i &lt; n;i++) //记下当前最优解的方案
                bestschedule[i] = schedule[i];
        }
        return ;
    }
    for(int j = 1;j &lt;= k;j++){
        if(max(spendtime,machinetime[j] + times[task]) &lt; besttime){
        //剪枝，若当前最长机器时间已经超出最少时间，则不继续搜索
            if(machinetime[j] == 0){//当前机器是空的
                if(machinemaxtasktime[j - 1] &lt; times[task])
                    break;
                    //对于一个可行解对应的方案，把各个机器重新排序，是等价的
                    //故我们只保留按每台机器最长任务的时间降序的方案
                    //由于任务分配前按时间降序排列，放入一台空机器的第一个任务就是该机器的最长时间的任务
                    //如果当前要放入一台空机器的任务时间大于前一个机器的最长任务的时间
                    //说明情况重复了
                machinemaxtasktime[j] = times[task];
            }
            schedule[task] = j;          //将任务t分配给当前机器j
            machinetime[j] += times[task];
            BackTrack(task + 1,max(spendtime,machinetime[j]));
            schedule[task] = 0;         //回溯，不将任务t分配给当前机器j，0表示未分配
            machinetime[j] -= times[task];
            if(machinetime[j] == 0) //恢复
                machinemaxtasktime[j] = 0;
        }
    }
    return ;
}
int main(){
    FILE *fp = fopen(&quot;in3.txt&quot;,&quot;r&quot;);
    fscanf(fp,&quot;%d%d&quot;,&amp;n,&amp;k);
    for(int i = 0;i &lt; n;i++){
        fscanf(fp,&quot;%d&quot;,&amp;times[i]);
    }
    fclose(fp);

    sort(times,times + n,cmp); //times按降序排序
    besttime = init();
    machinemaxtasktime[0] = 999999999;

    printf(&quot;----------------------------Input----------------------------\n&quot;);
    printf(&quot;Task Time\n&quot;);
    for(int i = 0;i &lt; n;i++)
        printf(&quot;%4d %4d\n&quot;,i,times[i]);

    BackTrack(0,0);       //子集树回溯法

    printf(&quot;----------------------------Output----------------------------\n&quot;);
    printf(&quot;Best time: %d\n&quot;,besttime);
    printf(&quot;Task Machine\n&quot;);  //按任务对应的机器输出
    for(int i = 0;i &lt; n;i++)
        printf(&quot;%4d %4d\n&quot;,i,bestschedule[i]);
    printf(&quot;Machine  Task_list\n&quot;); //按机器对应的任务输出
    int tmp[MAXMACHINE][MAXTASK]={}; //第一维为机器下标，第二维第0个为任务数，之后为任务下标列表
    for(int i = 0;i &lt; n;i++){ //i为任务下标
        int j = bestschedule[i]; //该任务对应的机器下标
        int l = ++tmp[j][0]; //当前机器分配的任务数+1
        tmp[j][l] = i;
    }
    for(int j = 1;j &lt;= k;j++){
        printf(&quot;%4d    &quot;,j);
        for(int i = 1;i &lt;= tmp[j][0];i++)
            printf(&quot;%4d&quot;,tmp[j][i]);
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-mcps/lab3" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/11/26/mcps/lab3/" class="article-date">
      <time datetime="2018-11-25T16:00:00.000Z" itemprop="datePublished">2018-11-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/26/mcps/lab3/">汇编上机题3</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>计算N!（0&lt;N&lt;20）</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="assembly">.MODEL SMALL    

.DATA
    D_N DW 4 DUP(0) ;N   (64bit)
    D_N_FAC DW 4 DUP(0) ;N!    (64bit)
    D_TMP DW 4 DUP(0) 
    D_I DW 4 DUP(0) 
    MAP DB &quot;0123456789ABCDEF&quot; 
    Q_TMP DW 0   
    R_TMP DW 0
.CODE

PRINTNEWLINE MACRO _PSTRING ;打印换行符
    PUSH AX
    PUSH DX
    MOV AH,2
    MOV DL,0DH
    INT 21H 
    MOV DL,0AH
    INT 21H
    POP DX
    POP AX
ENDM




PRINTNHEX PROC          ;打印一个64位整数(16进制)
    PUSHA         
    ;---------------- 
    MOV BX,7
    MOV CX,8
PLOOP:
    MOV AL,BYTE PTR D_N_FAC[BX] 
    MOV AH,0
    ;CMP AX,0
    ;JZ PEND:
    MOV DL,10H 
    DIV DL  ;商在AL，余数在AH
    MOV BYTE PTR Q_TMP,AL
    MOV BYTE PTR R_TMP,AH 
    MOV DI,Q_TMP   
    MOV DL,BYTE PTR MAP[DI] 
    MOV AH,2H
    INT 21H  
    MOV DI,R_TMP
    MOV DL,BYTE PTR MAP[DI]
    MOV AH,2H
    INT 21H 
    ;PEND:
    DEC BX             
    LOOP PLOOP       
    ;----------------
    POPA
    RET
ENDP

MOV8 MACRO DATAA,DATAB
    PUSH AX
    MOV AX,DATAB[0]
    MOV DATAA[0],AX
    MOV AX,DATAB[2]
    MOV DATAA[2],AX
    MOV AX,DATAB[4]
    MOV DATAA[4],AX
    MOV AX,DATAB[6]
    MOV DATAA[6],AX 
    POP AX
ENDM

BIGMUL MACRO RES,A,B  
    PUSHA
    ;----------------
    MOV WORD PTR RES[0],0
    MOV WORD PTR RES[2],0
    MOV WORD PTR RES[4],0
    MOV WORD PTR RES[6],0
    MOV CX,4
    MOV BX,0
    LOOP1:
    MOV DI,0
    PUSH CX
    ;------------
        LOOP2:
        MOV AX,B[BX]
        MUL A[DI] ;DX:AX=A[DI]*B[BX]
        MOV SI,BX
        ADD SI,DI ;SI=BX+DI 
        ADD WORD PTR RES[SI],AX
        PUSHF
        CMP SI,6
        JZ AEND
        POPF
        ADC WORD PTR RES[SI+2],DX
        PUSHF  
        CMP SI,4
        JZ AEND
        POPF
        ADC WORD PTR RES[SI+4],0
        PUSHF 
        CMP SI,2
        JZ AEND
        POPF
        ADC WORD PTR RES[SI+6],0  
        JMP AEND2
        AEND:
        POPF
        AEND2:
        ADD DI,2
        LOOP LOOP2  
    ;------------
    POP CX
    ADD BX,2
    LOOP LOOP1
    ;----------------
    POPA 
ENDM 


.STARTUP

    MOV WORD PTR D_N[0],19
    MOV CX,WORD PTR D_N[0] ;循环次数
    MOV D_I[0],1 ;当前i
    MOV D_TMP[0],1 ;临时结果
CALC:
    BIGMUL D_N_FAC,D_TMP,D_I
    MOV8 D_TMP,D_N_FAC  
    CALL PRINTNHEX 
    PRINTNEWLINE
    INC D_I[0]  ;I++
    LOOP CALC 


.EXIT 

END
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MCPS/">MCPS</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-alg/lab3" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/11/25/alg/lab3/" class="article-date">
      <time datetime="2018-11-24T16:00:00.000Z" itemprop="datePublished">2018-11-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/25/alg/lab3/">算法基础上机实验三 最长公共子序列问题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>最长公共子序列问题和调研报告</p>
<h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p><strong>1.</strong> <strong>最长公共子序列问题</strong>（Longest common subsequence problem）的定义</p>
<p>​       <strong>子序列</strong>：给定序列X=(x1,x2,…,xm)，序列Z=( z1,z2,…,zk)是X的一个子序列，必须满足：若X的索引中存在一个严格增的序列i1,i2,…,ik，使得对所有的j=1~k，均有xij=zj</p>
<p>​       <strong>公共子序列（CS）</strong>：Z是X和Y的子序列，则Z是两者的公共子序列CS。</p>
<p>​       <strong>最长公共子序列（LCS）：</strong>在X和Y的CS中，长度最大者为一个最长公共子序列</p>
<p><strong>2.</strong> <strong>用动态规划求解LCS</strong></p>
<p>（1）刻画LCS最优解的结构特征</p>
<p>如果用暴力搜索的方法求解LCS，就要穷举X的所有子序列，对每个子序列检查他是否也是Y的子序列，记录找到的最长子序列。X的每个子序列对应X的下标集合是{1,2,…,m}的一个子集，所以X有2m个子序列，时间复杂度为指数阶，真实情况下无法接受。</p>
<p>通过下面的定理，我们可以知道最长公共子序列问题具有最优子结构性质，可以用动态规划方法解决。</p>
<p><strong>定义</strong> X的ith前缀：Xi=(x1,x2,…,xm)，i=1~m，X0=φ (空集)。</p>
<p><strong>定理</strong> 设序列X=(x1,x2,…,xm)和Y=(y1,y2,…,yn)，Z=(z1,z2,…,zk)是X和Y的任意一个LCS，则有</p>
<p>①若xm=yn, ==&gt; zk=xm =yn且Zk-1是Xm-1和Yn-1的一个LCS;</p>
<p>②若xm!=yn且zk!=xm, ==&gt; Z是Xm-1和Y的一个LCS;</p>
<p>③若xm!=yn且zk!=yn, ==&gt; Z是X和Yn-1的一个LCS;</p>
<p>（证明略去）</p>
<p>由此可见，2个序列的最长公共子序列可由(1)(2)(3)算出，(2)(3)的解是对应子问题的最优解。因此，最长公共子序列问题具有最优子结构性质。</p>
<p>（2）子问题的递归解</p>
<p>上面的定理意味着我们求解X和Y的一个LCS时需要求解一个或两个子问题：</p>
<p>①如果 xm=yn 则</p>
<p>找Xm-1和Yn-1的LCS；</p>
<p>②如果 xm!=yn 则 </p>
<p>找Xm-1和Y的LCS 和 找X和Yn-1的LCS；</p>
<p>取两者中的最大的；</p>
<p>​       定义c[i,j]=Xi和Yj的LCS长度，i=0~m, j=0~n，则有如下公式</p>
<p><img src="//lyncien.github.io/2018/11/25/alg/lab3/clip_image002.jpg" alt="img"></p>
<p>（3）计算最优解和构造LCS</p>
<p>根据上面的公式，我们可以使用自底向上的动态规划方法。若X和Y的长度分别为m和n，则时间复杂度为O（mn）。</p>
<p>使用如下变量</p>
<p>c[0..m, 0..n] //二维数组，存放最优解值，计算时行优先</p>
<p>b[1..m, 1..n] //二维数组，解矩阵，存放构造最优解信息</p>
<p><img src="//lyncien.github.io/2018/11/25/alg/lab3/clip_image004.png" alt="img"></p>
<p>当构造解时，从b[m,n]出发，上溯至i=0或j=0止</p>
<p>上溯过程中，当b[i,j]包含“↖”时打印出xi(yj)</p>
<p>（4）进一步改进</p>
<p>对于表c，事实上，每个c[i,j]只依赖与其他三项：c[i-1,j]、c[i,j-1]和c[i-1,j-1]，因此，表c可以进一步压缩，无需O（mn）空间。</p>
<p>两种思路：</p>
<p>① c[i-1,j]、c[i,j-1]和c[i-1,j-1]只涉及当前行和上一行，因此表c只需保留两行，反复利用这两行，原先第i行的数据可以覆盖在第i-2行上。同时选取min（m,n）为行的长度。</p>
<p>②表c只保留一行，选取min（m,n）为行的长度，假设为n，则表c[1…n]。原来计算c[i,j]，现在计算c[j]。另外增设一个变量tmp，每次计算c[j]后，把原先c[j]值保存在tmp中。 </p>
<p><img src="//lyncien.github.io/2018/11/25/alg/lab3/clip_image006.png" alt="img"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="c++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define MAXLEN 100
int c[MAXLEN][MAXLEN]={};
int b[MAXLEN][MAXLEN]={};
int m,n;
char s1[MAXLEN],s2[MAXLEN];
void printlcs(int i,int j){
    if(i == 0 || j == 0)
        return ;
    if(b[i][j] == 1){ //指向左上,i-1,j-1
        printlcs(i-1,j-1);
        printf(&quot;%c&quot;,s1[i-1]);
    }
    else if(b[i][j] == 2)//指向上,i-1,j
        printlcs(i-1,j);
    else                //指向左,i,j-1
        printlcs(i,j-1);
}
void lcs(){
    m = strlen(s1);
    n = strlen(s2);
    int i,j;
    for(i=1;i&lt;=m;i++){
        for(j=1;j&lt;=n;j++){
            if(s1[i-1] == s2[j-1]){ //s1[1..i]和s2[1..j]的LCS是s1[1..i-1]和s2[1..j-1]的LCS的长度加1
                c[i][j] = c[i-1][j-1] + 1;
                b[i][j] = 1;
            }
            else if(c[i-1][j] &gt;= c[i][j-1]){//s1[1..i]和s2[1..j]的LCS就是s1[1..i-1]和s2[1..j]的LCS
                c[i][j] = c[i-1][j];
                b[i][j] = 2;
            }
            else{//s1[1..i]和s2[1..j]的LCS就是s1[1..i]和s2[1..j-1]的LCS
                c[i][j] = c[i][j-1];
                b[i][j] = 3;
            }
        }
    }
    printlcs(m,n);
    printf(&quot;\n%d\n&quot;,c[m][n]);
}
int main(){
    printf(&quot;input the first string:&quot;);
    scanf(&quot;%s&quot;,s1);
    printf(&quot;input the second string:&quot;);
    scanf(&quot;%s&quot;,s2);
    lcs();
    return 0;
}
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这次实验让我比较深入地了解了动态规划的使用条件及其应用。动态规划要求解问题必须满足最优子结构，即该问题的最优解包含其子问题的最优解。动态规划与分治法相似，都是通过组合子问题的解来求解原问题，但分治法将原问题划分为互不相交的子问题，递归地求解子问题，而动态规划适用于子问题重叠的情况，并且对于每个子问题只求解一次，将其解保存在一个表格中，避免了不必要的计算。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-mcps/lab2" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/11/19/mcps/lab2/" class="article-date">
      <time datetime="2018-11-18T16:00:00.000Z" itemprop="datePublished">2018-11-19</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/19/mcps/lab2/">汇编上机题2</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>编程实现排序算法，对某文件（txt格式）中的无符号整数进行排序，排序结果输出到屏幕（数据的个数不超过1024）</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="assembly">.MODEL SMALL,STDCALL

.DATA
    N DW 0
    TMP DW 1 DUP (0)
    NUMS DW 1024 DUP (0)   
    MSG_ERR DB 0dh,0ah,&#39;THERE ARE SOME ERRORS IN OPERATING THE FILE!&#39;,&#39;$&#39;  
    MSG_SUCCESS db 0dh,0ah,&#39;SORT RESULT:&#39;,&#39;$&#39;
    FILEHANDLE DW 0
    FILENAME DB &quot;test2.txt&quot;
    TMPC DB 1 DUP (0)
.CODE   

PRINTC MACRO CHAR;打印字符
    PUSH AX
    PUSH DX 
    MOV AH,2
    MOV DL,CHAR
    INT 21H
    POP DX
    POP AX     
ENDM 

PRINTS MACRO PSTRING ;打印字符串
    PUSH AX
    PUSH DX
    MOV AH,9H
    LEA DX,PSTRING
    INT 21H
    POP DX
    POP AX
ENDM

PRINTN PROC    ;打印一个16位整数,AX
    ;PUSH AX
    PUSH BX
    PUSH CX
    PUSH DX
    ;----------------
    MOV BX,10
    MOV CX,0
DPUSH:
    MOV DX,0
    DIV BX   ;DX:AX/10,即AX/10 商在AX，余数在DX
    PUSH DX ;余数即最低位，压栈
    INC CX  ;统计位数  
    CMP AX,0
    JZ DPOP  ;商为0，已经是最高位，开始出栈   
    JMP DPUSH    
DPOP:
    POP DX
    ADD DL,30H
    MOV AH,2H            
    INT 21H  ;打印栈顶的位        
    LOOP DPOP
    ;----------------
    POP DX
    POP CX
    POP BX
    ;POP AX
    RET
PRINTN ENDP

FGETN PROC ;从文件读取一个16位整数,结果在AX  
    PUSH BX
    PUSH CX
    PUSH DX    

    MOV CX,5 ;数的文本长度，最长5位
    MOV AX,0 ;乘法用的AX,初始化
LOOP1:
    ;-------------------READCHAR
    PUSH AX
    PUSH BX
    PUSH CX
    PUSH DX
    MOV AH,3FH
    MOV BX,FILEHANDLE
    MOV CX,1  ;读取长度
    LEA DX,TMPC;用于暂存读取的串
    INT 21H   ;读取后AX存放实际读取出的字符数
    JC R_ERR ;CF=1 出错
    CMP AX,0
    JZ R_QUIT ;AX=0, EOF
    CMP TMPC[0],20H
    JZ R_QUIT ;空格
    POP DX
    POP CX
    POP BX
    POP AX
    ;-------------------
    MOV DX,10 ;DX=10
    MUL DX    ;DX:AX=AX*10 由于读取的是16位无符号整数，最后只会在AX中,DX一直是10 
    SUB TMPC[0],30H ;
    ADD AX,WORD PTR TMPC[0] 
    LOOP LOOP1 
R_QUIT:
    POP DX
    POP CX
    POP BX
    POP AX    
    ;此时AX为读取的数
    JMP R_END

R_ERR:
    POP DX
    POP CX
    POP BX
    POP AX
R_END:
    POP DX
    POP CX
    POP BX
    RET
FGETN ENDP

SORT PROC ;冒泡排序
    PUSH AX
    PUSH BX
    PUSH CX
    PUSH DX    

    MOV CX,N 
    DEC CX    ;外循环次数为N-1
    SLOOP1:
    PUSH CX  ;把外循环计数器存下来
    ;-------------------
        MOV BX,0
        SLOOP2: ;外循环计数器也是内循环次数
        MOV AX,NUMS[BX]
        INC BX
        INC BX
        MOV DX,NUMS[BX]
        CMP AX,DX
        JZ NOEXCHANGE  ;AX=DX 
        JC NOEXCHANGE  ;AX&lt;DX
        EXCHANGE:      ;AX&gt;DX
            MOV NUMS[BX],AX
            DEC BX
            DEC BX
            MOV NUMS[BX],DX
            INC BX
            INC BX
        NOEXCHANGE:
        LOOP SLOOP2
    ;-------------------
    POP CX  ;取出外循环计数器
    LOOP SLOOP1

    POP DX
    POP CX
    POP BX
    POP AX
    RET
SORT ENDP

.STARTUP
    ;打开文件
    LEA DX,FILENAME ;MOV DX,OFFSET _FILENAME
    MOV AH,3DH 
    MOV AL,2    
    INT 21H
    JC ERROR ;出错
    ;---------
    MOV FILEHANDLE,AX   ;保存句柄
    CALL FGETN ;读取第一个数，表示接下来有几个数据
    MOV N,AX
    CALL PRINTN
    PRINTC 0DH
    PRINTC 0AH
    MOV BX,0
    MOV CX,N
FREAD:
    CALL FGETN
    MOV NUMS[BX],AX
    CALL PRINTN
    PRINTC 20H
    INC BX
    INC BX ;由于是字节，下标每次要加2
     LOOP FREAD

     ;---------
    CALL SORT
    ;---------

    PRINTS MSG_SUCCESS  
    PRINTC 0DH
    PRINTC 0AH

    MOV CX,N
    MOV BX,0
PRINTRESULT:
    MOV AX,NUMS[BX]
    CALL PRINTN
    PRINTC 20H
    INC BX
    INC BX

    LOOP PRINTRESULT

    JMP TOEND
    ;---------
ERROR:
    PRINTS MSG_ERR
    CALL PRINTN; 打印AX存储的错误码
TOEND:
    MOV    AH, 4CH ;按任意键结束 
    INT    21H

.EXIT 

END


</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MCPS/">MCPS</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2019 Lyncien
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 1;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>