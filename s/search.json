[{"title":"安全意识","url":"/s/p/btthcc/","content":"**生命安全第一，其他都是浮云**######-虽然没有千里眼和顺风耳，但是走路也要尽量眼观六路耳听八方，不要看手机，不要胡思乱想，利用这点时间没有意义-过马路，即使有车辆停下让你，也要慢慢走过去，并且时刻观察两侧，因为不是所有的车辆都会让你-不停留在车辆盲区-远离大车-注意脚下的任何井盖，尽可能不从上面走-注意头上可能的掉落物，不要在建筑边缘停留，要么进去，要么出来-进入陌生建筑，尽可能摸清所有出口和逃生路线-如果不会游泳，不要靠近水边-不要倚靠任何护栏-地铁门灯亮时，不要赶着进去，等下一班-在地铁上不要靠近门，尽可能靠中间-电梯门开时观察电梯是否正常到达，不要低着头就往前走-不要停留在电梯门缝中间-登山时谨记：走路不观景，观景不走路。-不要在山上用雨伞，少坐缆车######-不要边充电边玩手机-雷雨天不要在空旷地区、树下和窗边滞留，不要打电话-条件允许的情况下，切断电源再使用热水器-不了解的食物不入口-水杯不离身或视线**做到以上，然后听天由命**","tags":["other"],"categories":[]},{"title":"LeetCode刷题笔记——理解二叉树的非递归遍历II","url":"/s/p/bmnwen/","content":"未完成..待续 在上一篇中，我们讨论了迭代遍历二叉树的各种细节，这篇主要讲重建二叉树##根据遍历结果/序列重建二叉树 首先假定原二叉树所有节点的值不相同，否则没有意义 比如极端情况所有节点的值都一样，这样无论是正常树状还是一条链状结构，任意遍历方式结果都一样，无法保留任何结构信息 这里的遍历结果/序列通常指以顺序容器存储的数值序列或包括空结点标记的字符串序列###直接遍历的结果 直接遍历二叉树的结果丢失了结构信息，无法对根节点和左右子树进行分离：-中序序列无法确定根节点-先序序列（首元素为根节点）和后序序列（尾元素为根节点）无法确定左右子树的分界点###多种直接遍历的结果####先序+中序/后序+中序 可以由 先序序列+中序序列 或者 后序序列+中序序列 唯一确定一棵二叉树，思路如下 首先先序序列和后序序列可以确定根节点的值（分别在首尾） 然后在中序序列中定位到根节点的位置，其之前即为左子树中序序列，其之后为右子树中序序列（即使两者之一或都是空子树，也能确定左右关系）#####先序+中序 遍历先序遍历的结果（另外维护一个遍历中序遍历的下标） 如果当前节点不是下一个中序遍历的节点，则不断进入左子树（把当前节点接在栈顶结点的左子树，并压栈） 如果当前节点是下一个中序遍历的节点，说明当前节点没有左子树？ 栈中节点为「还没有确定右孩子的节点」 ```python def buildTree(preorder,inorder):if not preorder:return None root=TreeNode(preorder[0])stack=[root]inorderIndex=0 for val in preorder[1:]:currNode=TreeNode(val)if stack[-1].val !=inorder[inorderIndex]:stack[-1].left=currNode else:while stack and stack[-1].val==inorder[inorderIndex]:node=stack.pop()inorderIndex+=1 node.right=currNode stack.append(currNode)return root ```#####后序+中序 和上面的实现对称 ```python def buildTree(inorder,postorder):if not postorder:return None root=TreeNode(postorder[-1])stack=[root]inorderIndex=len(inorder)-1 for val in reversed(postorder[:-1]):currNode=TreeNode(val)if stack[-1].val !=inorder[inorderIndex]:stack[-1].right=currNode else:while stack and stack[-1].val==inorder[inorderIndex]:node=stack.pop()inorderIndex-=1 node.left=currNode stack.append(currNode)return root ```####先序+后序 仅由 先序序列+后序序列 一般情况无法唯一确定一棵二叉树， 因为先序和后序都是左右子树相继访问，在**某个子树为空时**无法确定该部分遍历的结果属于哪个子树 最简单的情况(根结点0左结点1 和 根结点0右结点1)``` 0 0/和\\1 1 ``` 前序序列都是`[0,1]`，后序序列都是`[1,0]` 特别地，如果原二叉树仅存在度为0和2的结点，则可以由先序序列+后序序列唯一确定，简单举例如下 给定前序和后序序列 ```[1,2,3,4,5,6,7,8,9,10,11]和[3,4,2,8,9,6,10,11,7,5,1]``` 显然根节点为1 从前序的第二个元素我们得知左子树的根节点为2，在后序中查找到对应位置，其之前即为左子树，之后为右子树 左子树前序和后序 ```[2,3,4]和[3,4,2]``` 右子树前序和后序 ```[5,6,7,8,9,10,11]和[8,9,6,10,11,7,5]```#####实现，递归 1.不依赖全局变量，但需要peek左子节点的值提前定位分割点 1.1.进行子串切割，效率不高 ```python def buildTree(preorder,postorder):if not preorder:return None root=TreeNode(preorder[0])if len(preorder)==1:return root L=postorder.index(preorder[1])+1#左子树根节点在后序遍历中的位置+1，该位置及之后为右子树的遍历结果，L也是左子树的结点数 root.left=buildTree(preorder[1:L+1],postorder[:L])root.right=buildTree(preorder[L+1:],postorder[L:-1])return root ``` 1.2.直接在原串上递归，下标计算较繁琐 ```python def buildTree(preorder,postorder):def make(preIndex,postIndex,N):if N==0:return None root=TreeNode(preorder[preIndex])if N==1:return root for L in xrange(N):#确定左子树的节点数量 if postorder[postIndex+L-1]==preorder[preIndex+1]:break root.left=make(preIndex+1,postIndex,L)root.right=make(preIndex+1+L,postIndex+L,N-1-L)return root return make(0,0,len(preorder))``` 2.依赖全局变量，通过peek后序遍历的下一个节点，判断是否等于前序遍历的当前节点 若不等于，说明存在左/右子树，先尝试递归构建左子树，再次判断，若还不等于，尝试递归构建右子树 （由之前的分析，我们知道对于只存在左子树或只存在右子树的情况，我们无法确定是左还是右，这里的实现，相当于总是重建为左子树） 若等于，说明没有左右子树 ```python preIndex=0 postIndex=0 def buildTree(preorder,postorder):root=TreeNode(pre[preIndex])preIndex+=1 if post[postIndex]!=root.val):root.left=buildTree(preorder,postorder)if post[postIndex]!=root.val):root.right=buildTree(preorder,postorder)postIndex+=1 return root ```#####实现，非递归 ```python def buildTree(preorder,postorder):root=TreeNode(preorder[0])stack=[root]postorderIndex=0 for val in preorder[1:]:currNode=TreeNode(val)while stack[-1].val==postorder[postorderIndex]:stack.pop()postorderindex+=1 if stack[-1].left==None:stack[-1].left=currNode else:stack[-1].right=currNode stack.push_back(currNode)return stack[0]```###增加空结点的遍历结果 遍历时额外记录空结点的信息，此时等价于原二叉树只包含度为0和2的节点 ``` 9/\\3 2/\\/\\4 1#6/\\/\\/\\######``` 这种情况下可以实现由 先序遍历结果 或者 层序遍历结果 重建二叉树 逆波兰表达式对应的语法树也是只包含度为0和2的节点，所以无歧义####层序 ```python def buildTree(tokens):root=TreeNode(int(tokens[0]))queue=collections.deque([root])#已构建的结点（待构建左右子树） i=1 while queue:node=queue.popleft()if tokens[i]!='None':node.left=TreeNode(int(tokens[i]))queue.append(node.left)i+=1 if tokens[i]!='None':node.right=TreeNode(int(tokens[i]))queue.append(node.right)i+=1 return root ```###二叉搜索树直接遍历的结果 二叉搜索树能够只通过 前序序列 或 后序序列 重建，而且无需记录空结点####方法1 因为二叉搜索树的 中序序列 是递增的序列，如果知道 前序序列 或 后序序列，就可以通过**排序**获得中序序列，即 `inorder=sorted(preorder)` 再使用二叉树的 先序+中序 或者 后序+中序 重建方法即可####方法2 可以利用二叉搜索树的有序特性，优化通用解法 无需存储空结点，而是利用值的范围来判断左右子树的分界点 以前序序列为例，第一个值为根节点的值，由于二叉搜索树左子树的值均小于根节点，则可以在前序序列中定位到左右子树序列的分界#####后序 ```python def buildBST(tokens):def helper(lower=float('-inf'),upper=float('inf')):if not tokens or tokens[-1]< lower or tokens[-1]> upper:return None val=int(tokens.pop())root=TreeNode(val)root.right=helper(val,upper)root.left=helper(lower,val)return root return helper()``` ```python def buildBST(preorder):root=TreeNode(preorder[0])stack=[]stack.append(root)for val in preorder[1:]:#将栈的最后一个元素作为父元素，并从下一个前序遍历的节点创建子节点 currentNode=TreeNode(val)node=stack[-1]#栈中小于当前节点值的元素全部出栈，当前节点连接到最后一个弹出栈的结点的右边 while stack and stack[-1].val < currentNode.val:node=stack.pop()if node.val < currentNode.val:node.right=currentNode else:node.left=currentNode stack.append(currentNode)return root ``` 特别地，如果树结点的值大小范围确定，可用用长度一致的二进制块存储（而不是直接将数值转为字符串），比如四个字节，再存储为字符串，这样无需分隔符，输入字符串可根据预定义块大小分割##二叉树序列化和反序列化 序列化：将对象的状态信息编码/转换为可以存储或传输的形式，比如字符串###单一遍历 二叉树的序列化可以直接复用上述遍历方法和根据遍历结果重建二叉树的方法 序列化时只需要将遍历结果以特定的分隔符拼接转化为字符串即可 反序列化时可根据预定分隔符转换回值序列###其他方法 使用嵌套括号分隔遍历结果 Tree=root(Tree_left)(Tree_right)Tree=(Tree_left)root(Tree_right)Tree=(Tree_left)(Tree_right)root 则只使用单个遍历结果就能够反序列化回二叉树 因为每个左括号都有唯一对应的右括号，可以唯一确定序列中 根结点 与 左、右子树 的分界位置 事实上，不必所有空结点都用空括号对表示，仅右子树不为空时，左子树的空括号需保留##相关题目 https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/https://leetcode-cn.com/problems/construct-string-from-binary-tree/https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree https://leetcode-cn.com/problems/serialize-and-deserialize-bst/https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/https://leetcode-cn.com/problems/verify-preorder-sequence-in-binary-search-tree","tags":["LeetCode","Binary Tree"],"categories":[]},{"title":"LeetCode刷题笔记——背包问题汇总","url":"/s/p/bm4vhj/","content":"##符号说明 `C`:背包容量(重量)`N`:物品种类数 `weights`:每种物品的重量 `values`:每种物品的价值 `amounts`:每种物品的数量 为了避免下标访问引起的混淆，这里规定物品编号从`1`开始 `weights`和`values`、`amounts`从下标1开始为有效数据 `dp[0][]` 表示不放物品的情况##01背包 说明：每种物品只有`1`个###基本实现 时间复杂度$O(NC)$，空间复杂度$O(NC)$ ```c++int knapsack01(const int C,const int N,vector<int>&weights,vector<int>&values){vector<vector<int>> dp(N+1,vector<int>(C+1,0));//dp[i][j]为前i种物品(选择若干或全部)放入容量j的包能取得的最大价值，初始化为0 for(int i=1;i <=N;i++){//枚举第i种物品，此时前i-1种物品已决定是否放入 for(int j=1;j <=C;j++){//枚举容量j，正序逆序都可以 dp[i][j]=dp[i-1][j];//不选第i种物品的情况，继承放入前i-1种物品的情况 if(j >=weights[i]){//当前容量够大，能放第i种物品才选 dp[i][j]=max(dp[i][j],dp[i-1][j-weights[i]]+values[i]);}}}return dp[N][C];}``` 注意：对于计数类问题，`dp[0][0]`一般应该初始为`1`，取最大值改为累加，详见下面的其他情形###状态压缩 时间复杂度$O(NC)$，空间复杂度$O(C)$ 上面的基本实现中，`dp[i][]`仅依赖于`dp[i-1][]`，即当前行仅依赖上一行，因此可以去除第一维（物品） 去除第一维后`dp`数组变为单行，相当于在原来的上一行直接修改，所以需要注意修改顺序，必须逆序枚举容量 ```c++int knapsack01(const int C,const int N,vector<int>&weights,vector<int>&values){vector<int> dp(C+1,0);//在第i次循环开始时，dp[j]为前i-1种物品(选择若干或全部)放入容量j的包能取得的最大价值 for(int i=1;i <=N;i++){//枚举第i种物品，此时0~i-1号物品已决定是否放入 for(int j=C;j >=weights[i];j--){//枚举容量j，必须逆序//因为依赖上一行的数据在j较小的位置，逆序遍历不会覆盖需要的上一行数据//当前容量够大，能放第i种物品才选，最小容量只需遍历到weights[i]dp[j]=max(dp[j],dp[j-weights[i]]+values[i]);//max中的dp[j]是上一次外循环的结果，赋值后dp[j]原地更新为本次外循环的结果//dp[j-weights[i]]还是上一次外循环的结果，因为是逆序遍历j}//不选第i种物品的情况(j<weights[i])，继承放入前i-1种物品的情况，dp[j]不修改}return dp[C];}```##完全背包 说明：每种物品不限量###基本实现 时间复杂度$O(NC\\sum(C/w_i))$，空间复杂度$O(NC)$ ```c++int knapsackComplete(const int C,const int N,vector<int>&weights,vector<int>&values){vector<vector<int>> dp(N+1,vector<int>(C+1,0));//dp[i][j]为前i种物品(任选若干种若干个)放入容量j的包能取得的最大价值，初始化为0 for(int i=1;i <=N;i++){//枚举第i种物品，此时前i-1种物品已决定放入多少个 for(int j=1;j <=C;j++){//枚举容量j，正序逆序都可以 for(int k=0;k <=j/weights[i];k++){//枚举第i种物品放入的个数，包括0个(不选)，最多不超过当前容量j dp[i][j]=max(dp[i][j],dp[i-1][j-k*weights[i]]+k*values[i]);}}}return dp[N][C];}```###优化实现 时间复杂度$O(NC)$，空间复杂度$O(NC)$ 上面的基本实现中，存在较多的不必要的状态转移 考虑第`i`个物品重量为`w`， 计算容量`j`的情况时，`dp[i][j]` 从 `dp[i-1][j],dp[i-1][j-w],dp[i-1][j-2w],..,dp[i-1][j-kw],..` 转移 而事实上，计算容量`j-w`的情况时，`dp[i][j-w]` 已从 `dp[i-1][j-w],dp[i-1][j-2w],dp[i-1][j-3w],..,dp[i-1][j-kw],..` 转移 所以 `dp[i][j]` 可以只从 `dp[i-1][j]` 和 `dp[i][j-w]` 转移，去除对`k`的循环 注意到，`dp[i][j]` 对 `dp[i][j-w]` 的依赖，因此只能正序枚举容量 ```c++int knapsackComplete(const int C,const int N,vector<int>&weights,vector<int>&values){vector<vector<int>> dp(N+1,vector<int>(C+1,0));//dp[i][j]为前i种物品(任选若干种若干个)放入容量j的包能取得的最大价值，初始化为0 for(int i=1;i <=N;i++){//枚举第i种物品，此时前i-1种物品已决定放入多少个 for(int j=1;j <=C;j++){//枚举容量j，必须正序 dp[i][j]=max(dp[i-1][j],dp[i][j-weights[i]]+values[i]);}}return dp[N][C];}```###优化实现+状态压缩 时间复杂度$O(NC)$，空间复杂度$O(C)$ 类似01背包的状态压缩 ```c++int knapsackComplete(const int C,const int N,vector<int>&weights,vector<int>&values){vector<int> dp(C+1,0);//在第i次循环开始时，dp[j]为前i种物品(任选若干种若干个)放入容量j的包能取得的最大价值 for(int i=1;i <=N;i++){//枚举第i种物品，此时前i-1种物品已决定放入多少个 for(int j=weights[i];j <=C;j++){//枚举容量j，必须正序//当前容量够大，能放第i种物品至少一个才选，最小容量只需从weights[i]开始 dp[j]=max(dp[j],dp[j-weights[i]]+values[i]);//dp[j-weights[i]]是本次外循环的结果，因为是正序遍历j//上面的分析也提到dp[i][j]对 dp[i][j-weights[i]]的依赖，i 同为本次外循环//max中的dp[j]是上一次外循环的结果，赋值后dp[j]原地更新为本次外循环的结果}//第i种物品放0个的情况(j<weights[i])，继承放入前i-1种物品的情况，dp[j]不修改}return dp[C];}```###转化为 01 背包问题 最简单的想法是： 考虑到第 `i` 种物品最多选 `⌊C/w_i⌋` 件， 可以把第 `i` 种物品拆分为 `⌊C/w_i⌋` 件费用及价值均一样的单件物品 因此直接套用01背包的方法，但时间复杂度并没有改进 更高效的转化方法是： 把第 `i` 种物品拆分成费用为 $w_i 2^k$、价值为 $v_i 2^k$ 的若干件物品，其中 $k$ 取遍满足 $0 ≤ w_i 2^k ≤ C$ 的非负整数。、 这样一来就把每种物品拆成 $O(log⌊C/w_i⌋)$ 件物品，时间复杂度大大改进。 这种方法利用了二进制拆分思想，相当于把第 `i` 种物品按 `1,2,4,8,...,2^k` 件进行打包 不管原最优策略最终选多少件第 `i` 种物品， 其件数写成二进制后，总可以对应表示成若干个 “`2^k`件物品” 的和。##多重背包 说明：每种物品有若干个###基本实现 时间复杂度$O(NC\\sum(min(C/w_i,a_i)))$，空间复杂度$O(NC)$ 类似完全背包的基本实现，枚举物品数量需要考虑物品本身数量上限 ```c++int knapsackComplete(const int C,const int N,vector<int>&weights,vector<int>&values,vector<int>&amounts){vector<vector<int>> dp(N+1,vector<int>(C+1,0));//dp[i][j]为前i种物品(任选若干种若干个)放入容量j的包能取得的最大价值，初始化为0 for(int i=1;i <=N;i++){//枚举第i种物品，此时前i-1种物品已决定放入多少个 for(int j=1;j <=C;j++){//枚举容量j，正序逆序都可以 for(int k=0;k <=min(j/weights[i],amounts[i]);k++){//枚举第i种物品放入的个数，包括0个(不选)，最多不超过当前容量j和第i种物品的数量 dp[i][j]=max(dp[i][j],dp[i-1][j-k*weights[i]]+k*values[i]);}}}return dp[N][C];}```###基本实现+状态压缩 时间复杂度$O(NC\\sum(min(C/w_i,a_i)))$，空间复杂度$O(C)$ ```c++int knapsackComplete(const int C,const int N,vector<int>&weights,vector<int>&values,vector<int>&amounts){vector<int> dp(C+1,0);for(int i=1;i <=N;i++){//枚举第i种物品，此时前i-1种物品已决定放入多少个 for(int j=C;j >=weights[i];j++){//枚举容量j，必须逆序 for(int k=0;k <=min(j/weights[i],amounts[i]);k++){//枚举第i种物品放入的个数，包括0个(不选)，最多不超过当前容量j和第i种物品的数量 dp[j]=max(dp[j],dp[j-k*weights[i]]+k*values[i]);}}}return dp[C];}```##其他###二维背包 说明：背包有两种容量，每种物品有两种重量 以01背包为例 此时应该为`dp`数组增加1维，增加1层循环 ```c++int knapsack01_2(const int C1,const int C2,const int N,vector<int>&weights1,vector<int>&weights2,vector<int>&values){vector<vector<vector<int>>> dp(N+1,vector<vector<int>>(C1+1,vector<int>(C2+1)));for(int i=1;i <=N;i++){for(int j=0;j <=C1;j++){for(int k=0;k <=C2;k++){dp[i][j][k]=dp[i-1][j][k];if(j >=weights1[i]&&k >=weights2[i]){dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-weights1[i]][k-weights2[i]]+values[i]);}}}}return dp[N][C1][C2];}```###求能否恰好装满 以01背包为例 此时物品的价值无意义，`dp`数组的元素改为`bool`值 应该初始化`dp`数组为`false`，初始化`dp[0][0]`为`true` 转移过程改为或（`||`） ```c++int knapsack01(const int C,const int N,vector<int>&weights){vector<vector<bool>> dp(N+1,vector<bool>(C+1,false));//dp[0][0]=true;//for(int i=1;i <=N;i++){for(int j=1;j <=C;j++){dp[i][j]=dp[i-1][j];if(j >=weights[i]){dp[i][j]||=dp[i-1][j-weights[i]];}}}return dp[N][C];}```###求恰好装满的最大价值 以01背包为例 应该初始化`dp`数组为`-INF`，初始化`dp[0][0]`为`0`，表示`0`容量`0`物品可以恰好装满，价值为`0` 转移过程中，取较大值时，`-INF`总是会被舍弃 最后结果`dp[N][C]`若为`-INF`，表示容量为C的包无法恰好装满(可以同时解决上一个问题)，否则表示可以装满的最大价值 ```c++int knapsack01(const int C,const int N,vector<int>&weights,vector<int>&values){vector<vector<int>> dp(N+1,vector<int>(C+1,INT_MIN));//初始化为负无穷 dp[0][0]=0;//for(int i=1;i <=N;i++){for(int j=1;j <=C;j++){dp[i][j]=dp[i-1][j];if(j >=weights[i]){dp[i][j]=max(dp[i][j],dp[i-1][j-weights[i]]+values[i]);}}}return dp[N][C]==INT_MIN?-1:dp[N][C];}```###求恰好装满的最少物品数量 以01背包为例 此时物品的价值均为`1`，表示一件物品 应该初始化`dp`数组为`INF`，初始化`dp[0][0]`为`0`，表示`0`容量`0`物品可以恰好装满且价值为`0` 转移过程改用`min`，取较小值时，`INF`总是会被舍弃 最后结果`dp[N][C]`若为`INF`，表示容量为`C`的包无法恰好装满，否则表示可以装满的最少物品数量 ```c++int knapsack01(const int C,const int N,vector<int>&weights){vector<vector<int>> dp(N+1,vector<int>(C+1,INT_MAX));//初始化为正无穷 dp[0][0]=0;//for(int i=1;i <=N;i++){for(int j=1;j <=C;j++){dp[i][j]=dp[i-1][j];if(j >=weights[i]){dp[i][j]=min(dp[i][j],dp[i-1][j-weights[i]]+1);}}}return dp[N][C]==INT_MAX?-1:dp[N][C];}```###求恰好装满的方案总数 以01背包为例 此时物品的价值无意义，`dp`数组表示方案数 应该初始化`dp`数组为`0`，初始化`dp[0][0]`为`1`，表示1种方案：`0`容量`0`物品可以恰好装满 转移过程改用累加（`+`） ```c++int knapsack01(const int C,const int N,vector<int>&weights){vector<vector<int>> dp(N+1,vector<int>(C+1,0));//初始化为0 dp[0][0]=1;//for(int i=1;i <=N;i++){for(int j=1;j <=C;j++){dp[i][j]=dp[i-1][j];if(j >=weights[i]){dp[i][j]+=dp[i-1][j-weights[i]];}}}return dp[N][C];}```###求恰好装满或最大价值的方案 以01背包为例 一般可以新增一个数组，记录转移过程中某个容量装入的最后一个物品 ```c++vector<int> knapsack01(const int C,const int N,vector<int>&weights,vector<int>&values){vector<vector<int>> dp(N+1,vector<int>(C+1,0));//若需要恰好装满，则初始化为负无穷 vector<vector<int>> path(N+1,vector<int>(C+1,-1));dp[0][0]=0;//for(int i=1;i <=N;i++){for(int j=1;j <=C;j++){dp[i][j]=dp[i-1][j];if(j >=weights[i]){int temp=dp[i-1][j-weights[i]]+values[i];if(temp > dp[i][j]){dp[i][j]=temp;path[i][j]=i;}}}}vector<int> items;for(int j=C,i=N;i >=0;i--){if(path[i][j]==i){items.push_back(i);j-=weights[i];}}return items;}``` 也可以直接由dp数组推出 ```c++vector<int> knapsack01(const int C,const int N,vector<int>&weights,vector<int>&values){vector<vector<int>> dp(N+1,vector<int>(C+1,INT_MIN));//初始化为负无穷 dp[0][0]=0;//for(int i=1;i <=N;i++){for(int j=1;j <=C;j++){dp[i][j]=dp[i-1][j];if(j >=weights[i]){dp[i][j]=max(dp[i][j],dp[i-1][j-weights[i]]+values[i]);}}}vector<int> items;for(int i=N,j=C;i >=1;i--){int w=weights[i],v=values[i];if(j >=w&&dp[i][j]==dp[i-1][j-w]+v){//若是完全或多重背包，此处应该尝试多次减去 j-=w;items.push_back(i);}}return items;}```##测试程序 ```c++#include <bits/stdc++.h> using namespace std;int main(){const int C=20;const int N=9;vector<int> weights={0,1,3,5,6,7,8,10,12,15};vector<int> values={0,1,2,3,4,5,6,7,8,9};cout << knapsack01(C,N,weights,values)<< endl;return 0;}```##相关题目[[416]分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)[[474]一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)[[377]组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)[[139]单词拆分](https://leetcode-cn.com/problems/word-break/)[[494]目标和](https://leetcode-cn.com/problems/target-sum/)[[322]零钱兑换](https://leetcode-cn.com/problems/coin-change/comments/)[[518]零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)[[1049]最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)##参考[动态规划之背包问题系列](https://zhuanlan.zhihu.com/p/93857890)","tags":["LeetCode","Knapsack"],"categories":[]},{"title":"C++学习笔记","url":"/s/p/bki8wr/","content":"####一些注意 member initialization list 的初始化顺序由class中member声明顺序决定，而不是list本身的顺序 大多数平台上，所有类型的指针具有相同的二进制表述 const_cast关键字用于指针或引用，只能去除底层const，即把一个指向const int类型的指针改成指向int类型的指针，不能将指针的顶层const去除,也不能将指向的对象的const属性去除####一些思考 指针存储了地址，其类型只决定编译器以何种长度访问内存，如`int*`在64位机器上以4字节为长度-`void*`只有地址信息，无法解引（和`void`实际上没关系，`void`表示没有参数或没有返回值）-从`int*`可以隐式转换为`void*`，因为事实上丢失了长度信息-从`void*`只能强制显示转换为`int*`，这事实上增加了信息，只有编程者知道 了解C++类库相关实现十分重要，使用高级工具和直接低级工具存在**开销差**，这个**开销差**就是抽象代价(*abstraction penalty*)。 某些情况下，高级工具会提供一些额外的功能。大部分情况下这都不是问题，因为你没有为你不使用的那部分买单。在罕见的情况下，这些未使用的功能会影响其他代码的性能。如果你很看重程序的性能，并且高级工具带来的开销过高，你最好是通过较低级别的工具来手工实现你需要的功能。在绝大多数情况下，额外增加的复杂性和出错几率都远大于性能的小幅提升带来的收益。####一些问题 Q:inline函数能取地址吗？ A:能，但这样代码中会生成一个函数本体用于取地址（通过函数指针调用通常不会被inline），即使在直接调用处是展开的 Q:虚函数能inline吗？ A:不能，虚函数是运行时才能确定调用哪个具体的函数，而inline是在编译期对函数进行展开，这两个概念本质上是矛盾的 Q:没有定义copy constructor ，但有 default constructor，函数按值返回会发生什么？ A:使用编译器默认产生的copy constructor，bitwise拷贝或memberwise拷贝，但可能不是我们预期的结果（不是深拷贝） Q:基类虚函数，子类虚函数同名不同参数（重载？）会发生什么问题？ A:通过基类指针只能调用到基类的函数，无论该指针指向的是基类还是派生类，如果使用基类指针调用子类同名重载函数，编译不通过 Q:new[]一个数组，长度信息存储在哪？malloc的长度信息能被获取？ A:编译器将new分解为两个动作，operator new(size)和 构造函数，向operator new传递申请的字节数时会多一些额外空间存储数组长度（用于delete时调用析构函数），operator new默认调用malloc申请，而malloc本身也维护了一个区块的大小（Cookie），但malloc并不知道是否该区块是否为数组 Q:new[]一个数组，用delete释放会发生什么 A:对于具有平凡的析构函数的类（包括基本类型），不会发生什么，delete依然能够是否对应申请时长度的空间（因为是由free实现），但对于那些需要在析构函数中释放相关资源的类，由于使用delete，不能进行正确次数的调用析构函数，可能出现资源泄露 Q:虚函数，基类和派生类返回值类型不同？####一些名词|缩略语|全称|中文||------|------------------------------------------------------------|------------------||SFINAE|Substitution Failure Is Not An Error|替换失败并非错误||RAII|Resource Acquisition Is Initialization|资源获取即初始化||RTTI|Run-Time Type Identification|运行时类型识别||pImpl|pointer to implementation|||NVI|Non-Virtual Interface（一种称为模板方法的设计模式，和C++模板没关系）|||(N)RVO|(Named)Return Value Optimization|（命名）返回值优化||EBO|Empty Base Optimization|空白基类优化|||stack unwinding|栈展开|####一些参考 https://www.zhihu.com/column/c_1306966457508118528 https://zhuanlan.zhihu.com/p/378355217 https://zhuanlan.zhihu.com/p/377145104######Modern C++https://docs.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp?view=msvc-170&viewFallbackFrom=vs-2019######String https://www.cnblogs.com/cthon/p/9181979.html[知无涯之std::sort源码剖析](https://feihu.me/blog/2014/sgi-std-sort/)######并发 https://paul.pub/cpp-memory-model/https://paul.pub/cpp-concurrency https://gaomf.cn/2020/09/11/Cpp_Volatile_Atomic_Memory_barrier/https://www.cnblogs.com/ishen/p/13200838.html https://zhuanlan.zhihu.com/p/43526907 https://zhuanlan.zhihu.com/p/41872203######协变 https://www.jianshu.com/p/db76a8b08694","tags":["C++"],"categories":[]},{"title":"LeetCode刷题笔记——二分查找","url":"/s/p/bk6szr/","content":"####基本思想 二分查找，单调性不是必须的 想象一个无限长的数组，左边全是`false`，右边全是`true`， 存在第一个使得`f(x)=true`的`x=k`，也就是突变点，突变点之后均满足`f(x)=true` 给定一个包含突变点的左闭右开坐标范围`[l,r)`，二分查找可以不断缩小范围找出这个点，最后`l`和`r`重叠于突变点`k` 模板如下，`f(x)`可以套用任何条件，只要问题可以抽象成上面描述的性质即可 ```cpp int binarySearch(vector<int>&nums){int n=nums.size();int l=0,r=n;while(l < r){int m=l+(r-l)/2;if(f(m))r=m;else l=m+1;}return nums[r];}``` 二分过程中，中点如果满足`f(m)=true`，说明突变点只会是`m`或`m`的左侧，缩小右边界`r=m`即可，否则缩小左边界，`l=m+1` 整个过程不断把右边界缩小到第一个满足`f(x)=true`的下标；若右边界已到位`r=k`，而左边界未重合，则之后只会一直缩小左边界，（因为中位数是下中位数，不会出现中位数是`k`），直到`l=r=k`#####升序数组找到一个大于等于target的下标 对于升序`nums`，存在一个最小下标`x`，在该下标及其之后满足`f(x)=true` 那么`f(x)=(nums[x]>=target)`，代入模板得 ```cpp int binarySearch(vector<int>&nums,int target){int n=nums.size();int l=0,r=n;while(l < r){int m=l+(r-l)/2;if(nums[m]>=target)r=m;else l=m+1;}return nums[r];}``` 而传统的二分查找指定target的下标，只是把上面的条件取等时单独考虑，直接返回而已，是特殊情况 对应的C++库函数实现了相同功能 ```C++lower_bound(ForwardIterator first,ForwardIterator last,const T&val,Compare comp)``` 该函数描述如下 > Returns an iterator pointing to**the first element**in the range `[first,last)` which**does not compare less**than `val`.> > The elements are compared using `operator<` or `comp`.> > The elements in the range shall already be[sorted](http://www.cplusplus.com/is_sorted)according to this same criterion(`operator<` or `comp`),or at least[partitioned](http://www.cplusplus.com/is_partitioned)with respect to `val`.在具体实现上有细微区别，大体如下，与上面的实现相比，`if`的条件和两个分支顺序相反 因为C++该函数使用`comp`，语义是**小于**，而`lower_bound`目标是第一个不小于，也就是第一个**大于等于**，所以`comp(nums[m],target)`这里相当于`!f(条件)` （如果需要自定义`comp`函数以使用`lower_bound`找到第一个满足xx条件的元素，就需要注意条件和comp的关系，有时候需要取反） ```C++int binarySearch(vector<int>&nums,int target){int n=nums.size();int l=0,r=n;while(l < r){int m=l+(r-l)/2;if(comp(nums[m],target))l=m+1;else r=m;}return nums[r];}```#####升序数组找到一个大于target的下标 对于升序`nums`，存在一个最小下标`x`，在该下标及其之后满足`f(x)=true` 那么`f(x)=(nums[x]> target)`，代入模板得 ```c++int binarySearch(vector<int>&nums,int target){int n=nums.size();int l=0,r=n;while(l < r){int m=l+(r-l)/2;if(nums[m]> target)r=m;else l=m+1;}return nums[r];}``` 对应的C++库函数实现了相同功能 ```c++upper_bound(ForwardIterator first,ForwardIterator last,const T&val,Compare comp)``` 该函数描述如下 > Returns an iterator pointing to**the first element**in the range `[first,last)` which**compares greater than**`val`.> > The elements are compared using `operator<` or `comp`.> > The elements in the range shall already be[sorted](http://www.cplusplus.com/is_sorted)according to this same criterion(`operator<` or `comp`),or at least[partitioned](http://www.cplusplus.com/is_partitioned)with respect to `val`.具体实现大体如下，`if`的条件和分支顺序和上面是一致的， 因为语义上`comp`是**小于**，而`upper_bound`目标是第一个**大于**， 所以这里`comp(target,nums[m])`就是`f(条件)` （注意这里`comp`两个参数传入的位置是和`lower_bound`的`comp`相反的） ```c++int binarySearch(vector<int>&nums,int target){int n=nums.size();int l=0,r=n;while(l < r){int m=l+(r-l)/2;if(comp(target,nums[m]))l=m+1;else r=m;}return nums[r];}```","tags":["LeetCode","Binary Search"],"categories":[]},{"title":"LeetCode刷题笔记——迭代、递归、回溯、搜索、动态规划和贪心","url":"/s/p/bijpya/","content":"###问题转换 使用计算机求解问题，首先将问题抽象，用数学语言描述和量化，一般可以认为输入一些变量的初始值和一些固定的参数，求解某个/某些目标变量，目标变量和输入变量有计算依赖的关系，下面对于一元或多元变量的值也称为状态 进一步地，限定问题的输入和求解的变量的值/状态的范围为计算机能够表示的范围，一般就是位数确定的整数或浮点数 再进一步地，限定为现实中有意义/合法的值/状态###问题求解######取所有合法状态的集合[s1,s2,...,sn]这类问题（也可以说不是问题），本身就要求遍历在问题背景下所有可能的合法状态，重点在于选择正确遍历策略，不遗漏不重复######满足 f(s)=C 的状态或状态集合 这类问题的每个状态做单独运算（映射），检查是否满足指定条件######最值 max(f(s))及对应状态 s 这类问题考虑所有状态之间的关系，求取某个统计量，最值是最常见的#####直接求解 对于这些问题，如果本身就要求，或者没有数学方法和针对该问题的特殊解法（这需要人的智慧） 对计算机开始，通常的做法就是暴力遍历每一种情况进行检查/统计，以解决问题 计算机最擅长做重复的事情，如果算力和存储无限大，任何（有限步骤能够结束的）算法都能运行 然而现实是，两者都是有限的，不能无脑重复 需要尽可能在暴力的基础上，进行优化，减少需要计算的状态（不必计算或可以从其他状态的结果里得到） 可以作为优化依据的信息包括-已知输入的某些信息，如有序、数据范围-求解过程已计算的信息，如上界、下界 优化手段包括但不限于-存储已计算的结果，避免重复计算-舍弃某些分支（剪枝），因为可以根据上下界判断出结果不可能在该分支中-改变求解顺序，如先排序或求解过程中排序（优先队列），这样能更多地达到上面提到的剪枝#####间接求解 有时候，直接暴力求解一个问题的代价是我们不能承受的，也没办法找到较好的优化方法 间接求解是通过求解更小规模的问题，在多个子问题的结果上计算得到原问题的结果 这要求问题本身能够分解为子问题###实现手段####迭代 在高级语言中，表现为循环结构 在机器层面，通过指令的向上跳转，重复执行之前的莫某几个步骤 意在遍历每一个对象/状态，以获取最值或每一个结果####递归 嵌套的迭代 在高级语言中，表现为函数内部以不同参数调用自身 在机器层面，将当前上下文压入栈中，跳转到函数入口以不同的参数开始新的执行 动机-子问题/规模更小的问题有同样的求解模式，求解过程封装为函数，可以复用函数代码，免去手动维护不同规模的问题变量-待遍历的对象/状态并非以线性结构存储，从某个对象/状态可以转移到多个相邻的状态，借助函数调用栈结构，能暂存调用的父节点，以便访问多个相邻节点###具体方法 回到leetcode问题上来，这里做一些总结，未完待续。。####搜索 搜索是一般的通用解决方法-可以找到所有可能的状态-可以找到符合条件的某一个状态#####广度优先搜索（BFS） 迭代实现的搜索，从一个状态扩展出若干个相邻的状态，加入队列中 如果所有状态构成不是树，而是图，即一个状态可能被发现多次，则需要去重#####深度优先搜索（DFS） 以 https://leetcode-cn.com/problems/binary-tree-tilt/为例 通常需要使用全局变量/类成员变量维护某个目标值（最值/累计值）或者计数值（获取第k个遍历结果） 因为返回值可能需要用于判断某个条件 ```c++class Solution{public:int ans=0;int findTilt(TreeNode*root){dfs(root);return ans;}int dfs(TreeNode*node){if(node==nullptr)return 0;int sumLeft=dfs(node->left);int sumRight=dfs(node->right);ans+=abs(sumLeft-sumRight);return sumLeft+sumRight+node->val;}};``` 也可以将目标值设为函数的引用参数，调用子问题时，子问题都修改最顶层调用传入的参数，避免使用全局变量 ```c++class Solution{public:int findTilt(TreeNode*root){int answer=0;dfs(root,answer);return answer;}int dfs(TreeNode*root,int&answer){if(!root)return 0;int ls=dfs(root->left,answer);int rs=dfs(root->right,answer);answer+=abs(ls-rs);return ls+rs+root->val;}};``` 当然也可以使用结构体（或pair<>）组合多个返回值，避免使用全局变量 ```c++class Solution{public:struct RET{int sum;int acc_tilt;};RET dfs(TreeNode*root){if(root==nullptr)return{0,0};RET l=dfs(root->left);RET r=dfs(root->right);return{root->val+l.sum+r.sum,abs(l.sum-r.sum)+l.acc_tilt+r.acc_tilt};}int findTilt(TreeNode*root){RET res=dfs(root);return res.acc_tilt;}}``` 对于需要构造所有状态的问题，通常就使用全局变量（列表）或引用参数，完成一个状态构造时加入，这种情况更偏向于回溯 使用全局变量的内存消耗通常大于引用参数，参考这个[提交记录](https://leetcode-cn.com/submissions/detail/271002745/)，内存分布明显有最前面两个峰，最后面还有一个峰是递归调用层数更多的方法，内存消耗也更多######启发式搜索 > $\\text{A*}$ 算法参考[Wikipedia-A*search algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm)或[oi-wiki-A*](https://oi-wiki.org/search/astar/)。 > > 在 $\\text{A*}$ 算法中，我们需要使用四个距离函数 $F(x),G(x),H(x),H^*(x)$，其中 $F(x),G(x),H(x)$ 是可以求出的，而 $H^*(x)$ 是无法求出的，我们需要用 $H(x)$ 近似 $H^*(x)$。设起点为 $s$，终点为 $t$，这些距离函数的意义如下： > >-$G(x)$ 表示从起点 $s$ 到节点 $x$ 的「实际」路径长度，注意 $G(x)$ 并不一定是最短的； > >-$H(x)$ 表示从节点 $x$ 到终点 $t$ 的「估计」最短路径长度，称为**启发函数**； > >-$H^*(x)$ 表示从节点 $x$ 到终点 $t$ 的「实际」最短路径长度，这是我们在广度优先搜索的过程中无法求出的，我们需要用 $H(x)$ 近似 $H^*(x)$； > >-$F(x)$ 满足 $F(x)=G(x)+H(x)$，即为从起点 $s$ 到终点 $t$ 的「估计」路径长度。我们总是挑选出最小的 $F(x)$ 对应的 $x$ 进行搜索，因此 $\\text{A*}$ 算法需要借助**优先队列**来实现。 > > 如果读者熟悉求解最短路的 $\\text{Dijkstra}$ 算法，就可以发现 $\\text{Dijkstra}$ 算法是 $\\text{A*}$ 算法在 $H(x)\\equiv 0$ 时的特殊情况。 > > $\\text{A*}$ 算法具有两个性质： > >-如果对于任意的节点 $x$，$H(x)\\leq H^*(x)$ 恒成立，即我们「估计」出的从节点 $x$ 到终点 $t$ 的最短路径长度总是不超过「实际」的最短路径长度，那么称启发函数 $H(x)$ 是可接纳的（admissible heuristic）。在这种情况下，$\\text{A*}$ 算法一定能找到最短路，但同一节点可能需要加入优先队列并搜索多次，即当我们从优先队列中取出节点 $x$ 时，$G(x)$ 并不一定等于从起点到节点 $x$ 的「实际」**最短**路径的长度； > >-如果对于任意的两个节点 $x$ 和 $y$，并且 $x$ 到 $y$ 有一条长度为 $D(x,y)$ 的有向边，$H(x)-H(y)\\leq D(x,y)$ 恒成立，并且 $H(t)=0$，那么称启发函数 $H(x)$ 是一致的（consistent heuristic）。可以证明，一致的启发函数一定也是可接纳的。在这种情况下，同一节点只会被加入优先队列一次，并搜索不超过一次，即当我们从优先队列中取出节点 $x$ 时，$G(x)$ 一定等于从起点到节点 $x$ 的「实际」**最短**路径的长度。 > >#####>#####回溯 DFS的一种特殊情况，参见[这篇文章](https://www.cis.upenn.edu/~matuszek/cit594-2012/Pages/backtracking.html)使用回溯求解的问题常常原地构建和修改状态，这就要求要求能够使状态逆序恢复 在具体的写法上，它与普通的深度优先搜索一样，都有[修改当前节点状态]→[递归子节点]的步骤，只是多了回溯的步骤，变成了[修改当前节点状态]→[递归子节点]→[回改当前节点状态]。 回溯法的核心就是回溯，具有进入与返回顺序对称的特性，通常用来生成或查找多维的问题 可以认为`状态=(变量1，变量2，...，变量n)` 回溯相当于可变重数的for循环，充分利用函数调用栈暂存信息，并且自动帮助我们恢复状态，参考下面的例子 ``` for(val1 in 变量1)for(val2 in 变量2)...for(valn in 变量n)check f(状态)=f(val1，val2，...，valn)``` 可以逐步构建状态，减少状态构建时的开销，特别是构建是依赖于前面变量的操作， 最简单的：累加 ``` f(i,val){val+=v[i];f(i+1,val);//val-=v[i];//由于调用栈自动清理变量，省略了此步}//如果是for循环（假设只在最内循环编写代码），则需要每次对所有层的val进行从头累加 ``` 复杂一些的：比如枚举状态本身，表示为一个数组，需要逐步构建数组 这种情况常常通过传引用，原地修改同一个对象，而不是拷贝构造一个新的对象 ``` f(i,arr){arr.push(i);f(i+1,arr);arr.pop(i);//回溯}``` 回溯过程中可以剪枝，提前return（相当于在某个for中break），特别是一些状态之间相互耦合的情况-使用变量有代价`g(变量)`，可在回溯过程中根据代价上限提前返回######常见的用回溯求解的问题 排列，每个元素只能用一次，需要查询某个元素是否已使用 组合/子集-组合类的去重，一般通过排序后，判断选中的相邻两个数是否相同#########动态规划 不同于一般的搜索，动态规划和贪心，更侧重于间接求解问题，即问题可以分解为子问题 动态规划是一种思想，对于求解的问题，其结果依赖于于重叠的子问题（否则应该使用分治，在多个机器核心上同时求解），并且每个子问题的求解顺序不影响更大的问题的结果（无后效性） 以动态规划求解问题，一般需要一个一维或多维数组，每个维度是问题的某个规模参数从，通过已知或易知的边界条件（规模最小的问题），一定的次序逐步求解较大规模的问题######[140.单词拆分 II](https://leetcode-cn.com/problems/word-break-ii/)看看官方题解，思考一下我的做法与记忆化搜索的关系?*######[300.最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)思考解法二：贪心+二分######[410.分割数组的最大值](https://leetcode-cn.com/problems/split-array-largest-sum/)思考解法二：贪心+二分######[968.监控二叉树](https://leetcode-cn.com/problems/binary-tree-cameras/)思考这题我的做法是贪心吗？贪心为什么可行######[376.摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)思考这题，类似最长递增子序列的O(n^2)的动态规划为什么本题能优化到O(n)，和O(n)的贪心是什么区别####记忆化搜索 记忆化搜索和动态规划在本质上是一样的，复用重叠子问题，相同的子问题只求解一次 动态规划由迭代实现，由于更大规模的问题依赖于规模小的问题，因此求解顺序上有一定的要求-有时候数据的分布顺序不是实现正确求解的顺序，所依赖的子问题可能**尚未求解**或**尚不能正确求解**（因为更小的子问题尚未求解）-比如，[329.矩阵中的最长递增路径](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)，如果想要迭代求解，必须先对所有坐标按对应值排序或拓扑排序，依照此顺序求解-分糖果那题似乎也可以拓扑排序+动态规划 记忆化搜索由函数递归实现，并不以特定的顺序求解，-每当遇到一个问题，分解为若干个子问题-如果子问题已经求解过（记忆在存储中），则直接使用结果；-如果子问题未求解，则递归地求解子问题，并记录在存储中####贪心-","tags":["LeetCode","Iterate","Recurse","Backtrack","Search","DP","Greedy"],"categories":[]},{"title":"LeetCode刷题笔记——链表","url":"/s/p/bi8to3/","content":"###总结 链表相关的题目整体上难度不大 主要是对指针的指向修改容易出错-赋值顺序错误导致丢失了某个节点之后的所有结点-访问了空指针-计数次数与预期相差1 链表的特性-无法随机访问，只能从头开始单向前进-初始时链表的长度未知-（单链表）从某个节点无法获取其前一个节点######双指针 使用多个指针同时前进，实现到达链表中的某个偏移位置-快慢指针：以不同的速度前进，快指针每次前进两个结点，慢指针每次前进一个结点，快指针到末尾时慢指针到达链表中点-以一定的间隔同时前进，A指针先前进k步，之后AB指针同时前进，A指针到末尾时，B指针在倒数第k个节点######prev指针 对与需要删除或移动某个节点的情况，需要修改该节点前一个结点的next指针 如果循环时迭代的变量视为当前节点，则需要额外维护一个prev变量 当然，也可以直接将循环时迭代的变量视为前一个节点，使用该节点->next->val，这样可以省去prev变量######dummy结点 通常以一个不存储实际数值的哑结点作为头结点，以统一操作，避免在循环中进行额外的判断（是否为head） 如果使用上面的prev变量，初始时prev就指向dummy######注意点 对循环边界条件的判断-链表是否结束，注意判断是用`p!=nullptr`还是`p->next!=nullptr`-前进指定的次数 对于需要计数的情况-尽可能不要在循环的判断条件中对计数变量使用`++`和`--`后缀运算符，特别是与结点指针`p !=nullptr`的判断进行逻辑与`&&`运算时-因为后缀运算的副作用是否执行与执行位置不明显，带来思维上的负担，容易出现边界情况计算错误-好的做法应该是在循环体中修改计数变量（同时修改结点指针） 对于指针指向的修改-需要额外的变量暂存某个指针-以一定的顺序赋值，避免错误覆盖而丢失指针-每次循环结束后某个指针变量的指向是明确的（“语义”不变的） 关于递归实现-递归虽然更简洁，但边界条件也容易出错，并且栈开销较大，尽量不使用###具体题目####简单题######[2.两数相加](https://leetcode-cn.com/problems/add-two-numbers)以链表存储的两个数，低位在前 直接相加即可，注意最后的进位######[445.两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii)以链表存储的两个数，高位在前 先入栈或先翻转链表######[19.删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)经典双指针，注意删除的有可能是首结点，需要dummy A从head先前进N，然后B从dummy出发与A一起前进，A==null时，B为倒数第N的前一个结点######[21.合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists)简单归并，注意最后接上未遍历完的那个链表######[83.删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list)题意：删除已排序链表中所有重复数字的节点，使每个元素只出现一次 对每个结点，不断删除相同值的下一个结点######[82.删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii)题意：删除已排序链表中所有重复数字的节点，只留下原先只出现一次的数字 这题有可能删除头结点，需要dummy 设置prev和curr，对每个结点curr，不断删除相同值的下一个结点，最后删除curr######[141.环形链表](https://leetcode-cn.com/problems/linked-list-cycle)快慢指针判断环，注意循环的边界条件 如果`fast`遇到`nullptr`，说明没有环######[203.移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements)判断下一个元素的值即可，若相等，删除下一个元素######[206.反转链表](https://leetcode-cn.com/problems/reverse-linked-list)经典方法，前中后三个指针遍历 ```c++ListNode*prev=nullptr;ListNode*curr=head;ListNode*next=nullptr;while(curr){next=curr->next;curr->next=prev;prev=curr;curr=next;}return prev;``` 还有一种奇技淫巧， ```c++ListNode*p;for(p=nullptr;head;)tie(p,head,head->next)=tuple<ListNode*,ListNode*,ListNode*>(head,head->next,p);return p;```######[237.删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list)比较有意思的题目，由于不知道当前节点的前一个结点，无法直接删除，我们可以把下一个结点（必须存在）的值放到当前节点存储，然后删除下一个结点######[725.分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts)题意：把链表按顺序平均切成k份，任意两部分的长度差距不能超过 1，排在前面的部分的长度应该大于或等于排在后面的长度。 先计算长度n，求每份基本长度n/k，n%k余数r，前r段每段长度n/k+1，剩下的每段长度为n/k，对两种长度分别循环切分######[876.链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list)经典的快慢指针######[1290.二进制链表转整数](https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer)遍历，移位，累加######[1669.合并两个链表](https://leetcode-cn.com/problems/merge-in-between-linked-lists)题意：给你两个链表，它们包含的元素分别为&nbsp;`` n `` 个和&nbsp;`` m `` 个。请你将&nbsp;`` list1 ``&nbsp;中下标从 `` a `` 到 `` b `` 的全部节点都删除，并将`` list2 ``&nbsp;接在被删除节点的位置。 注意前进次数，前进a-1次获得删除区间的前一个结点，再前进b+1次，获得删除区间的后一个结点######[1721.交换链表中的节点](https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list)题意：__交换__ 链表正数第 `` k `` 个节点和倒数第 `` k `` 个节点的值 双指针，A先前进k-1次，记录A的位置获得第k A+1（注意这里），之后AB一起，A==null时，B就是倒数k######[2058.找出临界点之间的最小和最大距离](https://leetcode-cn.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points)题意：找出链表的两个严格极(大或小)值之间的最大和最小距离 前中后三个指针，依次找到所有极值的位置，更新最小间距######[2095.删除链表的中间节点](https://leetcode-cn.com/problems/delete-the-middle-node-of-a-linked-list)快慢指针找中点的前一个结点，注意输入和循环的边界条件 或者多用一个pre存放上一次的慢指针，比较清晰不会混乱####中等题######[24.两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs)递归方法：简单 迭代方法： 交换之前的节点关系是 `temp-> node1-> node2`，交换之后的节点关系要变成 `temp-> node2-> node1`，因此需要进行如下操作。 ``` temp.next=node2 node1.next=node2.next node2.next=node1 ``` 完成上述操作之后，节点关系即变成 `temp-> node2-> node1`。再令 `temp=node1`，对链表中的其余节点进行两两交换，直到全部节点都被两两交换。######[61.旋转链表](https://leetcode-cn.com/problems/rotate-list)题意：将链表每个节点向右移动&nbsp;`` k ``_&nbsp;_个位置 先求长度n，k=k%n，k==0时无需处理 思路：将链表连接成环，然后在指定位置断开 具体：尾部下一个节点连到头成环，然后找到新链表的最后一个节点（即原链表的第n-1-k个节点），将当前闭合为环的链表断开######[86.分隔链表](https://leetcode-cn.com/problems/partition-list)题意：给一个特定值x，调整链表使得所有 __小于__ `` x `` 的节点都出现在 __大于或等于__ `` x `` 的节点之前，应当 __保留__ 两个分区中每个节点的初始相对位置。 效果相当于快排里的划分函数。 但链表不能从后往前迭代。因此，开一个dummy存放遍历时遇到的所有>=x的结点，原head的链表保留<x的结点，最后链接两个链表######[92.反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii)题意：反转链表中的一个区间[left,right]，下标从1开始 注意设置dummy，因为left可能是1，这样我们总是可以从dummy先前进left-1次获得left的前一个结点p，然后常规翻转right-left+1次 最后设置原p->next的next为翻转后剩下结点的首节点，p->next设为翻转后的首节点######[142.环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii)题意：找出环形链表的入口点 快慢指针，直到快为null（说明无环，返回）或快==慢 此时slow走n步，fast走2n步，fast比slow多走一圈，则圈长为n 设不在圈中的部分长度为k，则slow在圈中已走n-k步，说明再走k步就会回到入口点（进圈的第一个结点） 让fast回head，与slow同速度前进，直到相等，则此时slow走n+k步，比fast多1圈，则fast走了k步，两者都在入口点######[143.重排链表](https://leetcode-cn.com/problems/reorder-list)######[147.对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list)设置一个指针p指向已排序的末尾节点，遍历链表，若当前节点大于末尾，则p++，否则取出当前节点从头开始寻找插入点######[160.相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists)题意：两个链表可能在某个结点相交（之后的结点是一样的）。返回相交的其实结点，不存在返回Null 简单的方法：先算长度，然后重新遍历，让长的链表先走长度差，之后同时遍历两个链表，判断节点是否一样 巧妙的方法：同时遍历两个链表，各自到末尾时开始遍历另一个链表，直到二者相等（包括都为null的情况，说明不相交）######[234.回文链表](https://leetcode-cn.com/problems/palindrome-linked-list)题意：判断链表的数字是否回文 方法一：快慢指针+反转链表，不额外使用存储的方法。先快慢指针找到中点，将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后将链表恢复原样。 方法二：快慢指针找中点，中点后的结点存入一个栈中 方法三：巧妙的递归方法，需要使用全局变量 ```c++ListNode*frontPointer;bool recursivelyCheck(ListNode*currentNode){if(currentNode !=nullptr){if(!recursivelyCheck(currentNode->next)){return false;}if(currentNode->val !=frontPointer->val){return false;}frontPointer=frontPointer->next;}return true;}bool isPalindrome(ListNode*head){frontPointer=head;return recursivelyCheck(head);}```######[328.奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list)题意：奇数下标的结点连在一起，偶数下标的结点连在一起作为后半部分 开另一个dummy结点存储取出的偶结点，最后接到原链表后######[817.链表组件](https://leetcode-cn.com/problems/linked-list-components)题意：计算链表中 元素连续出现在某个数组中 的区间数量 先把数组元素存入集合，方便查找，然后遍历链表即可######[2130.链表最大孪生和](https://leetcode-cn.com/problems/maximum-twin-sum-of-a-linked-list)题意：在一个大小为&nbsp;`` n ``&nbsp;且 `` n ``&nbsp;为&nbsp;__偶数__ 的链表中，第&nbsp;`` i ``&nbsp;个节点（下标从 __0__&nbsp;开始）的孪生节点为第&nbsp;``(n-1-i)``&nbsp;个节点 ，求最大的孪生结点元素和 类似回文链表######[138.复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer)题意：给你一个长度为 `` n `` 的链表，每个节点包含一个额外增加的随机指针 `` random `` ，该指针可以指向链表中的任何节点或空节点。返回这个链表的&nbsp;__<a href=\"https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin\" target=\"_blank\">深拷贝</a>__。复制链表中的指针都不应指向原链表中的节点 。 简单方法：使用哈希表记录新旧结点关系，按序构建新链表，然后再次遍历，根据hash表重建random指针 巧妙方法： 首先将该链表中每一个节点拆分为两个相连的节点，例如对于链表 $A\\rightarrow B\\rightarrow C$，我们可以将其拆分为 $A\\rightarrow A'\\rightarrow B\\rightarrow B'\\rightarrow C\\rightarrow C'$。对于任意一个原节点 $S$，其拷贝节点 $S'$ 即为其后继节点。 然后，重建random指针，对于一个原链表节点执行`p->next->random=p->random->next` 最后，将两个链表拆分开。####困难题######[23.合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists)朴素方法：k-1次循环，每次取一个链表合并到第一个链表，O(nk^2)进阶方法：分治合并，logk次，O(nklogk)更好的方法：维护当前每个链表没有被合并的元素的最前面一个，$k$ 个链表就最多有 $k$ 个满足这样条件的元素，每次在这些元素里面选取 `val` 属性最小的元素合并到答案中。在选取最小元素的时候，用优先队列来优化这个过程。优先队列中的元素不超过 $k$ 个，最多有 $kn$ 个点，插入删除各一次，故总的时间代价即渐进时间复杂度为 $O(kn\\times\\log k)$。######[25.K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/k-ge-yi-zu-fan-zhuan-lian-biao-by-leetcode-solutio)细节题 实现一个函数，输入一个子链表的头和尾节点，翻转，并且返回新的头与尾######[148.排序链表](https://leetcode-cn.com/problems/sort-list)题意：归并排序链表######[430.扁平化多级双向链表](https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list)类似二叉树的先序遍历 相似题目[114.二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)######[1171.从链表中删去总和值为零的连续节点](https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list)朴素方法：每个位置都执行向后遍历，删除和为0的区间，直到不能再删，换下一个位置，O（n^2） 两次遍历法：第一次求前缀和，维护前缀和到节点（保留最后一个）的哈希表；第二次遍历，若当前节点处前缀和在哈希表出现了 ，则表明两结点之间所有节点和为0，直接删除区间所有节点######[2074.反转偶数长度组的节点](https://leetcode-cn.com/problems/reverse-nodes-in-even-length-groups)细节题","tags":["LeetCode","LinkList"],"categories":[]},{"title":"LeetCode刷题笔记——理解二叉树的非递归遍历","url":"/s/p/bi4kgl/","content":"犹记得当年大二学习数据结构时，二叉树的迭代遍历就是书本中第一个难点 虽然认真看几遍标准代码能够理清逻辑和思路，但时隔多年，在leetcode上刷题时仍然不能由自己一遍写对 因此这里结合笔者的一些思考重新梳理一遍##理解二叉树的非递归遍历 树是一种数据结构，用于表示多个对象（结点/节点）间存在的层次关系 二叉树则是一种特殊情况，每个结点最多只有左右两棵子树，且必须区分子树的左右关系 树的遍历，是对树中的所有对象进行有损序列化（不保留结构信息，通常无法反序列化），以某种特定的顺序访问每个对象，且每个对象只被访问一次 注意，这里的顺序针对的是访问，而非发现，因为一个对象可以先被发现，等其他对象被访问后再访问该对象 笔者简单定义了以下两个行为 访问：获取对象上的某个值，在代码实现中通常就是打印出来或者存储到顺序容器上 发现：被某个变量存储或指向，因为树状结构不是数组，无法通过一个索引随机访问，初始时只有根节点被存储或指向 从存储结构的视角上看 对于链表，它是一个离散顺序结构，每次发现一个节点，访问其值后即可抛弃（使指针指向下一个节点），所以发现和访问是同时发生的（如果需要逆序访问一个链表，同样需要一个栈或者使用函数递归调用） 对于二叉树，可以认为是多分支的链表，我们每次发现一个节点，并不需要立即访问其值，也不能立刻抛弃它，因为节点指向左右两个分支， 按照不同的策略，存在不同的访问顺序，一些情况下发现与访问不是同时发生，我们必须使用一个容器暂存已发现的节点，可以是栈（三种遍历），也可以是队列（层序遍历） 访问顺序-从某个节点被发现时的视角看-中序遍历：访问左子树->访问当前节点->访问右子树-先序遍历：访问当前节点->访问左子树->访问右子树-后序遍历：访问左子树->访问右子树->访问当前节点-这是常见的三种模式，左右子树的顺序并不重要，通常先左后右，区别只在于当前节点在何时访问-从树状结构的全局视角看-层序遍历：按节点的层次访问，相同层次内的节点顺序不作要求，一般按照整体结构的左右顺序 注意：借助函数的递归调用，我们可以很容易实现上面三种遍历，递归实现方式本质上利用了函数的调用栈结构对节点进行暂存 注意：上述的访问顺序针对的是每个结点，因此访问一个子树并不代表立刻访问子树的根节点，因为该子树的根节点也要符合这个访问顺序 注意：使用容器暂存的节点，只能说该节点已经被发现，在节点出栈时这个节点的状态是不确定的：节点已访问？左子树已访问？右子树已访问？这需要根据具体的代码上下文确定。这也说明了栈本身隐含了节点的特定状态。如果不保证栈中节点状态的一致性，往往需要额外的信息辅助判断，有时还需要二次入栈。##遍历与搜索的关系 搜索：一般发现结点的同时就进行访问，因为搜索的目标是找到符合特定要求的结点，对于访问的顺序没有特定要求，但仍然需要容器暂存结点，因为结点有多个分支。 对于二叉树，深度优先搜索和先序遍历的访问顺序一致，广度优先搜索和层次遍历的访问顺序一致##实现三种遍历###经典版本####先序 先序遍历时，结点本身先于左右子树访问 从这个角度看，可以发现时即刻访问，无需暂存结点 但由于存在左右子树分支，仍然需要暂存其中一个结点 ```python def preorderTraversal(root):res=[]stack=[]node=root#当前处理的结点，这里就是“发现了”根节点 while node !=None or len(stack)> 0:#基本条件，有正在处理的结点或暂存区不为空#阶段1：一发现就立刻访问，并且有左子树就一直进入左子树 while node !=None:res.append(node.val)#一发现就立刻访问 stack.append(node)#因为要进入左子树，必须暂存结点，以便之后进入右子树 node=node.left#“发现了”左子节点#阶段2：从暂存区获取，进入右子树，因为之前进入暂存区时，左子树已访问过 node=stack.pop()#出栈节点无用，其值入栈前已访问 node=node.right#“发现了”右子节点 return res ``` 节点入栈之前，其值就已被访问 节点在出栈时，它的左子树已经被访问（因为左子树的结点总是比父节点后入栈） 事实上，由于入栈节点本身已被访问，可以仅入栈其右子结点，这样出栈后无需再跳转右子结点####中序 ```python def inorderTraversal(root):res=[]stack=[]node=root while node !=None or len(stack)> 0:#阶段1：有左子树就一直进入左子树，发现但不访问，依次暂存父结点 while node !=None stack.append(node)node=node.left#阶段2：从暂存区获取 node=stack.pop()res.append(node.val)#出栈时才访问 node=node.right return res ``` 节点在出栈时，它的左子树已经被访问（因为左子树的结点总是比父节点后入栈） 与先序版本的唯一不同是节点其值在出栈时才被访问，这样就实现了节点左子树先于节点本身访问####后序 后序遍历时，对于一个结点，必须其左右子树都访问后才能访问自身，而仅使用栈无法表示两种状态-左子树已访问右子树未访问-左右子树均已访问 需要额外的变量辅助判断 ```python def postorderTraversal(root):res=[]stack=[]prev=None#上一个访问的节点 node=root#当前处理的结点，这里就是“发现了”根节点 while node !=None or len(stack)> 0:while node !=None:#直到一个节点没有左子树 stack.append(node)#发现时并不访问，直接暂存 node=node.left node=stack.pop()#弹出的节点，要么没有左子树，要么左子树已访问过 if not node.right or node.right==prev:#没有右或上一次访问就是右子树根节点 res.append(node.val)#可以访问当前节点了 prev=node node=None#注意，访问完需置空当前节点，因为本身和左右子树均已访问，该节点在下次循环不再使用 else:stack.append(node)#放回！ node=node.right#发现右子树 return res ``` 节点在出栈时-本身未被访问-节点左子树已经被访问（因为左子树的结点总是比父节点后入栈）-节点右子树是否访问是未知的，因此栈中的节点存在**两种状态**需要维护一个变量prev记录上一次访问的结点 每次出栈一个结点-如果-prev就是出栈结点的右子结点，说明出栈结点右子树已访问完（因为右子结点是后序遍历右子树的最后一个结点）-或者出栈结点没有右子树 这两种情况都表示可以访问当前出栈节点-否则，应该将出栈节点**放回**栈中，进入该节点的右子树 prev变量区分了出栈节点的两种状态###经典版本（合并内外循环） 经典写法中，外部循环的条件为`node !=None or len(stack)> 0`，内循环还有`node !=None`的条件，初看时容易让人迷惑 可以将阶段一的循环并入外循环，在循环内部判断`node !=None`，更加清晰####先序 ```python def preorderTraversal(root):res=[]stack=[]node=root while node !=None or len(stack)> 0:if node !=None:res.append(node.val)stack.append(node)node=node.left else:node=stack.pop()node=node.right return res ```####中序 ```python def inorderTraversal(root):res=[]stack=[]node=root while node !=None or len(stack)> 0:if node !=None:stack.append(node)node=node.left else:node=stack.pop()res.append(node.val)node=node.right return res ```####后序 ```python def postorderTraversal(root):res=[]stack=[]prev=None node=root while node !=None or len(stack)> 0:if node !=None:stack.append(node)node=node.left else:node=stack.pop()if not node.right or node.right==prev:res.append(node.val)prev=node node=None else:stack.append(node)node=node.right return res ```###经典版本（改造） 在这个版本中，分离了 `node !=None` 和 `len(stack)> 0` 这两个条件 以栈为中心，外循环保留 `len(stack)> 0`，每次取出一个节点 循环中每当访问一个节点，就一直进入左子树####中序 ```python def inorderTraversal(root):res=[]stack=[]node=root while node !=None:stack.append(node)node=node.left while len(stack)> 0:node=stack.pop()res.append(node.val)node=node.right while node !=None:stack.append(node)node=node.left return res ```####后序 ```python def postorderTraversal(root):res=[]stack=[]prev=None if(root)stack.push(root)while len(stack)> 0:node=stack.pop()if not node.right or node.right==prev:res.append(node.val)prev=node else:stack.append(node)node=node.right while node !=None:stack.append(node)node=node.left return res ```###简化版本 根据三种遍历各自的特点，能进一步简化实现####先序 与经典实现不同，结点发现即入栈，而不是访问后跳转到子结点 所有节点都留到出栈时访问，因此无需判断`node !=None`，所有node均由栈中获取 栈中节点状态保持一致性，均为已发现未访问 ```python def preorderTraversal(root):res=[]stack=[]if root:stack.append(root)while len(stack)> 0:#暂存区不为空 node=stack.pop()res.append(node.val)#出栈时访问，发现并暂存子节点 if node.right:stack.append(node.right)if node.left:stack.append(node.left)return res ```####后序 由于有了pre信息，可以进一步简化 ```python def postorderTraversal(root):res=[]stack=[]prev=None if root:stack.append(root)while len(stack)> 0:node=stack.pop()if not node.right or node.right==prev:res.append(node.val)prev=node else:stack.append(node)#同样放回 if node.right:stack.append(node.right)if node.left:stack.append(node.left)return res ```###统一写法 在这个版本中，为栈中节点多维护了一个状态变量，这样即使节点多次入栈，也能够区分不同状态的节点 当一个节点-第一次发现时被入栈，标记状态为`FIND`-第一次出栈时，按照不同遍历的特性依次入栈节点本身和左右子结点，标记左右子节点状态为`FIND`，而当前节点标记状态为`VISIT`-第二次出栈时，访问节点的值 为什么要再次入栈？因为中序和后序遍历时，节点发现时不能立刻被访问 ```python FIND,VISIT=0,1 def traversal(root):res=[]stack=[(FIND,root)]while len(stack)> 0:state,node=stack.pop()if state==FIND:#只需改变这几行代码的顺序即可分别实现前中后序遍历，下面为中序遍历 if node.right:stack.append((FIND,node.right))stack.append((VISIT,node))if node.left:stack.append((FIND,node.left))else:res.append(node.val)return res ``` 如果觉得为每个节点维护一个状态浪费空间或者某些语言下实现不方便，可以仅标记某些少量的特殊状态，这里就是`VISIT`，简单的标记方法就是多向栈中加入一个空结点 ```python def traversal(root):res=[]stack=[root]while len(stack)> 0:node=stack.pop()if node !=None:#只需改变这几行代码的顺序即可分别实现前中后序遍历，下面为中序遍历 if node.right:stack.append(node.right)stack.append(node);stack.append(None)#多加入一个空结点以标记该节点下次出栈访问 if node.left:stack.append(node.left)else:#遇到空结点说明需要再弹出一个节点，该节点是第二次出栈 node=stack.pop()res.append(node.val)return res ```##实现层序遍历 层序遍历较简单，使用队列暂存一层的结点 依序访问一层的结点时，发现下一层的结点，依序入队列 ```python def levelOrder(root):res=[]queue=collections.deque([])if root:q.append(root)while queue:size=len(queue)#如果遍历结果不需要以层次分组，则无需设置内循环 while size:node=queue.popleft()res.append(node.val)if node.left:queue.append(node.left)if node.right:queue.append(node.right)size-=1 return res ```##Mirros 遍历 这种方法可以在线性时间内，只占用常数空间来实现遍历，由 J.H.Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。 线索二叉树 利用叶结点的空指针存储信息，无需栈####先序 ```python def preorderTraversal(root):res=[]pred=None#predecessor，左子树的最右下节点，中序遍历时当前节点的前驱节点 while root:if root.left:pred=root.left while pred.right and pred.right !=root:pred=pred.right if not pred.right:res.append(root.val)#访问当前节点 pred.right=root#让 pred 的右指针指向 root，这样之后的某次循环会回到root，走向if的另一个分支 root=root.left#进入左子树 else:#pred.right==root，说明左子树已经访问完了 pred.right=None#断开链接前驱和root的链接 root=root.right else:res.append(root.val)root=root.right return res ```####中序 ```python def inorderTraversal(root):res=[]pred=None#predecessor，左子树的最右下节点，中序遍历时当前节点的前驱节点 while root:if root.left:pred=root.left while pred.right and pred.right !==root:pred=pred.right if not pred.right:pred.right=root#让 pred 的右指针指向 root，这样之后的某次循环会回到root，走向if的另一个分支 root=root.left else:#pred.right==root，说明左子树已经访问完了，可以访问root本身 res.push(root.val)pred.right=null#断开链接前驱和root的链接 root=root.right else:#如果没有左孩子，则直接访问右孩子 res.push(root.val)root=root.right return res ``` Morris 中序遍历的一个重要步骤就是寻找当前节点的前驱节点，并且 Morris 中序遍历寻找下一个点始终是通过转移到 right 指针指向的位置来完成的-如果当前节点没有左子树，则访问，然后跳转到当前节点的右子树-如果当前节点有左子树，那么它的前驱节点一定在左子树上，可以在左子树上一直向右前进，找到当前点的前驱节点-如果前驱节点没有右子树（初始状态），就将前驱节点的 right 指针指向当前节点，这一步是为了在遍历完前驱节点后能找到前驱节点的后继，也就是当前节点-如果前驱节点的右子树为当前节点，说明前驱节点已经被遍历过并被修改了 right 指针，这个时候重新将前驱的右子设置为空，访问当前节点，然后跳转到当前节点的右子树##附：N叉树遍历 N叉树遍历，相当于把树的孩子节点数量从两个拓展到了N个，此时一般不讨论 中序遍历（中间不唯一）####先序 ```python def preorderTraversal(root):res=[]stack=[]if root:stack.append(root)while len(stack)> 0:node=stack.pop()res.append(node.val)for child in reversed(node.children):#将所有子结点逆序加入栈中 stack.append(child)return res ```####后序 一种偷懒的实现方法是复用前序遍历的方法，然后对结果进行翻转，但这样并非真的“遍历” 下面仿照二叉树的后序遍历改造实现 ```python def postorderTraversal(root):res=[]stack=[]pre=None;#记录上一个访问的节点 if root:stack.append(root)while len(stack)> 0:node=stack[-1]#当前栈顶节点没有子节点 或 最后一个子节点已经访问过 则出栈 并加入记录 if len(node.children)==0 or node.children[-1]==pre:res.append(node.val)stack.pop()pre=node else:#否则 将全部子节点逆序加入栈中 for child in reversed(node.children):stack.append(child)return res ```####层序 ```python def levelOrder(root):res=[]queue=collections.deque([])if root:queue.append(root)while queue:size=len(queue)while size:node=queue.popleft()res.append(node.val)for child in node.children:queue.append(child)size-=1 return res ```##相关题目 https://leetcode-cn.com/problems/binary-tree-inorder-traversal/https://leetcode-cn.com/problems/binary-tree-preorder-traversal/https://leetcode-cn.com/problems/binary-tree-postorder-traversal/https://leetcode-cn.com/problems/binary-tree-level-order-traversal/https://leetcode-cn.com/circle/article/ut9SBc/","tags":["LeetCode","Binary Tree"],"categories":[]},{"title":"LeetCode刷题笔记","url":"/s/p/bhwxzl/","content":"####难度 题目本身标识的难度级别只是对所有人的平均情况，应该建立自己的难度评估标准 保存和记录自己做过的每一题，可以分为四个等级-`trival`：能马上想到解法的题目，并且代码量较少，保证能一次写对，比如数组或字符串的简单模拟题-`easy`：能马上想到解法的题目，但实现起来需要注意一些细节、边界情况，能写出来，但需要一些修改调试，如链表类题目-`medium`：能知道大致思路，但实现起来较为繁琐，边界条件较为复杂，比如一些回溯类题目、动态规划题目、二分查找-`hard`：不知道解法（不在常见套路中或者需要一定的问题转换或者需要多个知识点），或者能知道大致思路但需要在常规套路上做较大的变动 刷题是提高自己熟练度的过程，也是把难度一层一层往下降的过程####规模 LeetCode上的很多题目可以根据题目提供的输入规模大致判断时间复杂度的最低要求|**Input Size**|**Complexity**|**可能的解法**||--------------|--------------|-------------||$[-2^{31},2^{31}-1]$|$O(1)$|位运算/数位运算/数学||$[10^4,10^7]$|$O(logn)$|二分/倍增/快速幂/辗转相除||$[10^4,10^6]$|$O(n)$|单重循环枚举+哈希表(unordered_set/unordered_map)/双指针/滑动窗口/栈(单调栈)/队列/串匹配算法/动态规划/贪心||$[10^4,10^5]$|$O(nlogn)$|排序/堆(priority_queue)/红黑树(set/map)||$\\le 3000$|$O(n^2)$|双重循环枚举/动态规划/Dijkstra||$\\le200$|$O(n^3)$|三重循环枚举/动态规划/Floyd||$\\le50$|$O(n^4)$|||$\\le20$|$O(2^n)$|回溯（组合）[494.目标和](https://leetcode-cn.com/problems/target-sum/)||$\\le15$|$O(n2^n)$|回溯（组合）[491.递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)||$\\le10$|$O(n!)$|回溯（排列）|####思路 突变-> 二分 有序-> 二分和双指针 满足xx的最小区间/搬动元素/合并序列-> 双指针 所有长度为k区间的xx-> 滑动窗口 下一个更大/小-> 单调栈 最值-> 回溯/搜索、动态规划、贪心 所有情况-> 回溯/搜索 TopK/动态维护最值-> 优先队列 元素不变，前缀查询（或者能通过前缀“差”计算区间“和”）-> 前缀“和” 元素变，前缀查询（或者能通过前缀“差”计算区间“和”）-> 树状数组 元素变，区间查询-> 线段树########溢出 有符号数的相加/相乘/左移时需注意 相加时如果需要判断是否溢出，可以用INT_MAX-一个加数与另一个加数比较大小-eg：[29.两数相除](https://leetcode-cn.com/problems/divide-two-integers/)有时候答案是int范围，但计算过程可能超出int，需要使用long long或者调整计算顺序，特别是那种先乘后除或先加后减的情况-eg：二分查找取中点需要使用 `(r-l)/2+l`，因为`(l+r)/2`可能发生溢出######Leetcode的溢出 Java：发生溢出时，直接当成负数来处理（最大与最小值连成环） 这意味着，如果我们在运算过程中如果只涉及「纯加减运算」，而不涉及「乘除」、「取最大值/最小值」和「数值大小判断」的话，不需要使用 long 来确保正确性，只要答案最终是 int 范围，溢出会被转化回来。 ```Java System.out.println(Integer.MIN_VALUE);//-2147483648 int a=Integer.MAX_VALUE;System.out.println(a);//2147483647 a+=1;System.out.println(a);//-2147483648 a-=1;System.out.println(a);//2147483647 ``` C++：对于 int 溢出的处理也是**一样**的。 但在 leetcode 上的 C++发生溢出时，会直接抛出运行时异常（应该是因为编译选项开启了`-fsanitize=undefined`）。 因此同样的代码无法被正常执行的 ```C++cout << INT_MIN << endl;//-2147483648 int a=INT_MAX;cout << a << endl;//2147483647 a+=1;//运行时报错 cout << a << endl;a-=1;cout << a << endl;```####区间 无论是普通的循环还是二分查找的上下界，坚持左闭右开原则，能避免很多`off-by-one`错误 至少有以下几点显而易见的优雅之处-$[l,r)$长度就是$r-l$-$l==r$时就是空区间-相邻的区间，上一个区间的上界是下一个区间的下界，比如$[1,2)$ $[2,3)$ $[3,4)$####双指针 广义的双指针就是指使用 两个指针 在 两个线性结构上（可以是同一个数组）同时（即交替）地同向（或反向，即首尾分别开始）前进 应用：-搬动元素：如原地移除指定或重复的元素、快排划分中交换两侧元素、归并两个有序数组-枚举排序数组中的两个元素：如果我们发现随着第一个元素的递增，根据约束条件或者剪枝条件（舍弃的部分不会有更优的解），第二个元素是递减的，可以使用相向双指针的方法，将枚举的时间复杂度从 O(N^2)减少至 O(N)。（枚举的过程，左指针每次向右移动一个位置，而右指针每次向左移动若干个位置，两指针一共会移动的次数为 O(N)，均摊下来，相当于左指针每次向右移动一个位置。）思考：这种双指针是贪心的思想吗？-eg.[11.盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)-eg.排序数组的两数之和 如果是在同一数组上，同向或/且两指针距离保持固定，可以称为滑动窗口 应用：-覆盖类问题：满足xx的最小区间，如字符串满足某些字符计数达到指定值、数组区间和达到某些值-所有区间的统计值：最值、平均、中位数，需要用另外的数据结构动态维护区间数据####单调栈 求解第一个大于/小于当前元素的下标 以单调递增栈为例-如果将入栈的元素大于栈顶元素，直接入栈，-否则，一直出栈直到栈顶满足上述条件，再入栈 性质1：当一个元素出栈时，将入栈的元素是后面第一个小于等于它的元素 性质2：当一个元素入栈时，此时栈顶元素是前面第一个小于它的元素（第一个小于等于它的元素的前一个元素）####串算法#####Manacher 算法 是在线性时间内求解最长回文子串的算法 https://leetcode-cn.com/problems/longest-palindromic-substring/https://leetcode-cn.com/problems/palindromic-substrings/solution/hui-wen-zi-chuan-by-leetcode-solution/#####KMP 算法 链接：https://leetcode-cn.com/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/读者需要注意以下几点：-KMP 算法虽然有着良好的理论时间复杂度上限，但大部分语言自带的字符串查找函数并不是用 KMP 算法实现的。这是因为在实现 API 时，我们需要在平均时间复杂度和最坏时间复杂度二者之间权衡。普通的暴力匹配算法以及优化的 BM 算法拥有比 KMP 算法更为优秀的平均时间复杂度；-学习 KMP 算法时，一定要理解其本质。如果放弃阅读晦涩难懂的材料（即使大部分讲解 KMP 算法的材料都包含大量的图，但图毕竟只能描述特殊而非一般情况）而是直接去阅读代码，是永远无法学会 KMP 算法的。读者甚至无法理解 KMP 算法关键代码中的任意一行。 由于本题就是在一个字符串中查询另一个字符串是否出现，可以直接套用 KMP 算法。因此这里对 KMP 算法本身不再赘述。读者可以自行查阅资料进行学习。这里留了三个思考题，读者可以在学习完毕后尝试回答这三个问题，检验自己的学习成果：-设查询串的的长度为 $n$，模式串的长度为 $m$，我们需要判断模式串是否为查询串的子串。那么使用 KMP 算法处理该问题时的时间复杂度是多少？在分析时间复杂度时使用了哪一种分析方法？-如果有多个查询串，平均长度为 $n$，数量为 $k$，那么总时间复杂度是多少？-在 KMP 算法中，对于模式串，我们需要预处理出一个 $\\textit{fail}$ 数组（有时也称为 $\\textit{next}$ 数组、$\\\\pi$ 数组等）。这个数组到底表示了什么？ 答案-设查询串的的长度为 $n$，模式串的长度为 $m$，我们需要判断模式串是否为查询串的子串。那么使用 KMP 算法处理该问题时的时间复杂度是多少？在分析时间复杂度时使用了哪一种分析方法？-时间复杂度为 $O(n+m)$，用到了均摊分析（摊还分析）的方法。-具体地，无论在预处理过程还是查询过程中，虽然匹配失败时，指针会不断地根据 $\\textit{fail}$ 数组向左回退，看似时间复杂度会很高。但考虑匹配成功时，指针会向右移动一个位置，这一部分对应的时间复杂度为 $O(n+m)$。又因为向左移动的次数不会超过向右移动的次数，因此总时间复杂度仍然为 $O(n+m)$。-如果有多个查询串，平均长度为 $n$，数量为 $k$，那么总时间复杂度是多少？-时间复杂度为 $O(nk+m)$。模式串只需要预处理一次。-在 KMP 算法中，对于模式串，我们需要预处理出一个 $\\textit{fail}$ 数组（有时也称为 $\\textit{next}$ 数组、$\\\\pi$ 数组等）。这个数组到底表示了什么？-$\\textit{fail}[i]$ 等于满足下述要求的 $x$ 的最大值：$s[0:i]$ 具有长度为 $x+1$ 的完全相同的前缀和后缀。这也是 KMP 算法最重要的一部分。####自定义Hash函数 对于基于`hashtable`的`unordered`系列的容器，键类型需要有hash函数，基础类型和string，标准库的`std::hash<>`提供了特化版本，其他自定义类型或容器类需要自行实现 注意，-hash函数一定会存在冲突，hash函数设计不好会导致分布不均匀，冲突更多，但只不过是影响hash表的效率；为基于哈希表的数据结构`unordered_set<vector<int>>`设计自定义的hash函数，即使多个`vector<int>`对应的hash值冲突，内部也会用链表一一记录-但如果是自行使用hash函数将`vector<int>`进行hash后得到一个`unsigned long long`才插入`set<unsigned long long>`，那么hash值冲突的若干个`vector<int>`将无法被区分！！#####自定义对字符串/字符数组的的哈希函数 自然溢出(mod 2^64)```c++constexpr unsigned long long base=131;unsigned long long charsHash(const char*str,int n){unsigned long long h=0;for(int i=0;i < n;i++){h=h*base+str[i];}};``` 单哈希 （[Rabin-Karp 字符串编码](https://leetcode.cn/problems/longest-happy-prefix/solution/zui-chang-kuai-le-qian-zhui-by-leetcode-solution/)） ```c++constexpr unsigned long long base=131,mod=10e18+7;unsigned long long charsHash(const char*str,int n){unsigned long long h=0;for(int i=0;i < n;i++){h=(h*base+str[i])%mod;}};```#####自定义对 array<int,26> 类型的哈希函数 常见于滑动窗口中统计各种字符的出现次数，由于长度固定为26<32，可用直接右移一位然后累计异或 ```c++auto arrayHash=[int_hash=hash<int>{}](const array<int,26>&arr)-> size_t{return accumulate(arr.begin(),arr.end(),0u,[&](size_t acc,int num){return(acc << 1)^int_hash(num);});};unordered_map<array<int,26>,vector<string>,decltype(arrayHash)> mp(0,arrayHash);```#####自定义对不定长度序列的哈希函数 以`vector<int>`为例######一个万用的哈希函数 魔数`0x9e3779b9` ```c++auto vector_hash=[](const vector<int>&vec){unsigned long long seed=vec.size();for(int v:vec)seed^=v+0x9e3779b9+(seed >> 2)+(seed << 6);return seed;};unordered_set<vector<int>,decltype(vector_hash)> s(0,vector_hash);```######另一种思路：转为字符串 把`vector<int>`转成元素的字符串拼接，`string`作为容器的`key`，这样无需提供hash函数#####自定义对 pair<T,U> 类型的哈希函数 考虑T/U为基础类型，一种方法是异或，但碰撞较为严重，hash表效率会降低 ```c++auto pair_hash=[](const auto p){return std::hash<decltype(p.first)>()(p.first)^std::hash<decltype(p.second)>()(p.second);}``` 另一种方法是借用上面的万用方法 ```c++auto pair_hash=[](const auto p){unsigned long long v1=std::hash<decltype(p.first)>()(p.first)+0x9e3779b9;unsigned long long v2=std::hash<decltype(p.second)>()(p.second)+0x9e3779b9;return v1^(v2+(v1 >> 2)+(v1 << 6));};```#####仿函数实现 为哈希表自定义hash函数可以有两者写法，一种是上面的lambda，一种是仿函数 对于lambda，它本质是一个匿名类的实例，无法显示调用构造函数，所以只能在构建哈希表时显示传入实例，且decltype作为模板参数 ```c++unordered_set<pair<int,int>,decltype(pair_hash)> s(0,pair_hash);``` 如果这个unordered_set本身再作为某个容器的元素，就会有问题，插入元素内部构造时会调用lambda的构造函数而报错 ```c++unordered_map<int,unordered_set<pair<int,int>,decltype(pair_hash)>> d;``` 这时候就应该用仿函数 ```c++int main(){class PIIHash{public:size_t operator()(const pair<int,int>&p)const{return hash<int>()(p.first)^hash<int>()(p.second);}};unordered_map<int,unordered_set<pair<int,int>,PIIHash>> lines1;lines1[1]=unordered_set<pair<int,int>,PIIHash>();lines1[1].insert(make_pair(1,2));auto pii_hash=[int_hash=hash<int>()](pair<int,int> pii){return int_hash(pii.first)^int_hash(pii.second);};unordered_map<int,unordered_set<pair<int,int>,decltype(pii_hash)>> lines2;lines2.emplace(1,std::move(unordered_set<pair<int,int>,decltype(pii_hash)>(0,pii_hash)));lines2[1].insert(make_pair(1,2));return 0;}``` 注意，重载 operator()，**参数要const，成员函数也要const**，否则unordered_set模板内部会匹配不上####自定义排序和优先队列比较函数######比较操作符 7种比较操作符，`operator==,!=,<,<=,>,>=,<=>(C++20)`######比较函数 对于排序或优先队列，可以自定义比较函数 排序过程或中或维护队列过程中任意两个元素都可能被比较，相当于给所有元素定一个全局唯一顺序 > 因此比较函数是一个全序的二元关系R（对于集合中的任何一对元素，在这个关系下都是**相互可比较**的），需满足 > >-传递性（如果 a R b 且 b R c 则 a R c），`cmp(a,b)&&cmp(b,c)==true-> cmp(a,c)==true` >-反对称性（如果 a R b 且 b R a 则 a is b），`cmp(a,b)&&cmp(b,a)-> a==b` >-完全性（即 a R b 或 b R a 必满足其一），`cmp(a,b)||cmp(b,a)==true` > > `<=`和`>=`就是全序关系， 元素的比较函数实现的是`<`或`>`语义而不是`<=`语义或`>=`语义 ，换句话说，对于语义上相等的元素，必须放回`false`######排序和优先队列 对应C++的sort函数，默认是升序（第三个模板参数默认为`less<T>`） 对于C++的优先队列，默认是大根堆（第三个模板参数默认为`less<T>`） `less<T>`或`greater<T>`是比较操作符的一个包装，会调用对应的`operator<`和`operator>` 如果元素是基本类型，使用内建比较操作符 如果元素是自定义结构体或类，默认没有比较操作符，需要自行实现 对于pair和tuple，默认有比较操作符（即朴素地依次比较每个元素），也可重载自行实现 要实现小根堆或降序，可以-实现重载`operator<`为“语义上”的`>`-或者优先队列的第三个模板参数改用`greater<T>`（需要该类型有实现`operator>`）-直接用lambda或仿函数实现比较函数（第三个模板参数） ```c++auto cmp=[&nums1,&nums2](const pair<int,int>&a,const pair<int,int>&b){return nums1[a.first]+nums2[a.second]> nums1[b.first]+nums2[b.second];};priority_queue<pair<int,int>,vector<pair<int,int>>,decltype(cmp)> pq(cmp);```####随机数#####C++标准库 `<random>` ```c++//random_device 是使用硬件熵源的非确定随机数生成器，可以认为是真随机数//random_device{}()即获取一个真随机数，作为预定义随机数生成器mt19937的种子 mt19937 rng{random_device{}()};mt19937_64 rng{random_device{}()};//64位版本//xxx_distribution 是随机数分布，对随机数生成器的产生结果进行变换//[a,b]均匀分布 整数 uniform_int_distribution<int> uni(a,b);//[a,b)均匀分布 浮点数 uniform_real_distribution<double> uni(a,b);//获取 int v=uni(rng);```#####C标准库` <stdlib.h>` ```c++//用当前时间作为种子进行初始化 srand((unsigned int)time(0));//返回[0,RAND_MAX]之间的随机整数（RAND_MAX+1个数中的任意一个）//标准规定了RAND_MAX 的值应至少为32767，不同实现上不同//GNU C 实现为 2147483647 rand();//获取[0,1]的随机浮点数 rand()/(double)RAND_MAX;//获取[0,1)的随机浮点数//rand()/(double)(RAND_MAX+1);//RAND_MAX+1可能溢出！ rand()/((unsigned)RAND_MAX+1);rand()/(RAND_MAX+1U);rand()/((double)RAND_MAX+1);rand()/(RAND_MAX+1.0);//获取[0,n]的随机整数，下面这样是错误的//因为RAND_MAX+1不一定是n+1的整数倍，取余后，存在两种不同概率的数//以RAND_MAX==32767，n+1==10000为例，得到[0,2767]的情况有4种，得到[2768,9999]的情况只有3种， rand()%(n+1);//获取[0,n)的随机整数(int)(n*rand()/(RAND_MAX+1.0));//获取[a,b]的随机数，拒绝采样法，可能导致超时，特别是N比RAND_MAX/2大一些的情况 inline int randint(int a,int b){const unsigned int N=b-a+1;const unsigned int bound=(RAND_MAX+1U)/N*N;//超过bound的部分不足N个，重新随机 int r;do{r=rand();}while(r >=bound);return a+int(r/(double)bound*N);}```####其他注意事项-浮点数相等比较-浮点数转整数（显式或隐式），正负数的处理不同！正数是向下取整，负数是向上取整！-`std::accumulate`的初始值类型，比如`long long s=accumulate(nums.begin(),nums.end(),0ll);//注意这里0ll`，结果是64位，初始值类型也要是64位，否则模板推导出32位`int`作为中间变量会溢出-unordered容器使用auto遍历，key是无序的-动态规划or背包问题，注意每层循环遍历的方向-剪枝要非常小心，不要把正确答案也剪掉了！先通过再说，没有把握，就不要随便剪枝！-使用contine千万注意，特别是在循环代码里的某些值必须每轮都更新-对于图的题目-注意顶点索引是从0开始还是从1开始，-注意是有向图还是无向图-对于无向图，应该添加两次边，边相关的数组开两倍-*Dijkstra*算法如果已经找到目标点到源点的最短距离，就可以提前返回了，剩余点无需再计算-注意图中的重边，去除有时候题目要求取最小-在正确的时机标记vis-非leetcode平台，需要自行处理IO时，对于输入的一组数据是数组或矩阵-如果是按单个元素或单行元素直接处理而不是先存储整组数据，若处理过程中已知道这组数据的对应结果而直接输出，此时要记得清理剩余输入！！！而不是直接break或continue；否则会把剩余数据当成下一组-给定序列，包含`n`个元素`e_i`，需要对序列中的连续相等或连续满足某个条件`f(e)`的每个子序列(设长度为`cnt`)进行计算处理`p(e,cnt)`-方法1，记录上一个的结果`pre`及其重复次数`cnt`，遍历每个元素`e`时判断与`pre`是否相等，-相等，则`cnt`加1-不相等，则处理上一次的结果`p(pre,cnt)`，然后重置`cnt=1,pre=e`-缺点：-第一次循环时，必然不相等，还需要针对第一次判断无效`pre`的情况，这对于后面的循环是无意义的-最后循环退出时，还需要额外处理最后一次连续的结果，往往需要复制粘贴之前处理的代码然后做一些修改，容易出错！（也可以提取为inline函数，但很多需要修改的局部变量需要传入引用）-方法2，双指针，`i`下标遍历每个元素`e`，对于`i`，`j`从`i`开始遍历直到不相等或序列结束，-这样即避免了第一次特殊判断，也避免了最后一次额外处理，代码如下 ```c++for(int i=0,j=0;i < s.size();i=j){char e=s[i];while(j < s.size()&&e==s[j])++j;int cnt=j-i;...//处理p(e,cnt)}``` 遍历临时构建的初始化列表 ```c++for(auto V:{1,2,3,4})```####二叉树/N叉树 二叉树层序遍历时，队列的大小要在每一层开始遍历时保存 满二叉树（堆）节点顺序与位运算的关系 树哈希 https://leetcode-cn.com/problems/subtree-of-another-tree/solution/ling-yi-ge-shu-de-zi-shu-by-leetcode-solution/树序列化####位运算 关于位运算的技巧，请看另一篇博客：C++位运算总结######压缩状态 在字符串和数组的题目中，如果需要编码的状态或存储的映射关系较少，巧妙运用位表示可以加快速度或避免使用集合和哈希表[187.重复的DNA序列](https://leetcode-cn.com/problems/repeated-dna-sequences/)[1684.统计一致字符串的数目](https://leetcode-cn.com/problems/count-the-number-of-consistent-strings/)作为记忆化搜索的状态表示（每个位表示某个对象是否已被选择），即dp[state]，state是整数，-这类问题一般规模最多20，用20位就可表示-[[473]火柴拼正方形](https://leetcode-cn.com/problems/matchsticks-to-square/)-[[464]我能赢吗](https://leetcode.cn/problems/can-i-win/)######与堆和完全二叉树的关系######异或的性质 异或运算满足结合律和交换律 a^a==0 a^b==c <==> a^c==b 只出现一次的数字系列######考虑每位对结果的影响，单独计算 困难题#####树状数组/线段树####模拟退火 ```c++class Solution{public:static constexpr double eps=1e-18;static constexpr double delta=0.995;//调了一年的参数一般为0.97~1.0 long ans=LONG_MIN;long calc(vector<int>&nums,int k){long res=0;int n=nums.size();for(int i=0;i < n;i++)res+=(i+k)%n*nums[i];ans=max(ans,res);//更新答案 return res;}void sa(vector<int>&nums){int n=nums.size();long last=LONG_MIN/2;for(double t=1e6;t > eps;t*=delta){int k=rand()%n;long now=calc(nums,k);long d=now-last;if(d > 0||//比当前优秀就接受 exp(-1.0*d/t)*RAND_MAX > rand()//否则以一定概率接受){last=now;}}}int maxRotateFunction(vector<int>&nums){double t=0;while((t=clock()/(1.0*CLOCKS_PER_SEC))<=0.98){//不超时的情况下尽可能多计算//cout << t << endl;srand(time(0));sa(nums);}return ans;}};```####REF https://leetcode-cn.com/problems/combination-sum-iv/solution/gong-shui-san-xie-yu-wan-quan-bei-bao-we-x0kn/[算法学习笔记-知乎专栏](https://www.zhihu.com/column/c_1182444932760125440)https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE3MTEyMA==&action=getalbum&album_id=1751702161341628417&scene=173&from_msgid=2247486649&from_itemidx=1&count=3&nolastread=1#wechat_redirect https://www.cnblogs.com/wei-li/p/2711629.html https://blog.csdn.net/github_36778422/article/details/106379106","tags":["LeetCode"],"categories":[]},{"title":"img_test","url":"/s/p/b4iaex/","content":"###Padding Lorem ipsum dolor sit amet,consectetur adipisicing elit.Impedit aut,neque quaerat in consectetur dignissimos deserunt autem architecto soluta,error dolores facere,numquam possimus repellat reiciendis maxime officia?Dolorum,nemo.Lorem ipsum dolor sit amet,consectetur adipisicing elit.Impedit aut,neque quaerat in consectetur dignissimos deserunt autem architecto soluta,error dolores facere,numquam possimus repellat reiciendis maxime officia?Dolorum,nemo.Lorem ipsum dolor sit amet,consectetur adipisicing elit.Impedit aut,neque quaerat in consectetur dignissimos deserunt autem architecto soluta,error dolores facere,numquam possimus repellat reiciendis maxime officia?Dolorum,nemo.###Large Image ![](./img_test/dojm2h.png)###Padding Lorem ipsum dolor sit amet,consectetur adipisicing elit.Impedit aut,neque quaerat in consectetur dignissimos deserunt autem architecto soluta,error dolores facere,numquam possimus repellat reiciendis maxime officia?Dolorum,nemo.Lorem ipsum dolor sit amet,consectetur adipisicing elit.Impedit aut,neque quaerat in consectetur dignissimos deserunt autem architecto soluta,error dolores facere,numquam possimus repellat reiciendis maxime officia?Dolorum,nemo.Lorem ipsum dolor sit amet,consectetur adipisicing elit.Impedit aut,neque quaerat in consectetur dignissimos deserunt autem architecto soluta,error dolores facere,numquam possimus repellat reiciendis maxime officia?Dolorum,nemo.","tags":["test","image"],"categories":["test","image"]},{"title":"markdown test","url":"/s/p/b2ppc0/","content":"###Header（标题）#h1（这是1个#号的标题）##h2（这是2个#号的标题）###h3（这是3个#号的标题）####h4（这是4个#号的标题）#####h5（这是5个#号的标题）######h6（这是6个#号的标题）###Paragraph（段落） 这是Markdown的一个段落[^1][^b]aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 如果是一堆字母并且没有空格，系统会认为这是一个单词，不进行换行；如果是一堆字母并且没有空格，系统会认为这是一个单词，不进行换行；如果是一堆字母并且没有空格，系统会认为这是一个单词，不进行换行[^b]下面这是分隔线------下面是Markdown特殊字符\\\\\\_\\*\\#\\$ 下面是HTML特殊字符&< >###Style（样式）**这是Bold（粗体）**__这也是bold（粗体）__*这是Italic（斜体）*_这也是Italic（斜体）_ ~~这是Delete（划掉）~~###Quote（引用） 这是`quote（行内的引用）` > 这是blockquote（块引用）###Formula（公式） 语法[^a]在代码和HTML标签内不起作用 <p>$1+1=2$</p> `$1+1=2$` 这是行内公式， $e^{i\\pi}+1=0$ $\\displaystyle f(x)=\\int_{-\\infty}^\\infty f(t)e^{2\\pi i x t}\\,dt$ ${\\displaystyle\\iint _{\\Sigma}\\nabla\\times\\mathbf{F}\\cdot d{\\boldsymbol{\\Sigma}}=\\oint _{\\partial\\Sigma}\\mathbf{F}\\cdot d\\mathbf{r}}$ $i\\hbar\\frac{\\partial\\Psi}{\\partial t}=-\\frac{\\hbar^2}{2m}\\nabla^2\\Psi+V\\Psi$ 这是多行公式， $$ C=\\left\\{\\begin{align}&12.92\\,C_{\\text{linear}}&,\\quad&C_{\\text{linear}}\\le0.0031308\\\\[0.5em]&1.055\\,C_{\\text{linear}}^{1/2.4}-0.055&,\\quad&C_{\\text{linear}}>0.0031308\\end{align}\\right.$$ 这是多行公式， $$\\begin{cases}\\nabla\\cdot D=\\rho\\\\\\nabla\\cdot B=0\\\\\\nabla\\times E=-\\frac{\\partial B}{\\partial t}\\\\\\nabla\\times H=J+\\frac{\\partial D}{\\partial t}\\end{cases}其中 B=\\mu_{0}H,\\D=\\varepsilon_{0}E $$###Table（表格）|a|b|c||:--:|:--:|:--:||1|2|3||4|5|6||7|8|9|###Code（代码） ```c//comment int func(){int n=100;char b='\\0';for(int i=0;i < n;i++){printf(\"%c\",&(b+i));}while(n--){printf(\"%d\",&n);printf(\"%d\",&n);printf(\"%d\",&n);printf(\"%d\",&n);}return 0;}```###Mermaid ```Mermaid sequenceDiagram participant A as Alice participant J as John A->>J:Hello John,how are you?J->>A:Great! ``` ```mermaid gantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task:a1,2014-01-01,30d Another task:after a1,20d section Another Task in sec:2014-01-12,12d another task:24d ```###Ordered-List（有序列表） 有序[^2]1.item 1.sub_item 2.item 1.sub_item 1.sub_sub_item 2.sub_item 3.item###Unordered-List（无序列表） 无序[^3]-item-item-sub_item-sub_item-sub_sub_item-sub_item-item###Image（图片） ![图片1](markdown_test/markdown.jpg)<p><img src=\"./markdown_test/markdown.jpg\" width=\"100px;\" height=\"200px;\"></img></p> <center><a>Image</a></center>###Link（链接）[百度][1][1]:https://www.baidu.com \"百度\"[百度](https://www.baidu.com)###HTML INPUT <input id=\"test-input\" type=\"text\" value=\"123\"></input> <button onclick=\"alert('你输入了'+document.getElementById('test-input').value);\">点击我</button> <input id=\"test-checkbox1\" type=\"checkbox\" checked/> <label for=\"test-checkbox1\">多选1</label> <input id=\"test-checkbox2\" type=\"checkbox\"/> <label for=\"test-checkbox2\">多选2</label> <input id=\"test-radio1\" name=\"test-radio\" type=\"radio\" checked/> <label for=\"test-radio1\">单选1</label> <input id=\"test-radio2\" name=\"test-radio\" type=\"radio\"/> <label for=\"test-radio2\">单选2</label> <input id=\"range1\" type=\"range\" min=\"0\" max=\"100\" step=\"1\" value=\"50\"> <select id=\"province-id-select\"><option value=\"1\"> 选项1 </option><option value=\"2\"> 选项2 </option><option value=\"3\"> 选项3 </option></select>###FootNote（脚注）[^1]:Markdown是一种纯文本标记语言[^2]:有序[^3]:无序[^a]:用两个\\$\\$包裹起来[^b]:这是一个很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的脚注[^b]:我是一个重复索引的脚注","tags":["test","markdown"],"categories":["test","markdown","aaa","bbb","ccc"]},{"title":"Hexo博客搭建记录","url":"/s/p/b2jglz/","content":"####简介 Hexo一个基于Nodejs的静态博客框架，通用预定义的模板和内嵌变量将Markdown文档渲染为静态网页 本博客就是使用Hexo搭建的，并且自行开发了主题 通过官方[文档](https://hexo.io/zh-cn/docs/helpers)和[API手册](https://hexo.io/zh-cn/api/)，即可搭建和编写简单主题，但有些配置和细节文档中没有描述的很清楚，这里主要记录了博主搭建博客和编写主题、使用插件的过程####包 Nodejs通过npm来管理模块/包，包目录下的package.json记录的包的名称、版本和依赖包（dependencies）等信息，安装的包在node_modules中 对于hexo，在一个目录（下面称为博客目录或博客）初始化后就产生了一个包，这个包里的package.json还有一个特殊项`hexo`，指定了hexo的版本，一般不需要手动修改package.json 通过npm可以安装主题和插件（主题和插件本身也是一个个包，作为博客包的依赖） dependencies中可以看到一些默认安装的官方插件 ``` \"hexo-generator-archive\":\"^1.0.0\",\"hexo-generator-category\":\"^1.0.0\",\"hexo-generator-tag\":\"^1.0.0\",\"hexo-renderer-swig\":\"^1.0.0\",\"hexo-renderer-stylus\":\"^1.0.0\",\"hexo-renderer-marked\":\"^4.0.0\",\"hexo-theme-landscape\":\"^0.0.3\",```-renderer是渲染器，从一种文件格式得到另一种文件格式-swig/markdown-> html-less/sass/stylus-> css-generator是页面生成器，通过调用hexo的api，根据某个特定的模板，在特定的路径下生成页面-theme是主题，默认安装landscape主题 博客的配置在_config.yml文件中，hexo渲染过程中，主题、插件可以读取配置的中的配置项 博客目录下的scripts子目录可以放置一些js脚本，通过hexo的api介入渲染和生成过程，类似于插件，如果要实现一些自用的功能，而不需发布为插件，则不用建立一个单独的包，直接添加到该目录下即可，渲染时 博客目录下的themes子目录也可以放置手动下载解压的主题 博客目录下的source子目录存放博客源文件，_posts目录中markdown格式文件会被渲染，而其他文件直接复制到public，具体规则可以在配置中控制 博客目录下的public子目录存放生成的静态页面文件####配置-配置中的永久链接格式`permalink:`，可以用一些预定义变量，对于文章的路径-`:title`包括了相对_post的路径-`:name`才是纯文件名-可在配置中添加以下，来开启`hexo server`时的gzip压缩-官方文档里没有提及，但打印`hexo.config`对象可以看到默认配置-开启后在调试时使用浏览器控制台的lighthouse作性能评估时就不会提示`启用文本压缩`这一项了 ```yaml server:compress:true ```####渲染器 渲染器插件实际上只是对真正的渲染引擎作简单的包装，通过hexo的API`hexo.extend.renderer.register`注册文件映射，调用真正的渲染引擎渲染， 比如hexo-renderer-less插件，实际调用less进行渲染######模板 模板的默认渲染器是ejs，即主题的layout目录下应该都是.ejs文件 也可以换成swig，jade，pug等 只能安装一种，否则可能会有冲突 ```bash npm install hexo-renderer-ejs--save npm install hexo-renderer-swig--save npm install hexo-renderer-jade--save npm install hexo-renderer-pug--save ```######样式 样式的默认渲染器是stylus 可以安装less或sass渲染器 ```bash npm install hexo-renderer-less--save npm install hexo-renderer-stylus--save npm install hexo-renderer-sass--save ``` 对于less插件，自定义渲染的文件路径和less配置项，需要在**主题的**配置中修改，如`themes/yourtheme/_config.yml` ```yaml less:paths:[\"/[主题的]source/css\",\"/[主题的]source/css/*\",\"/[主题的]source/css/style.less\"]//会转换到public对应的css，下划线开头的子文件夹不会处理 options://会直接传给less compress:true ```######markdown markdown的默认渲染器是marked，会对`$$`内部公式进行默认转义导致mathjax解析失败 kramed是在marked基础上修改的，支持了数学公式以markdown中的原样输出 ```bash npm uninstall hexo-renderer-marked--save npm install hexo-renderer-kramed--save ``` 但其实还是有小问题，比如 `$a_b^c,C_{linear}$`中间两个下划线之间的内容会被当成斜体 最后还是在主题中写了脚本通过api在渲染前提前替换，渲染后再替换回去####生成器 默认的几个生成器的生成规则如下#####archives 生成后有一个总主页/archives/每年有一个主页/archives/[year]每月有一个主页/archives/[year]/[month]它们都由archive.ejs生成，可在模板内判断is_archive,is_year,is_month#####tags 每个tag有一个主页/tags/[tag]，由tag.ejs生成 没有总主页，需要自行补充！-方法一：在source中，添加tags目录并在其中添加文件index.md 此时是用普通的布局page.ejs生成，可在其模板内部通过路径`page.path===\"tags/index.html\"` 或 `page.source===\"tags/index.md\"`作特殊判断-方法二：在layout里新建一个布局tags.ejs（内容自定，可以用变量`site.tags`获取所有标签），然后在scrips里添加一个generator脚本，注册 ```js hexo.extend.generator.register('tags',function(locals){return{path:'/tags/index.html',layout:['tags'],data:locals.theme};});``` 注意：[标签插件](https://hexo.io/zh-cn/docs/tag-plugins)是用于在markdown中引入新的语法标记，和这里文章的分类标签不是一回事，另外，本博客及主题不打算使用标签插件，因为这会引入非标准markdown语法，不便于以后迁移#####categories 类似tags####一些有用的插件######图片路径问题 修改博客配置的`post_asset_folder:true`，这样每篇文章都使用独立的资源文件夹（即`hexo new[title]` 时会创建同名文件夹） 但如果在markdown中按一般方式（即相对于独立资源文件夹的路径）引用图片，在渲染后的文章页能看到图片，在主页的文章预览中很可能看不到相对路径图片，需要安装以下插件 ```bash npm install https://github.com/7ym0n/hexo-asset-image--save ```######搜索 静态博客无法通过与服务器交互查询来搜索指定文章，只能在渲染时生成所有文章的一些元信息保存为JSON，在页面加载中通过JS载入，用户搜索时直接从JSON中获取，下面这个插件可以实现 ```bash npm install hexo-generator-search--save ``` 博客配置添加 ```yaml search:path:search.xml 或 search.json field:post content:true ``` 加上content后可以实现全文搜索，但可能导致JSON文件过大，页面加载时间变长######SEO 通过添加网站地图即sitemap，向搜索引擎提供网站的页面位置信息 ```bash npm install hexo-generator-sitemap--save npm install hexo-generator-baidu-sitemap--save ``` 博客配置添加 ```yaml sitemap:path:sitemap.xml baidusitemap:path:baidusitemap.xml ``` sitemap是官方插件，不过好像没有处理配置中root不是/的情况 baidu-sitemap是第三方插件，没有包括tags/categories页面，但处理了root不是/的情况 另外，可以在博客source根目录添加`robots.txt`文件 ``` User-agent:*Allow:/Allow:/archives/Allow:/tags/Allow:/categories/Allow:/page/Disallow:/js/Disallow:/css/Disallow:/img/Sitemap:/sitemap.xml Sitemap:/baidusitemap.xml ```######高亮 关闭hexo默认的高亮引擎，本博客是在主题中实现高亮 ```yaml highlight:enable:false prismjs:enable:false ```######GIT部署 如果在渲染后需要一键部署到github，可以安装插件 ```bash npm install hexo-deployer-git--save ``` 博客配置添加 ```yaml deploy:type:git repo:https://github.com/用户名/用户名.github.io.git branch:master ``` 执行 ```bash hexo d ``` 此时会在博客目录下生成`.deploy_git`目录（内容同public目录），即git仓库，会被强制push到github上####主题与插件开发 主题是一个单独的包，包括几个目录 layout目录，存放模板文件，会被博客全局注册的生成器或者主题内注册的生成器使用 scripts目录，类似全局的scripts目录，调用API或实现自定义功能，如-注册生成器-注册渲染前后的事件监听，实现对渲染过程的控制，如渲染前替换所有的数学公式 source目录，包括网站发布需要的一些样式和脚本文件，样式可以是原始的css，也可以是less等（会经过全局注册的渲染器生成css）####模板 主题的layout目录下存放了各种模板，它们会被注册的对应生成器读取，通过渲染器，加上hexo的内部变量，如文章的信息和配置项等等，最终生成静态页面 在模板中，通过内置的上下文变量和一些辅助函数，可以实现自定义生成页面的内容和样式#####内置上下文变量 全局变量：即所有页面中都可访问的变量，官方表格如下|变量|描述|类型||:-------|:--------------------------------------------------------|:-----------------------------------------------------------||`site`|[网站变量](https://hexo.io/zh-cn/docs/variables#网站变量)|`object`;见[网站变量](https://hexo.io/zh-cn/docs/variables#网站变量)||`page`|针对该页面的内容以及 front-matter 中自定义的变量。|`object`;见[页面变量](https://hexo.io/zh-cn/docs/variables#页面变量)||`config`|网站配置|`object`(站点的配置文件)||`theme`|主题配置。继承自网站配置。|`object`(主题配置文件)||`path`|当前页面的路径（不含根路径）|`string`||`url`|当前页面的完整网址|`string`||`env`|环境变量|???|######网站变量`site` `site.posts` 即所有文章 指放在`_post`文件夹下的md文件 `site.pages` 即所有分页 指放在`_post`文件夹外的md文件######页面变量`page` 在不同类型（`page`/`post`/`index`/`archive`/`tag`/`category`）的页面中，页面变量`page`包含的属性是不一样的，具体参考[官方文档](https://hexo.io/zh-cn/docs/variables)注意：每一个页面都有一个变量叫`page`，同时，有一种布局或者说页面类型叫`page`（意为普通的页面，相对的`post`/`index`/`archive`/`tag`/`category`是特殊的页面类型），不要混淆了哦######其他注意-内置的数组变量，如`site.posts`并不是真的Array，而是一种对象，-有data和length属性，data才是Array(可用forEach)，-有each方法，回调函数`function(obj,idx){}`-对于`site.posts`的每一个`post`对象，`post.date`即文章的日期，若不在markdown文件的头部元数据中指定，则默认为文件的创建日期-指定日期文本后，hexo将日期文本解析为momentjs对象，包含时区偏移，所以日期的数字不一定等于文本的数字，比如文本 2018-02-25 00:00:00-> momentjs对象(2018,02,24,23,00,00,+7)momentjs对象.format()-> 2018-02-24 23:00:00-渲染时，使用hexo自带辅助函数格式化 date(post.date,'YYYY-MM-DD')是不考虑时区偏移的？实测结果是等于原始指定的文本#####内置辅助函数 `url_for(page.path)` 会补上path里缺少的root部分（如果root是/，则没有变化）####API 可在博客的scripts或主题的scripts目录下添加JS脚本，调用hexo的api，改变渲染过程 `hexo`是个全局变量，是Hexo类的实例，在脚本里console.log打印就能得知有哪些属性 一些有用的属性-`xx_dir`各种路径 ``` base_dir:'[path to you blog]\\\\',public_dir:'[path to you blog]\\\\public\\\\',source_dir:'[path to you blog]\\\\source\\\\',plugin_dir:'[path to you blog]\\\\node_modules\\\\',script_dir:'[path to you blog]\\\\scripts\\\\',scaffold_dir:'[path to you blog]\\\\scaffolds\\\\',theme_dir:'[path to you blog]\\\\themes\\\\[theme name]\\\\',theme_script_dir:'[path to you blog]\\\\themes\\\\[theme name]\\\\scripts\\\\',```-`hexo.config`是全局配置，是`_config.yml`文件内容的JSON表示，包括未在配置文件中指明的一些默认配置-`hexo.theme.config`是主题配置，好像只在 回调函数中才能读取到，脚本全局的访问不到（可能此时未加载主题配置）-`hexo.locals`是“局部变量”，其实就是上面模板里的全局变量`site`，可通过`get/set`获取和修改某个变量-比如`hexo.locals.get('pages')`相当于模板里的`site.pages`-`set`方法的参数是一个回调函数-`hexo.*.context==hexo` （`*`包括`source`,`render`,`theme`等等）-`hexo.extend.*.register(callback)` 系列（`*`包括`filter`,`generator`,`renderer`等等）注册的回调函数中，满足`this==hexo`","tags":["hexo","theme"],"categories":[]},{"title":"并行计算上机实验三 CUDA实现向量加法和矩阵乘法","url":"/s/p/a4rhc0/","content":"###题目 CUDA实现向量加法和矩阵乘法-用CUDA实现向量加法的计算-定义A,B两个一维数组，编写GPU程序将A和B对应项相加，将结果保存在数组C中。分别测试数组规模为10W、20W、100W、200W、1000W、2000W时其与CPU加法的运行时间之比。-用CUDA实现矩阵乘法的计算-定义A，B 两个二维数组。使用GPU 实现矩阵乘法。并对比串行程序，给出加速比。###算法设计####向量加法的计算 考虑向量A,B,C,长度为n，C=A+B#####基本的串行算法 使用for循环将A的每个分量加到B的对应分量上得到C的对应分量即可。#####CUDA并行算法 每个线程进行一个分量的计算 由于一个Block最多只能有512个线程，因此设置Block的大小BLOCK_SIZE为500（一维，方便计算，另二维默认为1），Grid的大小为 n/BLOCK_SIZE（一维，另一维默认为1） GPU核函数中，对于每一个线程，记bx=blockIdx.x，tx=threadIdx.x，该线程负责计算i=bx*BLOCK_SIZE+tx下标的向量分量####向量乘法的计算 考虑矩阵A,B,C,C=A x B为了，便于说明，假设宽度和高度均为WIDTH，实际编程中将实现长宽不等的矩阵乘法#####基本的串行算法 两层for循环，每次计算C矩阵中的一个元素 ，需要A的一行和B的一列，对应元素相乘，进行求和，总共是三层循环。 ![img](lab3/clip_image002.jpg)#####CUDA并行算法 只使用了一个线程块，一个线程块中的每个线程计算C中的一个元素，每个线程载入矩阵A中的一行，载入矩阵B中的一列，为每对A和B元素执行了一次乘法和加法。 缺点：计算和片外存储器存访问比例接近1：1，受存储器延迟影响很大；矩阵的大小受到线程块所能容纳最大线程数（512个线程）的限制；所有的线程都要访问全局存储器获取输入矩阵元素；每个输入元素都需要被WIDTH个线程读取。#####CUDA并行分块算法 每个线程块计算一个大小为BLOCK_SIZE的方形子矩阵Csub，每个线程计算Csub子矩阵中的一个元素（假设A、B和C的大小都是BLOCK_SIZE的倍数）。 对于同一个子矩阵中的元素，由于在线程在同一个线程块内，因此可以事先将对应A、B子矩阵的元素复制到共享存储器(Shared Memory)，这样，之后的多次访问就不必每次都到全局存储器中获取了。 算法基本流程：每个线程为了计算自己负责的一个C矩阵的元素，需要A的一行元素和一列元素，对应地，这个线程所在的C的子矩阵的计算需要A的一个子矩阵行和B的一个子矩阵列（如下图）。以A为例，每个线程遍历A的行时，分割为两层循环进行遍历，外层遍历对应行每个子矩阵，内层遍历子矩阵的对应行，而在同一个子矩阵内，可以由共享存储器共享子矩阵，因此，每次外循环一开始（对应一个新的子矩阵），负责该子矩阵的线程块内的线程，就一起从全局存储器的A把该子矩阵读到共享存储器，然后再开始遍历自己负责的子矩阵的行。 对于下图，第一次外循环就是访问A和B的蓝色子矩阵，对应位置线程块的线程就一起把A和B的蓝色块读到共享存储器，然后用两个蓝色块的一行和一列相乘求和，作为C的这个元素的部分和。接下来的外循环会换到红色子矩阵…不断累加这个部分和，最后得到C的这个元素值。对于C的每个元素，由每个线程并行计算。 ![img](lab3/clip_image004.jpg)<!--more-->###算法分析####向量加法的计算 设*n*为向量长度 对于串行算法，时间复杂度为*O*(*n*)对于并行算法，时间复杂度为*O*(1)*，*这里假设每个线程计算一个分量，并且未考虑CPU与GPU的数据交换时间####矩阵分块乘法的计算 设*n*为矩阵高度和宽度的较大值， 对于串行算法，时间复杂度为*O(n^3)*对于并行算法，时间复杂度为*O*(*n*)，因为每个线程计算C矩阵的一个元素，需要访问A一行和B一列。在使用了分块方法和利用了共享存储器之后，常数因子会有所减少。这里未考虑CPU与GPU的数据交换时间。###算法源代码####向量加法的计算 ```C//系统头文件#include <stdlib.h>#include <stdio.h>#include <string.h>#include <time.h>#include <math.h>//cuda头文件#include <cuda_runtime.h>#include \"device_launch_parameters.h\"//线程块大小（只用一维）#define BLOCK_SIZE 500/***************************************************GPU上的向量加法,每一个线程块(bx,by)内线程(tx,ty)都将执行，所有变量各有一份***************************************************/__global__ void vectorAdd(float*C,float*A,float*B){//块索引 int bx=blockIdx.x;//int by=blockIdx.y;//必为1//线程索引 int tx=threadIdx.x;//int ty=threadIdx.y;//必为1//当前线程块(bx,by)内线程(tx,ty)负责的向量下标 int i=bx*BLOCK_SIZE+tx;//计算 C[i]=A[i]+B[i];}/***************************************************初始化向量为随机数值***************************************************/void randomInit(float*data,unsigned int size){for(unsigned int i=0;i < size;i++)data[i]=rand()/(float)RAND_MAX;}/***************************************************CPU上的串行向量加法***************************************************/void vectorAdd_seq(float*C,const float*A,const float*B,unsigned int size){for(unsigned int i=0;i < size;i++)C[i]=A[i]+B[i];}/***************************************************对比串行和并行计算向量的差异***************************************************/void printDiff(float*data1,float*data2,unsigned int size){unsigned int i,error_count=0;for(i=0;i < size;i++){if(fabs(data1[i]-data2[i])> 1e-6){printf(\"diff(%d)CPU=%lf,GPU=%lf\\n\",i,data1[i],data2[i]);error_count++;}}printf(\"Compare Result:Total Errors=%d\\n\",error_count);}/***************************************************主机端主函数***************************************************/int main(int argc,char**argv){//set seed for rand()srand((unsigned)time(NULL));float*h_A,*h_B,*h_C,*h_C_reference,*d_A,*d_B,*d_C;clock_t t1,t2,t3,t4;double time_gpu,time_cpu;int sizeArray[6]={100000,200000,1000000,2000000,10000000,20000000};for(int k=0;k < 6;k++){int size=sizeArray[k];int mem_size=size*sizeof(float);printf(\"-----Vector size:%d-----\\n\",size);//在主机内存申请A，B，C向量的空间 h_A=(float*)malloc(mem_size);h_B=(float*)malloc(mem_size);h_C=(float*)malloc(mem_size);//在GPU设备申请A,B,C向量的空间 cudaMalloc((void**)&d_A,mem_size);cudaMalloc((void**)&d_B,mem_size);cudaMalloc((void**)&d_C,mem_size);//初始化主机内存的A,B向量 randomInit(h_A,size);randomInit(h_B,size);//拷贝主机内存的A,B的内容到GPU设备的A,B cudaMemcpy(d_A,h_A,mem_size,cudaMemcpyHostToDevice);cudaMemcpy(d_B,h_B,mem_size,cudaMemcpyHostToDevice);//GPU内核函数的维度参数 dim3 dimBlock(BLOCK_SIZE,1);dim3 dimGrid(size/BLOCK_SIZE,1);//执行GPU内核函数 t1=clock();vectorAdd<<<dimGrid,dimBlock>>>(d_C,d_A,d_B);cudaThreadSynchronize();//CPU等待GPU运算结束 t2=clock();time_gpu=(double)(t2-t1)/CLOCKS_PER_SEC;printf(\"GPU Processing time:%lf s\\n\",time_gpu);//从GPU设备复制结果向量C到主机内存的C cudaMemcpy(h_C,d_C,mem_size,cudaMemcpyDeviceToHost);//用CPU串行计算向量C，并比较差异 h_C_reference=(float*)malloc(mem_size);t3=clock();vectorAdd_seq(h_C_reference,h_A,h_B,size);t4=clock();time_cpu=(double)(t4-t3)/CLOCKS_PER_SEC;printf(\"CPU Processing time:%lf s\\n\",time_cpu);printf(\"Speedup:%lf\\n\",time_cpu/time_gpu);printDiff(h_C_reference,h_C,size);//释放主机和设备申请的空间 free(h_A);free(h_B);free(h_C);free(h_C_reference);cudaFree(d_A);cudaFree(d_B);cudaFree(d_C);}system(\"pause\");}```####矩阵分块乘法的计算 ```c//系统头文件#include <stdlib.h>#include <stdio.h>#include <string.h>#include <time.h>#include <math.h>//cuda头文件#include <cuda_runtime.h>#include \"device_launch_parameters.h\"//线程块大小（每一维大小）#define BLOCK_SIZE 16//矩阵规模，为线程块的整数倍#define WA(5*BLOCK_SIZE)//Matrix A width#define HA(8*BLOCK_SIZE)//Matrix A height#define WB(12*BLOCK_SIZE)//Matrix B width#define HB WA//Matrix B height#define WC WB//Matrix C width#define HC HA//Matrix C height//以下代码中x对应width,y对应height/***************************************************设备端：取子矩阵起始地址***************************************************/__device__ float*GetSubMatrixBeginAddr(float*M,int wM,int x,int y){return M+wM*BLOCK_SIZE*y+BLOCK_SIZE*x;}/***************************************************设备端：取子矩阵元素地址***************************************************/__device__ float*GetSubMatrixElementAddr(float*subM,int wSubM,int x,int y){return subM+wSubM*y+x;}/***************************************************GPU上的矩阵分块乘法*每一个线程块(bx,by)内线程(tx,ty)都将执行，所有变量各有一份，除了下面的共享子矩阵为同一线程块(bx,by)内所有线程共有***************************************************/__global__ void matrixMul(float*C,float*A,float*B,int wA,int wB){//共享存储器上的A的子矩阵 __shared__ float subA_shared[BLOCK_SIZE][BLOCK_SIZE];//共享存储器上的B的子矩阵 __shared__ float subB_shared[BLOCK_SIZE][BLOCK_SIZE];//块索引 int bx=blockIdx.x;int by=blockIdx.y;//线程索引 int tx=threadIdx.x;int ty=threadIdx.y;//结果矩阵C的宽度 int wC=wB;//线程块(bx,by)内线程(tx,ty)负责计算的结果矩阵C的值 float CElement=0;//同一线程块内的线程负责同一个C的子矩阵，下面遍历一横A的子矩阵和一竖B的子矩阵 for(int m=0;m < wA/BLOCK_SIZE;m++){//同一线程块的线程共享A/B的一个子矩阵，先从全局存储器拷贝到共享存储器，一个线程拷贝一个元素//获取指向当前矩阵A/B子矩阵的指针Msub float*subA=GetSubMatrixBeginAddr(A,wA,m,by);float*subB=GetSubMatrixBeginAddr(B,wB,bx,m);subA_shared[ty][tx]=*(GetSubMatrixElementAddr(subA,wA,tx,ty));subB_shared[ty][tx]=*(GetSubMatrixElementAddr(subB,wB,tx,ty));__syncthreads();//线程块内同步，在计算之前，确保共享A/B的子矩阵所有的元素都已载入共享存储器中//计算结果矩阵C的子矩阵的一个元素，遍历求和当前A子矩阵的一横和B子矩阵的一竖对应元素的积 for(int k=0;k < BLOCK_SIZE;++k)CElement+=subA_shared[ty][k]*subB_shared[k][tx];__syncthreads();//线程块内同步，确保当前线程块内所有线程都完成了计算，才能开始下一组A/B的子矩阵}//当前线程把负责的C的子矩阵的一个元素结果写回 float*subC=GetSubMatrixBeginAddr(C,wC,bx,by);*(GetSubMatrixElementAddr(subC,wC,tx,ty))=CElement;}/***************************************************初始化矩阵为随机数值***************************************************/void randomInit(float*data,int size){for(int i=0;i < size;++i)data[i]=rand()/(float)RAND_MAX;}/***************************************************CPU上的串行矩阵乘法***************************************************/void matrixMul_seq(float*C,const float*A,const float*B,unsigned int hA,unsigned int wA,unsigned int wB){for(unsigned int i=0;i < hA;++i)for(unsigned int j=0;j < wB;++j){double sum=0;for(unsigned int k=0;k < wA;++k)sum+=A[i*wA+k]*B[k*wB+j];C[i*wB+j]=(float)sum;}}/***************************************************对比串行和并行计算矩阵的差异***************************************************/void printDiff(float*data1,float*data2,int width,int height){int i,j,k,error_count=0;for(j=0;j < height;j++){for(i=0;i < width;i++){k=j*width+i;if(fabs(data1[k]-data2[k])> 1e-4){printf(\"diff(%d,%d)CPU=%4.4f,GPU=%4.4f\\n\",i,j,data1[k],data2[k]);error_count++;}}}printf(\"Compare Result:Total Errors=%d\\n\",error_count);}/***************************************************主机端主函数***************************************************/int main(int argc,char**argv){//set seed for rand()srand((unsigned)time(NULL));//在主机内存申请A，B，C矩阵的空间 unsigned int size_A=WA*HA;unsigned int mem_size_A=sizeof(float)*size_A;float*h_A=(float*)malloc(mem_size_A);unsigned int size_B=WB*HB;unsigned int mem_size_B=sizeof(float)*size_B;float*h_B=(float*)malloc(mem_size_B);unsigned int size_C=WC*HC;unsigned int mem_size_C=sizeof(float)*size_C;float*h_C=(float*)malloc(mem_size_C);//在GPU设备申请A,B,C矩阵的空间 float*d_A;cudaMalloc((void**)&d_A,mem_size_A);float*d_B;cudaMalloc((void**)&d_B,mem_size_B);float*d_C;cudaMalloc((void**)&d_C,mem_size_C);//初始化主机内存的A,B矩阵 randomInit(h_A,size_A);randomInit(h_B,size_B);//拷贝主机内存的A,B的内容到GPU设备的A,B cudaMemcpy(d_A,h_A,mem_size_A,cudaMemcpyHostToDevice);cudaMemcpy(d_B,h_B,mem_size_B,cudaMemcpyHostToDevice);//GPU内核函数的维度参数 dim3 dimBlock(BLOCK_SIZE,BLOCK_SIZE);dim3 dimGrid(WC/BLOCK_SIZE,HC/BLOCK_SIZE);//执行GPU内核函数 clock_t t1=clock();matrixMul<<<dimGrid,dimBlock>>>(d_C,d_A,d_B,WA,WB);cudaThreadSynchronize();//CPU等待GPU运算结束 clock_t t2=clock();double time_gpu=(double)(t2-t1)/CLOCKS_PER_SEC;printf(\"GPU Processing time:%lf s\\n\",time_gpu);//从GPU设备复制结果矩阵C到主机内存的C cudaMemcpy(h_C,d_C,mem_size_C,cudaMemcpyDeviceToHost);//用CPU串行计算矩阵C，并比较差异 float*hC_reference=(float*)malloc(mem_size_C);clock_t t3=clock();matrixMul_seq(hC_reference,h_A,h_B,HA,WA,WB);clock_t t4=clock();double time_cpu=(double)(t4-t3)/CLOCKS_PER_SEC;printf(\"CPU Processing time:%lf s\\n\",time_cpu);printf(\"Speedup:%lf\\n\",time_cpu/time_gpu);printDiff(hC_reference,h_C,WC,HC);//释放主机和设备申请的空间 free(h_A);free(h_B);free(h_C);free(hC_reference);cudaFree(d_A);cudaFree(d_B);cudaFree(d_C);system(\"pause\");}```###结果 登录集群，建立个人文件夹，建立代码文件和任务文件 ![img](lab3/clip_image002.gif)####向量加法的计算 使用vim编辑pbs文件，填写任务相关信息 ![img](lab3/clip_image004.gif)使用vim编辑vec_add.cu文件，将事先写好的代码粘贴进去 ![img](lab3/clip_image006.gif)​ 提交任务，稍等几秒，得到编译结果和运行结果 ![img](lab3/clip_image008.gif)查看运行结果 ![img](lab3/clip_image010.gif)​ 可见不同规模的向量加法得到的加速比不同。在一定范围内，规模越大，加速比越大####矩阵分块乘法的计算 使用vim编辑pbs文件，填写任务相关信息 ![img](lab3/clip_image012.gif)使用vim编辑mat_mul.cu文件，将事先写好的代码粘贴进去 这里预置的矩阵规模为A(5个BLOCK_SIZE宽，8个BLOCK_SIZE高)，B(8个BLOCK_SIZE宽，13个BLOCK_SIZE高)，BLOCK_SIZE=16 ![img](lab3/clip_image014.gif)​ 提交任务，稍等几秒，得到编译结果和运行结果**![img](lab3/clip_image016.gif)**查看运行结果**![img](lab3/clip_image018.gif)**加速比为122.55，加速效果明显 再进行一次实验， 这次矩阵规模为A(15个BLOCK_SIZE宽，18个BLOCK_SIZE高)，B(18个BLOCK_SIZE宽，22个BLOCK_SIZE高)，BLOCK_SIZE=16 ![img](lab3/clip_image020.jpg)加速比为378.25，加速效果更明显 ​ 可见在一定范围内，矩阵规模越大，加速比越大######","tags":["parallel computing"],"categories":[]},{"title":"并行计算上机实验二 MPI实现π值的计算和PSRS排序","url":"/s/p/a3xuo0/","content":"###题目 MPI实现π值的计算和PSRS排序###算法设计####π值的计算#####基本的串行算法 ![http://img.blog.csdn.net/20150416160118625](lab2/clip_image003.jpg)利用公式arctan(1)=π/4以及(arctan(x))'=1/(1+x^2)，在[0,1]上对f(x)=4/(1+x^2)求积分，使用积分的定义离散化近似求解。将[0,1]分成大量的小区间，使用for循环在每个小区间上计算y_i的值，最后求和。#####MPI并行算法 在基本的串行算法上，main函数中开始时用MPI_Init初始化，则所有进程都将执行接下来的代码。用MPI_Comm_size获取总进程数，用MPI_Comm_rank获取当前进程id。将y_i的计算并行化，显式地分配for循环，将紧挨着的p个区间的y_i的值分配给p个进程分别计算（而不是将全部区间直接划分给p个处理器，这样可能导致各线程负载不均衡），换言之，当前进程只计算每连续p个区间中的1个。最后用MPI_Reduce将每个进程计算的局部值归约求和，结果在主进程（0号进程）上。####PSRS排序 给定n个元素的数组`A[0..n-1]`，执行以下步骤(1)均匀划分：将`A[0..n-1]`均匀划分成p段，每个进程pi处理`A[(i*n/p..(i+1)*n/p-1]`(2)局部排序：每个进程pi调用串行排序算法对`A[(i*n/p..(i+1)*n/p-1]`排序(3)选取样本：每个进程pi从自己的有序子数组`A[(i*n/p..(i+1)*n/p-1]`中等间距选取p个样本元素，存放在samples数组中(4)样本排序：用主进程global_samples数组收集（MPI_Gather）各个进程的samples数组，对总共的p2个样本元素进行串行排序(5)选择主元：用主进程从排好序的p2个样本中选取p-1个主元，并广播（MPI_Bcast）给其他pi(6)主元划分：每个进程pi按p-1个主元将自己的有序子数组`A[(i*n/p..(i+1)*n/p-1]`划分成p段（每段长度可能不同），此时，不需要新申请一个二维数组存放p段数据，只需要一个一维数组sizes记录每段的长度和一个一维数组记录每段的起始位置offsets（相对偏移，通过累加前面的段的长度得到）(7)全局交换：每个进程pi将自己的有序子数组中的每段按段号交换到对应id的进程中，可以利用MPI_Alltoallv函数实现全局交换，之前的长度数组sizes和偏移数组作为参数offsets，另外需要三个数组newsizes、newoffsets和newdatas用于接收数据。 MPI_Alltoallv函数定义如下 ``` int MPI_Alltoallv(const void*sendbuf,发送缓冲区的起始地址 const int*sendcounts,数组：每个发送数据的长度 const int*sdispls,数组：每个发送数据相对于发送缓冲区起始地址的位移量 MPI_Datatype sendtype,发送的数据类型 void*recvbuf,接收缓冲区的起始地址 const int*recvcounts,数组：每个接收数据的长度 const int*rdispls， 数组：每个接收数据相对于接收缓冲区起始地址的位移量 MPI_Datatype recvtype,接收的数据类型 MPI_Comm comm)通信域 ``` 该函数实现各个进程向各个进程交换**不定长**的数据 该函数执行效果举例如下，每个数据的长度不定 ``` 交换前 A0 A1 A2 A3 A4 A5--进程0的sizes数组 B0 B1 B2 B3 B4 B5--进程1的sizes数组 C0 C1 C2 C3 C4 C5--进程2的sizes数组 D0 D1 D2 D3 D4 D5--进程3的sizes数组 E0 E1 E2 E3 E4 E5--进程4的sizes数组 F0 F1 F2 F3 F4 F5--进程5的sizes数组 交换后 A0 B0 C0 D0 E0 F0--进程0的newsizes数组 A1 B1 C1 D1 E1 F1--进程1的newsizes数组 A2 B2 C2 D2 E2 F2--进程2的newsizes数组 A3 B3 C3 D3 E3 F3--进程3的newsizes数组 A4 B4 C4 D4 E4 F4--进程4的newsizes数组 A5 B5 C5 D5 E5 F5--进程5的newsizes数组 ```(8)归并排序：每个进程pi对接收到的元素进行归并排序(9)用主进程收集（MPI_Gatherv）各个进程的新数据，写回A，此时，原数组A已有序 MPI_Gatherv函数定义如下 ``` int MPI_Gatherv(void*sendbuf,发送缓冲区的起始地址 int sendcount,发送数据的长度 MPI_Datatype sendtype,发送的数据类型 void*recvbuf,接收缓冲区的起始地址 int*recvcounts,数组：每个接收数据的长度 int*displs,数组：每个接收数据相对于接收缓冲区起始地址的位移量 MPI_Datatype recvtype,接收的数据类型 int root,根进程的id MPI_Comm comm)通信域 ``` 该函数实现各个进程向根进程汇集不定长的数据 <!--more-->###算法分析####π值的计算 设*n*为[0,1]之间划分的区间数 对于串行算法，时间复杂度为*O*(*n*)对于4种并行算法，时间复杂度为*O*(*n*/*p*)*，*其中*p*为处理器数####PSRS排序(参考文献 Hanmao Shi,Jonathan Schaeffer.Parallel Sorting by Regular Sampling.)设*n*为A的元素个数，*p*为处理器数，*w*=*n*/*p*则时间复杂度为各阶段时间复杂度之和 $O(wlogw+wlogp+plogw+p^2 logp^2)$ 若$n >p^3 $,近似为 $O(\\frac{n}{p}logn)$ 另外，算法第六步每个处理器的w个数据根据p – 1个主元划分，每段的长度可能不相等，因此数组低维的长度不等，无法实现确定，但文献中证明了每段的长度最长不超过2w个元素。 > Theorem 1:In phase 3 of PSRS,each processor merges less than 2w elements.###算法源代码####π值的计算#####基本的串行算法 ```C#include <stdio.h> static long num_steps=100000;//越大值越精确 double step;void main(){int i;double x,pi,sum=0.0;step=1.0/(double)num_steps;for(i=1;i <=num_steps;i++){x=(i-0.5)*step;sum=sum+4.0/(1.0+x*x);}pi=step*sum;printf(\"%lf\\n\",pi);}```#####使用并行域并行化的程序 ```c#include \"mpi.h\"#include <stdio.h>#include <math.h> static long num_steps=100000;int main(int argc,char*argv[]){int id,num_processes;double local_pi,pi,local_sum=0.0,x;double step=1.0/(double)num_steps;double t1,t2;MPI_Init(&argc,&argv);MPI_Comm_size(MPI_COMM_WORLD,&num_processes);MPI_Comm_rank(MPI_COMM_WORLD,&id);if(id==0)//主进程 t1=MPI_Wtime();for(int i=id+1;i <=num_steps;i+=num_processes){//各线程计算自己部分的面积local_pi x=step*(i-0.5);local_sum=local_sum+4.0/(1.0+x*x);}local_pi=local_sum*step;MPI_Reduce(&local_pi,&pi,1,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);//归约local_pi到pi if(id==0){t2=MPI_Wtime();printf(\"time:%fs\\n\",t2-t1);printf(\"PI is approximately%.16f\\n\",pi);}MPI_Finalize();return 0;}```#########PSRS排序 ```C#include <stdlib.h>#include <stdio.h>#include \"mpi.h\"#define INF 2147483647/***************************************************合并两个已排好序的子数组A[l:m],A[m+1:r],写回A[l:r]***************************************************/void Merge(int*A,int l,int m,int r){int i,j,k,n1=m-l+1,n2=r-m;int*L=(int*)malloc((n1+1)*sizeof(int));int*R=(int*)malloc((n2+1)*sizeof(int));for(i=0;i < n1;i++)L[i]=A[l+i];for(j=0;j < n2;j++)R[j]=A[m+1+j];L[i]=R[j]=INF;i=j=0;for(k=l;k <=r;k++)if(L[i]<=R[j])A[k]=L[i++];else A[k]=R[j++];free(L);free(R);}/***************************************************对A[l:r]进行归并排序***************************************************/void MergeSort(int*A,int l,int r){if(l < r){int m=(l+r)/2;MergeSort(A,l,m);MergeSort(A,m+1,r);Merge(A,l,m,r);}}/***************************************************对A[0:n-1]进行PSRS排序***************************************************/void PSRS(int*A,int n,int id,int num_processes){//每个进程都会执行这个函数，这里面的变量每个进程都有一份，因此都是局部的（对于当前进程而言） int per;int*samples,*global_samples;//global表示这个变量是主进程会使用的，但事实上每个进程都声明了 int*pivots;int*sizes,*newsizes;int*offsets,*newoffsets;int*newdatas;int newdatassize;int*global_sizes;int*global_offsets;//-------------------------------------------------------------------------------------------------------------------per=n/num_processes;//A的n个元素划分为num_processes段，每个进程处理per个元素 samples=(int*)malloc(num_processes*sizeof(int));//当前进程的采样数组 pivots=(int*)malloc(num_processes*sizeof(int));//num_processes-1 个主元，最后一个设为INF，作为哨兵 if(id==0){//主进程申请全局采样数组 global_samples=(int*)malloc(num_processes*num_processes*sizeof(int));//正则采样数为 num_processes*num_processes}MPI_Barrier(MPI_COMM_WORLD);//设置路障，同步所有进程//-------------------------------------------------------------------------------------------------------------------//（1）均匀划分，当前进程对A中属于自己的部分进行串行归并排序 MergeSort(A,id*per,(id+1)*per-1);//这里没有把A中对应当前进程的数据复制到当前进程，而是直接对A部分排序//（2）正则采样，当前进程选出 num_processes 个样本放在local_sample中 for(int k=0;k < num_processes;k++)samples[k]=A[id*per+k*per/num_processes];//主进程的sample收集各进程的local_sample，共 num_processes*num_processes 个 MPI_Gather(samples,num_processes,MPI_INT,global_samples,num_processes,MPI_INT,0,MPI_COMM_WORLD);//-------------------------------------------------------------------------------------------------------------------//（3）采样排序 （4）选择主元 if(id==0){//主进程 MergeSort(global_samples,0,num_processes*num_processes-1);//对采样的num_processes*num_processes个样本进行排序 for(int k=0;k < num_processes-1;k++)//选出num_processes-1个主元 pivots[k]=global_samples[(k+1)*num_processes];pivots[num_processes-1]=INF;//哨兵}//主进程向各个进程广播，所有进程拥有一样的pivots数组 MPI_Bcast(pivots,num_processes,MPI_INT,0,MPI_COMM_WORLD);MPI_Barrier(MPI_COMM_WORLD);//-------------------------------------------------------------------------------------------------------------------sizes=(int*)calloc(num_processes,sizeof(int));//当前进程的per个元素根据主元划分之后的每段的长度，用calloc分配后自动初始化为0 offsets=(int*)calloc(num_processes,sizeof(int));//当前进程的per个元素根据主元划分之后的每段的起始位置，用calloc分配后自动初始化为0 newsizes=(int*)calloc(num_processes,sizeof(int));//当前进程在进行全局交换之后的每段的长度，用calloc分配后自动初始化为0 newoffsets=(int*)calloc(num_processes,sizeof(int));//当前进程在进行全局交换之后的每段的起始位置，用calloc分配后自动初始化为0//（5）主元划分 for(int k=0,j=id*per;j < id*per+per;j++){//当前进程对自己的per个元素按主元划分为num_processes段，此处不处理数据，只计算每段大小 if(A[j]< pivots[k])//如果之前不用哨兵，最后一段要单独考虑 sizes[k]++;else sizes[++k]++;}//（6）全局交换//多对多全局交换消息，首先每个进程向每个接收者发送接收者对应的【段的大小】 MPI_Alltoall(sizes,1,MPI_INT,newsizes,1,MPI_INT,MPI_COMM_WORLD);//计算原来的段偏移数组，新的段偏移数组，新的数据大小 newdatassize=newsizes[0];for(int k=1;k < num_processes;k++){offsets[k]=offsets[k-1]+sizes[k-1];newoffsets[k]=newoffsets[k-1]+newsizes[k-1];newdatassize+=newsizes[k];}//申请当前进程新的数据空间 newdatas=(int*)malloc(newdatassize*sizeof(int));//当前进程在进行全局交换之后的数据，是由交换后的各段组合而成的//多对多全局交换消息，每个进程向每个接收者发送接收者对应的【段】 MPI_Alltoallv(&(A[id*per]),sizes,offsets,MPI_INT,newdatas,newsizes,newoffsets,MPI_INT,MPI_COMM_WORLD);MPI_Barrier(MPI_COMM_WORLD);//-------------------------------------------------------------------------------------------------------------------//（7）当前进程归并排序自己的新数据 MergeSort(newdatas,0,newdatassize-1);MPI_Barrier(MPI_COMM_WORLD);//（8）主进程收集各个进程的数据，写回A//首先收集各进程新数据的大小 if(id==0)global_sizes=(int*)calloc(num_processes,sizeof(int));MPI_Gather(&newdatassize,1,MPI_INT,global_sizes,1,MPI_INT,0,MPI_COMM_WORLD);//主进程计算即将搜集的各进程数据的起始位置 if(id==0){global_offsets=(int*)calloc(num_processes,sizeof(int));for(int k=1;k < num_processes;k++)global_offsets[k]=global_offsets[k-1]+global_sizes[k-1];}//主进程收集各个进程的数据 MPI_Gatherv(newdatas,newdatassize,MPI_INT,A,global_sizes,global_offsets,MPI_INT,0,MPI_COMM_WORLD);MPI_Barrier(MPI_COMM_WORLD);//-------------------------------------------------------------------------------------------------------------------//销毁动态数组 free(samples);samples=NULL;free(pivots);pivots=NULL;free(sizes);sizes=NULL;free(offsets);offsets=NULL;free(newdatas);newdatas=NULL;free(newsizes);newsizes=NULL;free(newoffsets);newoffsets=NULL;if(id==0){free(global_samples);global_samples=NULL;free(global_sizes);global_sizes=NULL;free(global_offsets);global_offsets=NULL;}}int main(int argc,char*argv[]){int A[27]={15,46,48,93,39,6,72,91,14,36,69,40,89,61,97,12,21,54,53,97,84,58,32,27,33,72,20};double t1,t2;int id,num_processes;MPI_Init(&argc,&argv);MPI_Comm_size(MPI_COMM_WORLD,&num_processes);//获取进程数 MPI_Comm_rank(MPI_COMM_WORLD,&id);//获取当前进程id if(id==0)t1=MPI_Wtime();PSRS(A,27,id,num_processes);if(id==0){t2=MPI_Wtime();printf(\"time:%lfs\\n\",t2-t1);for(int i=0;i < 27;i++)printf(\"%d \",A[i]);printf(\"\\n\");}MPI_Finalize();return 0;}```###结果 ![img](lab2/clip_image002.jpg)![img](lab2/clip_image002-1570631864083.jpg)","tags":["parallel computing"],"categories":[]},{"title":"LeetCode题目改编——只出现一次的数字IV","url":"/s/p/a3bmo0/","content":"###起源 受LeetCode系列题目启发[只出现一次的数字I](https://leetcode-cn.com/problems/single-number/)[只出现一次的数字II](https://leetcode-cn.com/problems/single-number-ii/)[只出现一次的数字III](https://leetcode-cn.com/problems/single-number-iii/)已提交贡献（然而几个月了都是Pending，发到博客来吧~###题目 给定一个正整数数组 `nums`，其中恰好有三个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那三个元素。**示例:**``` 输入:[1,6,2,4,1,3,2,5,6]输出:[3,4,5]```**注意：**1.结果输出的顺序并不重要，对于上面的例子，可以是 3,4,5 的任意排列。 2.你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？###解题 这道题比 “[只出现一次的数字III](https://leetcode-cn.com/problems/single-number-iii/)” 多了一个只出现一个的数字，我们只要找到三个只出现一个的数字中一个，加入数组中，再使用 “[只出现一次的数字III](https://leetcode-cn.com/problems/single-number-iii/)” 寻找两个只出现一次的数字即可 首先记 `LSB(x)=x&(-x)`，表示取`x`的二进制最低的位`1`，其他位均置为`0`，如`LSB(100110b)=000010b `，若`x > 0`，则 `LSB(x)> 0` 设三个只出现一次的正整数为 `a,b,c `,设 `n=a^b^c`（对数组中所有数进行异或可得`n`），由异或的交换律和结合律有 `(n^a)^(n^b)^(n^c)=0` 显然也有 `LSB(n^a)^LSB(n^b)^LSB(n^c)!=0`， 即至少有一个二进制位是`1`，因为任意两个`LSB(·)`异或运算结果为`0`或者有两个二进制位`1` 设 `k`为`LSB(LSB(n^a)^LSB(n^b)^LSB(n^c))` 的位1所在位置，即`k`是 `LSB(n^a)， LSB(n^b)， LSB(n^c)`为三者中最小的最低位1的位置，则 `(n^a)，(n^b)，(n^c)`三者在第 `k` 位上只有3种可能，有3个`1`，2个`1`或1个`1`。 如果有3个`1`或者1个`1`，则第 `k`位异或结果为1，与 `(n^a)^(n^b)^(n^c)=0`矛盾 因此`(n^a)，(n^b)，(n^c)`三者在第 `k` 位上只能有2个`1`，我们现在要寻找的三个数种的第一个数就是第 `k` 位上是`0`的那个数，不妨设为`c` 为此，我们初始化`n=0`遍历数组，依次计算`n^=arr[i]`，得到`n=a^b^c`， 初始化`lsb=0`，再次遍历数组，依次计算`lsb^=LSB(n^arr[i])`，结果得到的 `lsb` 就是`LSB(n^c)` ，因为对于那些出现两次的数x，`LSB(n^x)^LSB(n^x)=0`，而对于`n^a`和`n^b`，它们在第`k`位（也是它们的最低位的`1`）都是`1`，因此，`LSB(n^a)^LSB(n^b)=0` 初始化`c=0`，再次遍历数组，如果`LSB(n^arr[i])==lsb`，计算`c^=arr[i]`，最后结果`c`就是我们要寻找的数，因为`LSB(n^arr[i])==lsb`筛选出的`arr[i]`最低位`1`的位置和`lsb`相同（也就是和`c`相同），这些数的异或结果只会留下`c`，出现两次的数都抵消了###C++代码 ```cpp#include <iostream>#include <vector> using namespace std;int LSB(int num){//取最低位的1，其他位均置为0 return num&(-num);}vector<int> Two(vector<int> arr){//寻找数组中两个只出现一次的数（其他数都出现两次） int a_xor_b=0,a=0,b=0,lsb=0;for(int i=0;i < arr.size();i++)a_xor_b^=arr[i];lsb=LSB(a_xor_b);for(int i=0;i < arr.size();i++)if(arr[i]&lsb)a^=arr[i];b=a_xor_b^a;return vector<int>{a,b};}int OneOfThree(vector<int> arr){//寻找数组中三个只出现一次的数中的一个（其他数都出现两次） int a_xor_b_xor_c=0,c=0,lsb=0;for(int i=0;i < arr.size();i++)a_xor_b_xor_c^=arr[i];for(int i=0;i < arr.size();i++)lsb^=LSB(a_xor_b_xor_c^arr[i]);lsb=LSB(lsb);for(int i=0;i < arr.size();i++)if(LSB(a_xor_b_xor_c^arr[i])==lsb)c^=arr[i];return c;}vector<int> Three(vector<int> arr){//寻找数组中三个只出现一次的数（其他数都出现两次） int c=OneOfThree(arr);arr.push_back(c);vector<int> res=Two(arr);res.push_back(c);return res;}int main(){vector<int> arr={1,6,2,4,1,3,2,5,6};vector<int> res=Three(arr);for(int i=0;i < 3;i++)cout << res[i]<< \" \";return 0;}```###参考 <http://lijinma.com/blog/2014/05/29/amazing-xor/> http://www.360doc.com/content/14/0728/12/14505022_397625773.shtml","tags":["LeetCode"],"categories":[]},{"title":"并行计算上机实验一 OpenMP实现π值的计算和PSRS排序","url":"/s/p/a37xc0/","content":"###题目 OpenMP实现π值的计算和PSRS排序###算法设计####π值的计算#####基本的串行算法 ![http://img.blog.csdn.net/20150416160118625](lab1/clip_image002.jpg)利用公式arctan(1)=π/4以及(arctan(x))'=1/(1+x^2)，在[0,1]上对f(x)=4/(1+x^2)求积分，使用积分的定义离散化近似求解。将[0,1]分成大量的小区间，使用for循环在每个小区间上计算y_i的值，最后求和。#####使用并行域并行化的程序 在基本的串行算法上，用编译制导语句#pragma omp parallel将y_i的计算并行化（注意将使用到的变量私有化，每个线程各自拥有），显式地分配for循环，将紧挨着的p个区间的y_i的值分配给p个处理器分别计算（而不是将全部区间直接划分给p个处理器，这样可能导致各线程负载不均衡）。退出并行域之后，主线程对p个处理器各自的局部和sum进行求和。#####使用共享任务结构并行化的程序 在基本的串行算法上，用编译制导语句#pragma omp parallel将y_i的计算并行化，但是并不显式地分配for循环，直接在for循环前面加上编译制导语句#pragma omp for，系统将for循环自动分配给p个处理器。退出并行域之后，主线程对p个处理器各自的局部和进行求和。#####使用private子句和critical部分并行化的程序 在基本的串行算法上，用编译制导语句#pragma omp parallel将y_i的计算并行化（注意将使用到的变量私有化，每个线程各自拥有），显式地分配for循环，将紧挨着的p个区间的y_i的值分配给p个处理器分别计算（而不是将全部区间直接划分给p个处理器，这样可能导致各线程负载不均衡）。随后，直接在并行域内对上面的结果求和，但必须加上编译制导语句#pragma omp critical，表示指定代码段在同一时刻只能由一个线程进行执行。#####使用并行规约的并行程序 在基本的串行算法上，用编译制导语句#pragma omp parallel for reduction(+:sum)将y_i的计算并行化（注意将使用到的变量私有化，每个线程各自拥有），显式地分配for循环，将紧挨着的p个区间的y_i的值分配给p个处理器分别计算（而不是将全部区间直接划分给p个处理器，这样可能导致各线程负载不均衡）。sum存储了各个处理器的局部和，最后无需主进程显式地对局部和求和，系统将使用指定的算法(+)，对各个局部的sum自动归约。####PSRS排序 给定n个元素的数组`A[0..n-1]`，执行以下步骤(1)均匀划分：将`A[0..n-1]`均匀划分成p段，每个处理器pi处理`A[(i*n/p..(i+1)*n/p-1]`(2)局部排序：每个处理器pi调用串行排序算法对`A[(i*n/p..(i+1)*n/p-1]`排序(3)选取样本：每个处理器pi从自己的有序子数组`A[(i*n/p..(i+1)*n/p-1]`中等间距选取p个样本元素(4)样本排序：用一台处理器对p2个样本元素进行串行排序(5)选择主元：用一台处理器从排好序的样本序列中选取p-1个主元，并播送给其他pi(6)主元划分：每个处理器pi按p-1个主元将自己的有序子数组`A[(i*n/p..(i+1)*n/p-1]`划分成p段，此时，新申请一个数组存放p段数据（每段长度可能不同）(7)全局交换：每个处理器pi将自己的有序子数组中的每段按段号交换到对应id的处理器中。(8)归并排序：每个处理器pi对接收到的元素进行归并排序(9)将各处理器的新数据写回A，此时，原数组A已有序 <!--more-->###算法分析####π值的计算 设*n*为[0,1]之间划分的区间数 对于串行算法，时间复杂度为*O*(*n*)对于4种并行算法，时间复杂度为*O*(*n*/*p*)*，*其中*p*为处理器数####PSRS排序(参考文献 Hanmao Shi,Jonathan Schaeffer.Parallel Sorting by Regular Sampling.)设*n*为A的元素个数，*p*为处理器数，*w*=*n*/*p*则时间复杂度为各阶段时间复杂度之和 $O(wlogw+wlogp+plogw+p^2 logp^2)$ 若$n >p^3 $,近似为 $O(\\frac{n}{p}logn)$ 另外，算法第六步每个处理器的w个数据根据p – 1个主元划分，每段的长度可能不相等，因此数组低维的长度不等，无法实现确定，但文献中证明了每段的长度最长不超过2w个元素。 > Theorem 1:In phase 3 of PSRS,each processor merges less than 2w elements.>###算法源代码####π值的计算#####基本的串行算法 ```C#include <stdio.h> static long num_steps=100000;//越大值越精确 double step;void main(){int i;double x,pi,sum=0.0;step=1.0/(double)num_steps;for(i=1;i <=num_steps;i++){x=(i-0.5)*step;sum=sum+4.0/(1.0+x*x);}pi=step*sum;printf(\"%lf\\n\",pi);}```#####使用并行域并行化的程序 ```c#include <stdio.h>#include <omp.h>#define NUM_THREADS 2 static long num_steps=100000;double step;void main(){int i;double x,pi,sum[NUM_THREADS];step=1.0/(double)num_steps;omp_set_num_threads(NUM_THREADS);//设置2线程#pragma omp parallel private(i)//并行域开始，每个线程(0和1)都会执行该代码{double x;int id;id=omp_get_thread_num();for(i=id,sum[id]=0.0;i < num_steps;i=i+NUM_THREADS){x=(i+0.5)*step;sum[id]+=4.0/(1.0+x*x);}}for(i=0,pi=0.0;i < NUM_THREADS;i++)pi+=sum[i]*step;printf(\"%lf\\n\",pi);}//共2个线程参加计算，其中线程0进行迭代步0,2,4,...线程1进行迭代步1,3,5,....```#####使用共享任务结构并行化的程序 ```c#include <stdio.h>#include <omp.h>#define NUM_THREADS 2 static long num_steps=100000;double step;void main(){int i;double x,pi,sum[NUM_THREADS];step=1.0/(double)num_steps;omp_set_num_threads(NUM_THREADS);//设置2线程#pragma omp parallel//并行域开始，每个线程(0和1)都会执行该代码{double x;int id;id=omp_get_thread_num();sum[id]=0;#pragma omp for//未指定chunk，迭代平均分配给各线程（0和1），连续划分 for(i=0;i < num_steps;i++){x=(i+0.5)*step;sum[id]+=4.0/(1.0+x*x);}}for(i=0,pi=0.0;i < NUM_THREADS;i++)pi+=sum[i]*step;printf(\"%lf\\n\",pi);}//共2个线程参加计算，其中线程0进行迭代步0~49999，线程1进行迭代步50000~99999.```#####使用private子句和critical部分并行化的程序 ```c#include <stdio.h>#include <omp.h>#define NUM_THREADS 2 static long num_steps=100000;double step;void main(){int i;double pi=0.0,sum=0.0,x=0.0;step=1.0/(double)num_steps;omp_set_num_threads(NUM_THREADS);//设置2线程#pragma omp parallel private(x,sum,i)//该子句表示x,sum,i变量对于每个线程是私有的{int id;//不用定义为私有，因为id是在并行域内定义的 id=omp_get_thread_num();for(i=id,sum=0.0;i < num_steps;i=i+NUM_THREADS){x=(i+0.5)*step;sum+=4.0/(1.0+x*x);}#pragma omp critical//指定代码段在同一时刻只能由一个线程进行执行 pi+=sum*step;}printf(\"%lf\\n\",pi);}//共2个线程参加计算，其中线程0进行迭代步0,2,4,...线程1进行迭代步1,3,5,....//当被指定为critical的代码段正在被0线程执行时，1线程的执行也到达该代码段，则它将被阻塞知道0线程退出临界区。 ```#####使用并行规约的并行程序 ```c#include <stdio.h>#include <omp.h>#define NUM_THREADS 2 static long num_steps=100000;double step;void main(){int i;double pi=0.0,sum=0.0,x=0.0;step=1.0/(double)num_steps;omp_set_num_threads(NUM_THREADS);//设置2线程#pragma omp parallel for reduction(+:sum)private(x)//每个线程保留一份私有拷贝sum，x为线程私有，最后对线程中所以sum进行+规约，并更新sum的全局值 for(i=1;i <=num_steps;i++){x=(i-0.5)*step;sum+=4.0/(1.0+x*x);}pi=sum*step;printf(\"%lf\\n\",pi);}//共2个线程参加计算，其中线程0进行迭代步0~49999，线程1进行迭代步50000~99999.```####PSRS排序 ```C#include<stdio.h>#include<string.h>#include<stdlib.h>#include<omp.h>#define INF 2147483647#define NUM_THREADS 3/***************************************************合并两个已排好序的子数组A[l:m],A[m+1:r],写回A[l:r]***************************************************/void Merge(int*A,int l,int m,int r){int i,j,k,n1=m-l+1,n2=r-m;int*L=(int*)malloc((n1+1)*sizeof(int));int*R=(int*)malloc((n2+1)*sizeof(int));for(i=0;i < n1;i++)L[i]=A[l+i];for(j=0;j < n2;j++)R[j]=A[m+1+j];L[i]=R[j]=INF;i=j=0;for(k=l;k <=r;k++)if(L[i]<=R[j])A[k]=L[i++];else A[k]=R[j++];free(L);free(R);}/***************************************************对A[l:r]进行归并排序***************************************************/void MergeSort(int*A,int l,int r){if(l < r){int m=(l+r)/2;MergeSort(A,l,m);MergeSort(A,m+1,r);Merge(A,l,m,r);}}/***************************************************对A[0:n-1]进行PSRS排序***************************************************/void PSRS(int*A,int n){int id;int per=n/NUM_THREADS;//A的n个元素划分为NUM_THREADS段，每个处理器处理per个元素 int sample[NUM_THREADS*NUM_THREADS];//正则采样数为 NUM_THREADS*NUM_THREADS int pivot[NUM_THREADS];//NUM_THREADS-1 个主元，最后一个设为INF，作为哨兵 int*A2[NUM_THREADS][NUM_THREADS]={NULL};//数组，NUM_THREADS处理器把自己的per个元素划分为NUM_THREADS段 int A2len[NUM_THREADS][NUM_THREADS]={0};//上面数组的实际存储长度，每个处理器的每个段的元素个数 omp_set_num_threads(NUM_THREADS);#pragma omp parallel private(id)shared(per,A,A2,n,sample,pivot,A2len)//NUM_THREADS 个处理器同时执行，共用代码{id=omp_get_thread_num();//当前处理器的id//（1）均匀划分 （2）每个处理器进行局部串行归并排序 MergeSort(A,id*per,(id+1)*per-1);//（2）正则采样，每个处理器分别选出 NUM_THREADS 个样本，共 NUM_THREADS*NUM_THREADS 个 for(int k=0;k < NUM_THREADS;k++)sample[id*NUM_THREADS+k]=A[id*per+k*per/NUM_THREADS];#pragma omp barrier//设置路障，同步所有线程//（3）采样排序 （4）选择主元#pragma omp master//主线程执行，其他线程不执行{MergeSort(sample,0,NUM_THREADS*NUM_THREADS-1);//对采样的NUM_THREADS*NUM_THREADS个样本进行排序 for(int k=0;k < NUM_THREADS-1;k++)//选出NUM_THREADS-1个主元 pivot[k]=sample[(k+1)*NUM_THREADS];pivot[NUM_THREADS-1]=INF;//哨兵}#pragma omp barrier//（5）主元划分 for(int k=0;k < NUM_THREADS;k++)A2[id][k]=(int*)malloc(sizeof(int)*per*2);//每个处理器的每个段的数组申请空间，最长不会超过 2*per 个 for(int k=0,j=id*per;j < id*per+per;j++){//每个处理器对自己的per个元素按主元划分为NUM_THREADS段 if(A[j]< pivot[k]){//这里如果不用哨兵，最后一段要单独考虑 A2[id][k][A2len[id][k]++]=A[j];}else{k++;A2[id][k][A2len[id][k]++]=A[j];}}#pragma omp barrier//这里必须有路障，否则部分处理器先划分结束后就开始全局交换，但此时数据还没有准备好//（6）全局交换//每个处理器把自己的per个元素划分成的NUM_THREADS个段“发送”给对应的NUM_THREADS个处理器(除了对应自己的那段)//实际上是每个处理器主动去其他处理器的per里取来自己的那段 for(int k=0;k < NUM_THREADS;k++){if(k !=id){//A2[id][id]是每个处理器对应自己的那段 memcpy(A2[id][id]+A2len[id][id],A2[k][id],sizeof(int)*A2len[k][id]);//从其他处理器那里获取自己的那段直接接在后面 A2len[id][id]+=A2len[k][id];}}//（7）每个处理器归并排序 MergeSort(A2[id][id],0,A2len[id][id]-1);#pragma omp barrier//（8）A2写回A#pragma omp master//主线程执行，其他线程不执行{for(int j=0,k=0;k < NUM_THREADS;k++){memcpy(A+j,A2[k][k],sizeof(int)*A2len[k][k]);j+=A2len[k][k];}}#pragma omp barrier//销毁A2动态申请的空间 for(int k=0;k < NUM_THREADS;k++)free(A2[id][k]);}}int main(){int A[27]={15,46,48,93,39,6,72,91,14,36,69,40,89,61,97,12,21,54,53,97,84,58,32,27,33,72,20};double t1,t2;t1=omp_get_wtime();PSRS(A,27);t2=omp_get_wtime();printf(\"time:%lfs\\n\",t2-t1);for(int i=0;i < 27;i++)printf(\"%d \",A[i]);printf(\"\\n\");return 0;}```###结果 ![img](lab1/clip_image002-1570631920818.jpg)![img](lab1/clip_image002-1570631936971.jpg)","tags":["parallel computing"],"categories":[]},{"title":"C/C++ 位运算总结","url":"/s/p/a32dc0/","content":"##C/C++位运算总结 n位数据的位运算可以视为长度为n的0/1向量运算 与为乘法，异或为模2加法####一、基本的位操作运算符|符号|描述|运算规则||----|----|------------------------------------------------------------||`&`|与|两个位都为1时，结果才为1||`|`|或|两个位都为0时，结果才为0||`^`|异或|两个位相同为0，相异为1，本质为模2加法（无进位加法）||`~`|取反|0变1，1变0||`<<`|左移|各二进位全部左移若干位，高位丢弃，低位补0||`>>`|右移|各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）|注意：-使用位操作算符时尽量添加括号，因为优先级低于一般的算术运算符-只能对整型数据运算 基本等式（无符号数） ```C ~~n==n ``` 基本等式（有符号数） ```C-n==~n+1==~(n-1)-~n==n+1//推论 ~-n==n-1//推论 ``` 分配律 ```c++a&(b|c)==(a&b)|(a&c)a|(b&c)==(a|b)&(a|c)``` 其他 ```c((1 << n)-c)==((1 << n)^c)//```######异或的性质 记 $\\oplus$ 为异或运算，异或运算满足以下性质： 1.$x\\oplus x=0$； 2.$x\\oplus y=y\\oplus x$（交换律）； 3.$(x\\oplus y)\\oplus z=x\\oplus(y\\oplus z)$（结合律）； 4.$x\\oplus y\\oplus y=x$（自反性）； 5.所有$n$位二进制数的异或为`0`（因为每一位`1`在所有数中出现的次数为一半，为偶数次） $$0\\oplus 1\\oplus...\\oplus(2^n-1)=0$$ 更一般地，对于任意$k\\ge 0,n\\ge 0$ $$(k·2^n+0)\\oplus(k·2^n+1)\\oplus\\...\\\\oplus(k·2^n+2^n-1)=0$$ <!--more-->####二、位运算技巧（无关位长）#####乘/除2的幂次（无符号数） ```cpp unsigned int x;x >> n;//等价于x/2^n;x << n;//等价于x*2^n;```#####判断奇偶 ```cpp bool is_odd(int a){return a&1;//等价于a%2==0;}```#####判断是否为$2^n$ ```cpp bool is_power_of_2(int a){return !(a&(a-1));}```#####交换两数 ```cpp void swap(int&a,int&b){//不使用第3个变量，a和b不能引用同一个变量 a^=b;//a=old_a^old_b b^=a;//b=old_b^(old_a^old_b)=old_a a^=b;//a=(old_a^old_b)^old_a=old_b}```#####是否同号 ```cpp bool is_same_sign(int a,int b){//a!=0 且 b!=0 return(a^b)>=0;}```#####置二进制第 n 位为 1 ```cpp int set_nth_bit_to_1(int a){a=a|(1 << n);}```#####置二进制第 n 位为 0 ```cpp int set_nth_bit_to_0(int a){a=a&~(1 << n);}```#####将二进制第 n 位取反 ```cpp int reverse_nth_bit(int a){a=a^(1 << n);}```#####取二进制最低一位1 ```cpp int get_low_1(int a){return a&(-a);//-a=~a+1=~(a-1),eg:a=01010100=> 00000100}```#####取二进制最低一位0 ```cpp int get_low_0(int a){return ~a&(a+1);//eg:a=01010101=> 00000010}```#####置二进制最低一位1为0 ```cpp int set_low_1_to_0(int a){a=a&(a-1);//eg:a=01010100=> 01010000}```#####置二进制最低一位0为1 ```cpp int set_low_0_to_1(int a){a=a|(a+1);//eg:a=01010101=> 01010111}```#####置二进制低位连续的0为1 ```cpp int set_low_1_to_0(int a){a=a|(a-1);//eg:a=01010100=> 01010111}```#####向上对齐为$2^n$的倍数 ```c++unsigned int round_up_to_power_of_2(unsigned int x,unsigned int n){//align_to_ return(x+(1 << n)-1)&~((1 << n)-1)}```####二、位运算技巧（依赖位长）#####获取int的位长 ```c++sizeof(int)*CHAR_BIT;//CHAR_BIT=8 in <climits> ``` 下面默认int为32位的情况#####获得int的最大值 ```cpp int get_int_max(){return((unsigned)1 << 31)-1;//2147483647}```#####获得int的最小值 ```cpp int get_int_min(){return((unsigned)1 << 31);//-2147483648}```#####取符号 当`a>0`时候返回`1`，`a<0`时返回`-1`，`a=0`时返回`0` 方法1 ```cpp int sign(int a){return !!a-(((unsigned)a >> 31)<< 1);}``` 方法2 ```objectivec int sign(int a){return-(int)((unsigned int)((int)a)>> 31);}```#####取绝对值 ```cpp int abs1(int a){return(a >> 31)==0?a:(~a+1);}/*n>>31 取得n的符号，若n为正数，n>>31等于0，若n为负数，n>>31等于-1 若n为正数 n^0=0,数不变，若n为负数有n^-1 需要计算n和-1的补码，然后进行异或运算， 结果n变号并且为n的绝对值减1，再减去-1就是绝对值*/``` 若右移是算术右移，也可写为 ```cpp int abs2(int a){int s=a >> 31;//0 或-1 return(a^s)-s;//s=0,a^0-0=a,s=1,a}```#####取最大值 方法1 ```cpp int max(int a,int b){return b&((a-b)>> 31)|a&(~(a-b)>> 31);/*如果a>=b,(a-b)>>31为0，否则为-1*/}``` 方法2 ```cpp int max(int x,int y){return x^((x^y)&-(x < y));/*如果x<y,x<y返回1，否则返回0，与0做与运算结果为0，与-1做与运算结果不变*/}```#####取最小值 方法1 ```cpp int min(int a,int b){return a&((a-b)>> 31)|b&(~(a-b)>> 31);/*如果a>=b,(a-b)>>31为0，否则为-1*/}``` 方法2 ```cpp int min(int x,int y){return y^((x^y)&-(x < y));/*如果x<y,x<y返回1，否则返回0，与0做与运算结果为0，与-1做与运算结果不变*/}```#####高16位与低16位交换 ```cpp unsigned int exchange_high_low_16(unsigned int a){a=(a >> 16)|(a << 16);}```#####取二进制最高一位1 ```cpp int get_high_1(unsigned int a){//注意是无符号数 a=a|(a >> 1);a=a|(a >> 2);a=a|(a >> 4);a=a|(a >> 8);a=a|(a >> 16);return(a+1)>> 1;//eg:a=01010101=> 01000000}```#####取二进制中1的个数 内置函数`__builtin_popcount`实现相同功能 swar算法？ ```cpp int count_1(unsigned int a){a=(a&0x55555555)+((a >> 1)&0x55555555);a=(a&0x33333333)+((a >> 2)&0x33333333);a=(a&0x0F0F0F0F)+((a >> 4)&0x0F0F0F0F);a=(a&0x00FF00FF)+((a >> 8)&0x00FF00FF);a=(a&0x0000FFFF)+((a >> 16)&0x0000FFFF);return a}```#####取二进制中前导0的个数 内置函数`__builtin_clz`实现相同功能 ```cpp int count_leader_0(unsigned int a){if(a==0)return 32;int n=1;if((a >> 16)==0){n+=16;a=a << 16;}if((a >> 24)==0){n+=8;a=a << 8;}if((a >> 28)==0){n+=4;a=a << 4;}if((a >> 30)==0){n+=2;a=a << 2;}if((a >> 31)==0){n+=1;}//或者 n-=(a >> 31);return n;}```#####取二进制中末尾0的个数 内置函数`__builtin_ctz`实现相同功能 ```cpp int count_tail_0(unsigned int a){if(a==0)return 32;int n=1;if((a << 16)==0){n+=16;a=a >> 16;}if((a << 24)==0){n+=8;a=a >> 8;}if((a << 28)==0){n+=4;a=a >> 4;}if((a << 30)==0){n+=2;a=a >> 2;}if((a << 31)==0){n+=1;}//或者 n-=(a << 31);return n;}```#####取二进制最低一位1的位数 ```cpp int Lsb32(unsigned int a){//LSB=Least Significant Bit int n=31;if(a&0x0000ffff){n-=16;a&=0x0000ffff;}if(a&0x00ff00ff){n-=8;a&=0x00ff00ff;}if(a&0x0f0f0f0f){n-=4;a&=0x0f0f0f0f;}if(a&0x33333333){n-=2;a&=0x33333333;}if(a&0x55555555)n-=1;return n;}```#####取二进制最高一位1的位数 ```cpp int Msb32(unsigned int a){//MSB=Most Significant Bit int n=0;if(a&0xffff0000){n+=16;a&=0xffff0000;}if(a&0xff00ff00){n+=8;a&=0xff00ff00;}if(a&0xf0f0f0f0){n+=4;a&=0xf0f0f0f0;}if(a&0xcccccccc){n+=2;a&=0xcccccccc;}if(a&0xaaaaaaaa)n+=1;return n;}```#####裁剪为0(小于0则返回0)```C int clamp_to_0(int x){return((-x)>> 31)&x;//利用带符号的右移}```#####裁剪为$2^n-1$(大于$2^n-1$则返回$2^n-1$)```C int clamp_to_power_of_2(int x,unsigned int n){return((((1 << n)-1-x)>> 31)|x)&((1 << n)-1);}```#####下一个大于x的$2^n$ ```C unsigned int next_power_of_2(unsigned int x){--x;x|=x >> 1;x|=x >> 2;x|=x >> 4;x|=x >> 8;x|=x >> 16;return++x;}```#########三、位运算实现基本数值运算#####实现加法 本质上实现了加法器，可以使用串行加法或并行加法######一位全加器 和：$S_i=A_i\\oplus B_i\\oplus C_{i-1}$ 进位：$C_i=A_iB_i+(A_i\\oplus B_i)C_i$ 这里的乘法就是按位与，加法就是按位或，$\\oplus$就是按位异或######串行加法 可以按上面的全加器一位一位计算结果######并行加法 一种实现是超前进位，所有进位可直接由$C_0$计算得到 $G_i=A_i B_i$ $P_i=A_i\\oplus B_i$ $C_i=G_i+P_i C_{i-1}=...$ 但在程序中不像电路可以直接相连，也只能依次计算$C_i$ ```cpp int add(int a,int b){int g=a&b;int p=a^b;int carry=0;//超前进位，计算出所有位上的进位（已考虑更低位进位结果） for(int i=0;i < 32;i++){carry|=(g|(p&(carry << 1)))&(1 << i);}return a^b^(carry << 1);//最后可以直接进行无进位加法}```######其他方法 下面采用了一次计算所有位的`和`与`进位`，然后循环解决子问题（`和`加上`进位`） ```cpp int add(int a,int b){int carry,add;do{add=a^b;//无进位加法 carry=(a&b)<< 1;//计算出所有位上的进位（未考虑更低位进位的结果）//下次计算：无进位加法的结果+所有进位，每次循环，需要进位的最低位都会提高，直到没有需要进位的位，carry=0 a=add;b=carry;}while(carry);return add;}```#####实现减法 负数在计算机中以补码表示，加减法都可以由加法器计算，减去一个数等价于加上相反数 ```cpp int subtract(int a,int b){return add(a,add(~b,1));//如果允许使用负号，直接取add(a,-b)}```#####实现乘法 乘法可以通过系列移位和加法完成。最后一个1可通过`b&~(b-1)`取得，可通过`b&(b-1)`去掉 C语言写法， ```cpp int multiply(int a,int b){int neg=(b < 0);if(neg)b=-b;int sum=0;while(b > 0){int last_bit=Lsb32(b);//调用之前的Lsb32函数，最低一位1的位数 sum+=(a << last_bit);b&=b-1;//置最低一位1为0}return neg?-sum:sum;}``` C++写法：可提前计算一个map ```cpp int multiply(int a,int b){bool neg=(b < 0);if(neg)b=-b;int sum=0;map<int,int=\"\"> bit_map;for(int i=0;i < 32;i++)bit_map.insert(pair<int,int=\"\">(1 << i,i));while(b > 0){int last_bit=bit_map[b&~(b-1)];//最低一位1的位数 sum+=(a << last_bit);b&=b-1;//置最低一位1为0}return neg?-sum:sum;}```#####实现除法 ```cpp int divide(int a,int b){//b==0,a==INT_MIN,b==INT_MIN的情况没有考虑 bool neg=(a^b)< 0;//(a > 0)^(b > 0);if(a < 0)a=-a;if(b < 0)b=-b;if(a < b)return 0;//每次将b移位至与a位数相同，需要计算b最多需要移动几位//有几种方法，右移被除数或左移除数，但是根据比较大小来判断位数是否相同容易出问题，特别是被除数是31位的时候//下面采用同时右移，计算位数差，不会发生溢出后比较的问题 int m=1,n=1;while((dividend >> m)> 0)m++;while((divisor >> n)> 0)n++;int q=0;for(int i=m-n;i >=0;i--){if((b << i)> a)continue;q|=(1 << i);a-=(b << i);}return neg?-q:q;}```#####格雷码 `n`位格雷码：`n`位二进制码的一个排列，满足任意两个相邻的代码（包括首尾）只有一位二进制位不同######递归生成方法 `n`位格雷码的集合=前缀`0`加 `n-1`位格雷码集合（顺序）+前缀`1`加` n-1`位格雷码集合（逆序）######异或生成方法 `n`位，二进制码=>格雷码 $G_i=B_i\\oplus B_{i+1}$，格雷码=>二进制码$B_i=G_i\\oplus B_{i+1}$，$i=[0,n-1]$，$B_n=0$ 这种方法使用**每位与其后（高）一位进行异或（比较差异）**（代码实现就是二进制码自身与自身右移一位异或） 为什么这种方法映射后符合任意两个相邻的代码只有一位二进制位不同？ 我们首先观察相邻两个二进制码的位变化情况，可以容易地发现`+1`相当于 从末尾开始直到第1个`0`（设为第`k`位）的所有位取反 `x..xx011..11`=> `x..xx100..00`；特别地，最低位就是`0`时，则`x..xx0`=>`x..xx1`；仅最高位是`0`时，则`011..11`=> `100..00` 这样相邻二进制码的变化都发生在末尾的连续一部分 因此**前后位异或的结果**的变化的位只出现在二进制码**变与不变的交界处**，只有一位（第`k`位）发生了变化 （特别地，对于最高位，与`0`异或后不变（格雷码最高位与二进制码最高位相同），则最高位异或结果发生变化仅在原二进制码最高位变化时`011..11`=> `100..00`，此时也只有一位（最高位，第`k=n-1`位）发生了变化） 为什么是一一映射 $G_i=B_i\\oplus B_{i+1}=$ ```cpp vector<int> grayCode(int n){int nn=1 << n;vector<int> res(nn);for(int i=0;i < nn;i++){res[i]=i^(i >> 1);}return res;}```####三、二进制位表示作为集合压缩数据 可以用 $N$位二进制整数$v=b_{N-1}...b_0$**编码**编号为$[0,..,N-1]$的$N$个对象 的**任何子集**$A$，其中$b_i=1$当且仅当$i\\in A$ （换句话说，二进制整数的每位表示一个对象是否在集合中） 则在$v\\in[0,2^N-1]$，每个整数$v$表示一个子集 （换句话说，二进制整数的位1的分布对应对象在集合中的情况）######遍历子集 由二进制整数表示的集合，可以方便地遍历所有子集，依次获取$v\\in[0,2^N-1]$的位分布情况即可######遍历大小为k的子集 相当于枚举所有包含$k$个$1$的$N$位二进制数，关键是如何从一个大小为$k$子集计算得到下一个（对应二进制数更大） ```c++int state=(1 << k)-1;//初始时k个1都在末尾：state=00001111 while(state < 1 << n){//有效位数小于等于n位：state=01100110 < 100000000 int low_bit=state&-state;//最低位1：low_bit=000000 1 0 int added=state+low_bit;//移除最低位连续多个1，之前的0变1：0110 011 0-> 0110 100 0 int low_multi_bits=state&~added;//仅保留上一次操作使得state发生位翻转的部分即state最低连续多个1的区间：z=0000 011 0 low_multi_bits=(low_multi_bits/low_bit)>> 1;//除法使得该区间连续多个1移至末尾，右移一位相当于删除一个1：z=0000000 1 state=added|low_multi_bits;//合并}//相当于每次把最低连续多个1的第一个1前移一位，剩余1全部移至末尾 ```######集合操作 由二进制整数表示的集合，可以方便地进行集合运算 C/C++一般实现 ```C typedef unsigned long long set;//添加 set add(set s,int i){s|=(1 << i);return s;}//删除 set remove(set s,int i){s&=~(1 << i);return s;}//在集合内 int in(set s,int i){return s&(1 << i);//或者(s >> i)&1}//并集 set union_(set s1,set s2){return s1|s2;}//交集 set intersect(set s1,set s2){return s1&s2;}//差集,s1-s2 set except(set s1,set s2){return s1&~s2;}``` 对于C++，也可以使用STL提供的bitset类 ```c++//初始化 std::bitset<4> foo;//foo:0000 std::bitset<4> a(9);//用整数初始化，a:0000000000001001 std::bitset<4> b(std::string(\"0011\"));//用字符串初始化，不够位数前面补0，b:0000000000000011//位的获取和赋值，相当于加入或删除元素，或者判断元素是否在集合中 foo[1]=1;//foo:0010 foo[2]=foo[1];//foo:0110 foo.set();//foo:1111 foo.set(2,0);//foo:1011 foo.set(2);//foo:1111 foo.reset(1);//foo:1101 foo.reset();//foo:0000 foo.flip(2);//foo:0100 foo.flip();//foo:1011//位运算对应集合操作 a&b;//0010,交集 a|b;//0111,并集 a^b;//0101,差集 a==b;//false(0110==0011)a !=b;//true(0110!=0011)//其他位运算，不对应集合操作 ~b;//1100(NOT)b << 1;//0110(SHL)b >> 1;//0001(SHR)//另外，一些统计和判断函数 foo.count();//Count bits set foo.size();//Return size foo.test();//Return bit value foo.any();//Test if any bit is set foo.none();//Test if no bit is set foo.all();//Test if all bits are set ```####四、参考 <http://www.cplusplus.com/reference/bitset/bitset/> <http://graphics.stanford.edu/~seander/bithacks.html#OperationCounting> <https://blog.whezh.com/bit-hacks/> <http://www.matrix67.com/blog/archives/263> <https://www.clarkok.com/blog/2015/06/13/%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9C%80%E9%AB%98%E4%BD%8D%E7%9A%84%E4%B8%80/> <https://blog.csdn.net/zmazon/article/details/8262185> <https://www.zhihu.com/question/38206659> <https://blog.csdn.net/MoreWindows/article/details/7354571> <http://lijinma.com/blog/2014/05/29/amazing-xor/> https://www.cnblogs.com/JihuiPeng/p/13666678.html","tags":["LeetCode","C/C++"],"categories":[]},{"title":"关于博客","url":"/s/p/a0qrhr/","content":"基于Hexo搭建的静态网页博客，记录写过的文档，大部分是一些课程作业/实验/报告。 使用的主题[hexo-theme-serendipity](https://github.com/Lyncien/hexo-theme-serendipity)和[hexo-theme-notebook](http://github.com/Lyncien/hexo-theme-notebook)是博主学习 JavaScript 和 CSS 时作为练手写的，目前代码比较混乱，待有时间整理后开源-由于博主对透明背景的元素有很大的执念，且前者是学习CSS初期的作品，所以风格略显花里胡哨不够稳重-后者参考了一些笔记本风格的布局以及github的配色，走极简路线","tags":[],"categories":["top"]},{"title":"并行计算初探","url":"/s/p/9ztpc0/","content":"今天是并行计算的第一节课，在介绍完重要性和历史后，老师提了一个问题，作为我们了解并行计算的开始 >如何并行地尽快求解$n$个元素的最大值或排序？ 老师讲解了求最大值的方法，我觉得挺有趣的，在此做个记录####朴素的串行算法 遍历即可，时间复杂度$O(n)$，需要一个处理器####一般的并行算法 类似淘汰赛的方式，每两个数用一个处理器进行比较，选出较大的数，在所有选出的数中重复该操作 时间复杂度$O(logn)$，需要处理器个数$O(n/logn)$####不计代价的并行算法 对于$n$个数的数组$A$，使用$n^2$个处理器：-第1步， 每个处理器$p_{ij},i\\in[0,n-1],j\\in[0,n-1]$，比较第$i$和第$j$个数的大小，得到结果方阵$B$ $$ B_{ij}=\\begin{align}1&&if\\A_i\\ge A_j\\\\0&&if\\A_i\\lt A_j\\\\\\end{align}\\， i\\in[0,n-1]，j\\in[0,n-1]$$-第2步， 再使用一个列向量$M$，处理器$p_{i1},i\\in[0,n-1]$初始化每个分量为$1$-第3步， 如果$B_{ij}=0，i\\in[0,n-1]，j\\in[0,n-1]$ ，处理器$p_{ij}$置$M_i=0$ （此处可能有写冲突，但不影响结果）-第4步，处理器$p_{i1}$对$M$的对应分量$M_i$进行检测。如此，只有最大的那个数对应$B$的行全为$1$，即对应$M$的分量为$1$ 时间复杂度为$O(1)$ 伪代码如下 ``` begin for 1 ≤ i,j ≤ p par-do//工作量O(p2);时间O(1),因为允许同时读 if A[i]≥ A[j]then B[i,j]=1 else B[i,j]=0 end if end for for 1 ≤ i ≤ p par-do//工作量O(p2);时间O(1),因为允许同时写 M[i]=B[i,1]∧ B[i,2]∧ … ∧ B[i,p]end for end ``` 举例如下：|A|||||:--:|:--:|:--:|:--:||3|5|8|4||B|||||:--:|:--:|:--:|:--:||1|0|0|0||1|1|0|1||1|1|1|1||1|0|0|1||M||:--:||0||0||1||0|最大数为$A_2=8$---####更新 布置了作业 > 改写求最大值问题的并行算法，要求不使用数组M。 很简单，不使用$M$数组，就直接在$B$上修改 第3步，处理器$p_{ij}$置$M_i=0$ ，修改为置$B_{i0}=0$ 第4步，处理器$p_{i1}$对$M_i$进行检测，修改为对$B_{i0}$进行检测","tags":["PC"],"categories":[]},{"title":"编译原理课程实验汇报","url":"/s/p/9xthc0/","content":"<div style=\"text-align:center;\"><font size=\"6\" color=\"blue\">编译原理课程实验汇报</font></div>##第一部分：小组合作篇####1.实验内容 在给定框架下，完成一个PL0语言的简单编译器-预备实验-安装Linux系统-安装GCC/Git/CMake-学习使用git命令合作编写代码-Lab1-熟悉PL0语言词法-实现语法分析部分，对输入的文件实现Token流输出-Lab2-熟悉PL0语言的语法图-实现语法分析部分-使用递归下降的方式-产生语法树-部分错误的检测-Lab3-更完整的错误检测与处理-对PL0语言进行拓展-设计并绘制新的语法图-Lab4-完善Lab3添加的功能-实现生成中间代码（基于特定模型的虚拟机）####2.总体设计和实现功能-根据助教所给的框架，主要包括以下几部分-common部分定义了编译器相关的数据结构和全局变量-err部分定义了错误了类型对应的提示信息-lex部分实现词法分析，输入文件字符流，构建一个状态机进行分析，输出Token流-syntax部分实现语法分析和代码生成。调用lex，逐个读取Token，进行递归下降的语法分析，用语法制导的方式生成中间代码-test.c-使用以上几部分构建编译器-前期用于测试-最后用于生成一个PL0编译器，调用时两个参数分别为输入的PL0源代码文件和输出的中间代码文件，该中间代码可在助教提供的PL0虚拟机上运行-最后在助教的虚拟机上运行得分为124 <!--more-->####3.小组成员之间的合作形式-每次实验我先完成了一大部分-在我的万般催促下，在每周日下午会面讨论，我和组长继续完善代码-DDL前一天由我收尾####4.对小组合作效果进行评价-合作效果其实不大-组长忙于其他课程，不过与我讨论很多；另一位同学就划水了...-_--大部分代码都是由我完成##第二部分：个人任务篇####1.我的主要任务-词法的**全部**实现-语法的**大部分**实现（除了错误处理的细节）-生成代码部分的**几乎全部**（除了call的一部分代码）-绘制新的语法图####2.每一个任务的完成-**词法部分**-`PL0Lex_get_token`函数每次被调用时，顺序读入文件中的字符，直到得到一个token或着发现语法错误-不进行复杂的判断，而是预先构造状态转换表，实现了一个有限自动机-包括非接受状态集和接受状态集-一开始进入`START`状态，然后进入一个while循环，每次读入一个字符后根据状态转换表进行转换-若读取的字符类型为`ILLEGAL`，直接返回错误类型。-如果进入了接受状态则返回token及其类型，长度，行号，位置-如果进入非接受状态，则循环继续，但要注意对数字和标识符以及长度进行记录，以便后续返回-如果读取到数字，则进入`IN_NUM`状态，继续读到数字则保持该状态，读到其他类型字符则进入`NUM_AC`状态。-如果读取到字母，则进入`IN_ID`状态，继续读到数字，字母和下划线则保持该状态，读到其他类型字符则进入`ID_AC`状态。-对于长度为2的symbol-对于各比较运算符`<=`和`>=`，读到第一个字母时，进入一个选择状态，根据下一个字符是否为`=`来进入相应接受状态，注意是否回退一个字符。-对于`!=`和`:=`，读取第一个字符时，分别进入选择状态，如果下一个字符是`=`，则接受，否则，第一个字符是非法字符，报错。-对于剩下各个长度为1的symbol，读到该字符就进入对应symbol的接受状态-对于注释，读取到`/`，进入一个选择状态，如果下一个字符是`*`则进入注释状态，否则接受`/`。退出注释状态同理。-如果当前的状态是`IN_LINECOMMENTS`则忽略一切字符直到读取到换行符`\\n`-如果当前的状态是`IN_BLOCKCOMMENTS`则忽略一切字符直到读取到`*/`-关于是否回退一个字符，预先设置一个数组来查询。-关于保留字，不在状态表中体现，进入`ID_AC`后取得一个字符串，此时才与保留字数组进行比较，如果不属于其中任何一个，则认为是标识符。-关于状态转换表-二维表，实现上面描述的自动机的功能，给定当前状态和输入字符，得到下一个状态-为了使状态表不会太大，对字符进行分类，改为根据当前状态和当前输入的字符**类型**进行转换-数字类型-字母类型-分隔符类型-长度为1的symbol字符每种对应一个类型-长度为2的symbol中出现的额外字符`!`和`:`也作为两种类型-其他字符均视为非法字符类型。-字符类型定义 ```C typedef enum _tCharType{LETTER,/*A-Za-z_*/DIGIT,/*0-9*/SPACE,/**/TAB,/*\\t*/NEWLINE,/*\\n*/PLUS,/*+*/MINUS,/*-*/TIMES,/***/SLASH,/*/*/EQU,/*=*/LES,/*<*/GTR,/*>*/LPAREN,/*(*/RPAREN,/*)*/COMMA,/*,*/SEMICOLON,/*;*/PERIOD,/*.*/COLON,/*:*/EXCLAMA,/*!*/AND,/*&*/OR,/*|*/ILLEGAL/*other*/}CharType;```-状态定义 ```c typedef enum _tState{START,SLASH_SEL,LES_SEL,GTR_SEL,IN_NUM,IN_ID,IN_LINECOMMENTS,IN_BLOCKCOMMENTS,TO_END_BLOCKCOMMENTS,COLON_SEL,EXCLAMA_SEL,AND_SEL,OR_SEL,//以上是中间状态（非接受） PLUS_AC,MINUS_AC,TIMES_AC,SLASH_AC,EQU_AC,NEQ_AC,LES_AC,LEQ_AC,GTR_AC,GEQ_AC,LPAREN_AC,RPAREN_AC,COMMA_AC,SEMICOLON_AC,PERIOD_AC,BECOMES_AC,NOT_AC,AND_AC,OR_AC,NUM_AC,ID_AC,//以上是接受状态 ERROR1,//\":\" expect \"=\" ERROR2,//expect \"&&\" but find \"&\" ERROR3//expect \"||\" but find \"|\"}State;```-**语法部分**-使用递归下降的方式-实现拓展语法-增加逻辑运算符`&&` `||` ` ! `-将PL/0语言中的“条件”概念一般化(表达式值非零即为“真”)-短路计算-加入`return`语句-增加`else` `elif`-增加`do` ` while `-增加参数传递-在语法分析中引入负数-语法图如下-![1547603448952](lab_final/1547603448952.png)-![1547603474286](lab_final/1547603474286.png)-![1547603515703](lab_final/1547603515703.png)-![1547603534249](lab_final/1547603534249.png)-根据语法图实现上述非终结符对应的函数-`program`-`program_block`-`var_declaration`-`const_declaration`-`statement`-`or_expression`-`and_expression`-`relation_expression`-`arithmetic_expression`-`term`-`factor`-其他函数-`gettoken`：调用词法分析器，获取一个Token-`match`：比较当前Token与预期的(通过参数传入)是否一致-`table_append`：将一个标识符加入全局表中-`table_append2`：将一个标识符(参数)加入另一个全局表中-`intable`：查找一个标识符在上面两个表中的下标，包括变量/常量/过程名/参数名-错误检测恢复的实现-发现当前Token不是预期的时候，即跳过后面的若干个Token，直到下一个可以正确地跟随当前正在分析的句子结构的符号为止。-对于上面的每个函数（对应语法图的每一个分析过程），调用时提供一个显式参数（一个集合），它指明当前活动结点的可能的后继符号集合，这个集合由上层的函数计算。-后继符号集合计算-在最上层先用一些明显的关键符号给它赋初值-随着分析的层次深入，逐步补充别的合法符号-在`statement`和`factor`的开始和结束时进行检测（调用check函数）-因为这两个函数出现大量分支，需要对开始符号进行检测。-其他层次的函数最终都会通过层层次调用在这两个函数里发现错误。-`check` 函数实现-有三个参数：-允许的下一个符号集合S1-另加的停止符号集合S2，有些符号的出现，虽然无疑是错的，但绝不应被忽略而跳过-应该报的错误信息-如果当前Token不在集合S1中，即报错，此时合并S1和S2为S，继续读取Token，直到找到一个Token在S中-这个函数可使分析程序不会**盲目地**跳过后面的符号-**生成代码部分**-全局数组`codes`，存储全部代码-每条代码有两个参数，第一个参数是指令名称，第二个参数用于`PUT`的常数或者`JMP`的目标地址，其他指令的第二个参数为NONE（预先定义的一个值）-```c typedef struct _code{char ins[4];int para;}code;```-`gen`函数，用于每次生成一条代码-PL0虚拟机包括3部分，codeheap/stack/memory-这里，stack只作为运算使用，当前运算总是对stack顶端的一个或两个值进行操作(虚拟机指令决定了这个特性)-memory被划分为两部分，从低地址端memory[1]开始增长作为模拟的运行栈(runstack)，从高地址端memory[1023]开始递减作为寄存器 ```--------------men[0]|null|runstack|..|..<--runstack's top(REG_SP)||reg4//REG_SP|reg3//REG_BP|reg2//REG_BX|reg1//REG_AX--------------men[1023]a record in runstack(running)--------------low address|return value|return address(in codeheap)|parameters|old base <---base(REG_BP)|local id(var/const/procedure)--------------high address <---top(REG_SP)```-用虚拟机的指令以及memory模拟一个运行栈和寄存器组，实现以下函数-`gen_savereg(REG regid)`函数，将stack栈顶值保存到上面的某个寄存器-`gen_loadreg(REG regid)`函数，将上面的某个寄存器的值读取到stack栈顶-`gen_runstack_push`，包括3个函数，向运行栈中压入一个值，这个值可以是立即数/来自寄存器/来自stack栈顶-`gen_runstack_pop`，包括2个函数，从运行栈取出栈顶值，这个值可以被扔掉/保存到寄存器-`gen_exchangestacktop`，交换stack栈顶的两个值-先存到”寄存器“-再反序压入-`gen_int2bool`，将stack栈顶值转为bool值-非0值即为1-实现：先`PUT 0 `，再`EQ`，最后`NOT`-`gen_id_addr(int index)`，根据标识符表/参数表的下标，动态生成某个变量/常量/参数在运行栈中相对基址的偏移量，然后加上基址，得到在memory中的地址，将这个地址放到stack栈顶-基址是随程序运行栈的变化而变化的-偏移量在生成代码时就算好了，根据语法分析时加入变量表和参数表的下标-运行栈中当前基址之下是参数（偏移量为负）-运行栈中当前基址之上是局部变量（偏移量为正）-主要功能与拓展功能的实现-增加逻辑运算符 `&&` `||` ` ! `-上面语法部分把`expression`和`condition`拓展为4个层次`or_expression`，`and_expression`，`relation_expression`，`arithmetic_expression`-将PL/0语言中的“条件”概念一般化(表达式值非零即为“真”)-`arithmetic_expression`计算算术表达式得到的值向上面3层传递时-如果上面3层只有都一个运算数，这个值被保留，即作为最终or_expression的值-如果某层有多个参数，则转换为bool值(0/1)再继续运算，调用`gen_int2bool`实现-短路计算-`or_expression`第一个数为1时，生成`JMP`指令（参数先空着），跳过之后多个值的计算，这里使用回填技术，在生成后面的计算代码后，再将代码所在的行填到这里JMP的参数-`and_expression`第一个数为0时，同理-加入`return`语句，增加参数传递-`factor`和`statement`中分析`call`时，利用`gen_runstack_push`函数完成-生成*\"将返回地址(当前代码下标+1)压入运行栈\"*的代码-再生成*\"将参数依次压入运行栈\"*，记下参数个数-然后生成*“跳转到子过程开始处”*的代码-最后按个数生成*\"将参数依次弹出运行栈\"*的代码。此时返回值正好在stack顶部-`procedure`部分，扫描到参数全部添加进另一个参数表(专门存放参数)，同时将过程名称和当前代码地址加入标识符表-`statement`中的`return`语句，将返回值压栈，交换栈顶两个值，则栈顶值是返回地址，生成跳转代码即可-增加`else` `elif`-利用`JPC`和`JMP`指令，依然使用回填技术，很简单-增加`do` ` while `-同上-负数-不在词法分析中实现-`const_declaration`取得常量数字Token时，如果前面一个Token是减号，则数取反后再存入加入标识符表-`factor`中，根据语法图，识别到负号时，再次调用`factor`，结果在栈顶，此时再生成两条代码`PUT 0;SUB;`实现将栈顶值取反####3.遇到的困难及解决-行号的计算问题-通过识别`\\n`，遇到就增加-但出现现象：对于某些行，行号增加了两次-这种情况出现在标识符是该行的最后一个Token且标识符之后就是换行符，这样，在标识符结束时会有一个回退一个字符的动作，导致`\\n`被扫描两次，则行号也被增加了两次。-为了避免回退导致`\\n`出现两次，应该限制`\\n`扫描后是在`START`状态下，也是不回退的情况下，判断此行结束，所以判断条件改为`if(ch=='\\n'&&state==START)`-考虑到还有块注释的情况，应该改为`if(ch=='\\n'&&(state==START||state==IN_BLOCKCOMMENTS))`-打印错误所在行的文本-最后一次实验需要打印错误所在行的文本，而之前词法分析时是每次用`fgetc`读取一个字符，并没有保存当前行-修改读取方式，一开始用`fgets`读取一行，缓存至`linebuf`中，每次用`pos`偏移获取一个字符放在全局变量`ch`中，如果`ch==0`，即读取到`linebuf`结束时，再使用`fgets`读取一行。-`linebuf`定义在在`lex`结构体中，语法分析时调用错误函数时可以使用。-错误恢复分析问题-一开始不知道如何下手-认真阅读课本中关于错误处理的部分，然后查阅了很多资料之后才大概明白如何处理-一些细节问题-有时候遇到某个错误时，反复报同一个错：处理完一个Token忘了`gettoken`-注意虚拟机的一些特性-比如`DIV`和`SUB`取操作数的顺序和语法分析时的顺序时相反的，需要自行交换栈顶两个数-调用虚拟机打印栈顶值后并不会弹出栈顶值-`NOT`，`AND`，`OR`只能实现对0和1的运算，数值到布尔值的运算需要自行实现####4.亮点-状态表的压缩（详见上面总体设计）-合并输入符号的类型-集合的表示-没有使用任何数据结构-因为集合元素是有限的Token类型，故集合大小有上限-直接用长整型数表示集合，每个位表示一种Token类型(类似独热编码)-将Token_Type（枚举类型）用2的幂映射到一个长整数-用位运算实现集合操作-创建集合：直接定义一个长整型数为0-合并集合：位或运算-元素是否在集合中：位与运算-错误处理-动态生成可能的后续符号集合-有选择地跳过非预期的符号-较好地实现错误跳过并继续分析-模型运行栈和寄存器-虚拟机提供的栈只能实现简单运算，无法深入到栈中获取数据-在内存中模拟运行栈，用生成的代码去**”操作“**运行栈-动态地在向栈中加入活动记录，实现过程的递归调用####5.总结与心得体会-通过实验，我能更深入理解上课所学的理论知识-词法：有限状态机-语法：递归下降预测分析-生成代码：语法制导的翻译，回填技术-错误处理：First集，Follow集-熟悉了git的使用-体会到了编译器编写的困难-检测到错误之后要能继续分析，lab2和lab3大部分时间都在想这个问题-这只是一个小小的实验，实现前端的一些简陋功能，但它已经花费了很长时间-如果面对更复杂的语法，就需要借助生成器，如书上所讲的Yacc-如果再考虑语言的各种特性（面向对象、多态、重载），那就更困难了-编译器生成代码要针对”体系结构“，这里就是助教提供的虚拟机-体会到大型工程管理不易-需要编织好划分好每个文件的功能-处理好全局变量、外部变量，避免重复定义，功能冗余","tags":["C","Compiler"],"categories":[]},{"title":"茶与健康","url":"/s/p/9vv400/","content":"##茶与健康 这学期有幸选中全校最热门的公选课——茶与健康。之前每学期都是1000+人选28人，在周一晚上上课，从上学期开始每周多开一次下午的课（这个时间选择人数较少），正好我这学期周一下午没课，就来碰碰运气，没想到真的抽中了。这门课之所以这么火，主要是因为上课就是喝喝茶，发表自己的感想，听老师讲述茶文化，期末交一篇论文就可以了，虽然可能被卡优秀率，但只有1学分，花点GPA喝喝茶还是很值得的。###18.09.03 今天是第一次上茶与健康课，由周先稠老师上课。老师是真·文化人，他说自己改革开放的第一批大学生，是受益者，也是开拓者践行者。今天，我们科技已经很发达，但却**失去了一些内在的东西**。他会在这门课慢慢讲述。虽然是老年人思维，不过有一些的确是**时间沉淀之下的肺腑之言**。老师确实用心在上这门课，我之前就听说曾经凌晨到肥西县的产茶地挑选刚刚产出的茶叶。比较神奇的是，他不用任何现代通讯设备，要找到他只能去办公室。 今天，老师主要介绍了这门课的来源，他说这门茶艺课已经开了10几年了，和王祥老师的陶艺课一样很受欢迎。本来还要开一门食艺课，但是经费不足。。。对了，他还同时开了一门养生课。果然是养生大师，老师已经60多岁了，但还满头浓密的黑发，一看像是不到50岁的样子。 这门课是在体育教学中心的301室上课，外门的装潢与其他教室并无两样，但一进门，经过短短的通道，进入另一扇门，就是另一番景象了，圆形的内室，木质地板，悬吊的灯笼，古朴的屏风围绕在几张茶几和靠椅周围，我简直不敢相信科大有这样的地方。老师说这个室内装修的材料是他亲自挑选的，但装修工人太不懂他的意思了。他讲要天圆地方，但结果地是圆的，而头上是纵横交错的横梁；他说古人讲究头顶为浅色有开阔感，地上为深色有厚重感（我怎么记得应该是“天玄地黄”，天是黑的，地是黄的），结果地板是淡黄色，头上横梁是深褐色；他讲墙边要一点中国传统风格的围栏，结果建筑工搞了罗马柱。还有水管也被漆成银色，后来他和几个学生一起用褐色麻绳缠绕了水管表面。 老师讲了： > “上这门课，我就是给你们倒茶喝的，你们在家里都会比较放肆，在外面比较收敛，在这里你们只要比在家稍微收敛一点就行了，不要太紧张和拘束。我们科大理工科课程压力大，这里就是给你们放松的机会。但是，我希望你们不要玩手机，而是用心去品茶，**每节课只要有5秒钟是属于你自己的**，我就满足了。” <!--more-->###18.09.10 今天喝的茶闻着清香，但入口即为苦味。老师并没有告诉我们今天喝的是什么品种的茶。 这节课还讲茶的起源。-茶，古时又称“茗”,“贾”,“芟”。-茶文化起源于中国的礼乐时代，茶文化中讲究的“敬”与“和”都蕴含丰富的礼乐精神。茶的饮用最初在西南的巴蜀地区，魏晋南北朝时的民族融合促进茶的传播，但主体仍是上层社会的生活方式。-唐代时，社会经济文化繁荣，禅宗的兴起，禁酒令导致的以茶代酒使得茶文化广泛地深入寻常百姓家。-宋代时对精致文化，高雅生活的极致追求，产生了许多茶文化相关的诗词绘画。-茶文化传入日本后，较好地保留和传承，形成“和、敬、淸、寂”的茶道，但根脉还是在中国。“和、敬、淸、寂”既是一种美学认知，也是一种人生态度。*今天我们已经形成高频的工商信息社会，在生活节奏加快的大趋势下，我们似乎没有时间关心自己的生活是否优雅，付出是否值得，所得是否即是所需。我们没有时间考虑太多，只希望“只争朝夕”，为自己和家庭争取更多的资源。人们若想从中国传统文化中寻觅一些日常生活中缺失的东西，茶艺是一个很好的切入点。将茶艺变成个人化的爱好，可以少一点忽悠，多一点真实的体验，不需要太过在意茶艺的形式和茶具的精美，直接与茶叶和水接触，回归一种质朴的生活风范，或许我们能从中得到一份安详淡定的心境。*###18.09.17 这节课讲茶的分类，根据氧化程度，分为：绿茶、红茶、青茶、黄茶、黑茶、白茶。 绿茶是不发酵茶，是中国最主要的茶类，其工艺相对稳定：杀青、揉捻、干燥。**茶叶的香味最大程度地被保留。**红茶是完全发酵茶，发源地是福建。其工艺多了一步发酵。 还有半发酵茶乌龙茶。 茶还可分为清香型、浓香型、陈香型。清香型香气纯正，鲜醇爽口。浓香型韵味足，耐冲泡。陈香型都是经过了长期存放的老茶，如普洱茶。 最后老师告诉我们这节课喝的茶是桐城兰花，原产于安徽桐城，初闻无甚味道，入口稍苦，但片刻后舌尖有些许甘甜。另外，上次课喝的是黄山毛峰，这两种都属于绿茶，是不发酵的茶。###18.09.24(中秋休假)###18.10.01(国庆休假)###18.10.08 这节课讲茶的功效。-提神。喝完茶后，晚上会特别精神。-促消化、利尿解毒。-治癌。老师讲：“这里面有茶多酚，在实验中对离体癌细胞有破坏力，有类似作用的还有红豆杉、西洋参，但功效不算太大，一两吨也治不好一个人，而且对于活体中的癌细胞依然无效。” 这节课喝的是太平猴魁，是老师在凌晨到达太平镇，趁着黎明让采茶女采下的茶叶剩下的茶叶梗。老师讲，这节课不评价这个茶，因为不是原产地的，是产地郊外10几公里的，大概算是“假茶”，确实，这次放了很多茶叶，但依然无甚味道，冲泡几次便与开水无异了。###18.10.15 今天喝的还是黄山毛峰，但是已经不像第一次那样清香了，是残枝败叶的“假茶”。 老师讲，50元的茶和500元的茶，只需要一位专家来科普5分钟，大家就能分辨出来了；500元和5000元的茶，如果你不能凝神静心，是很难感受出区别的，之前有电视采访节目，让人现场判断茶的品质，结果是那些有经验的饮茶者反而不能正确判断，就是因为这种临时场合很难静下心来；至于5000元和50000元的茶，那就需要灵性和天赋了。###18.10.22 今天喝了两种茶，同学们都说味道都不是很好，有种中药的苦涩味，与绿茶的本该有的清香相去甚远。不过由于我心情很糟糕，好像没有喝出味道。 老师讲解的时候，提到其中一种是野兰香茶，原产于皖南山区宁国市。虽然这原本是一种好茶，但由于保管环境的问题（交替在冰箱和太阳下放了一个暑假），品质败坏了。人也是如此，后天带来的影响极为重要。 老师说下节课将给我们讲一种好茶所需要的六种因素：**产地、产时、保管、研制、水、空气。**###18.10.29 今天喝的茶，初一看，枝叶颜色比先前的深沉得多，一闻，味道甚是厚重，没猜错的话，这应该是发酵茶，至少不是绿茶。入喉，果然重口味，但仔细斟酌，这又不是苦位，并且味道只在入口一瞬，而不会将苦涩之感沉淀在口腔里。 最后得知是祁门红茶。这种茶最初产地只有三个小镇，但是由于近年经济发展所需，周围地区也大量种植这种茶。在大量使用化肥农药后，茶的品质已大大不如原厂地。如今市面上包装精美的所谓“精品茶”就是这些地方产出的。 今天还讲了茶的产地对品质的影响。古语云“上者生烂石,中者生砾壤,下者生黄土”，意为上等之茶生长在岩石悬崖上，中等之茶生长在沙砾、沙土中，下等之茶则生长在泥土中。如今，我们已经很难得到上等茶，那只能是理想中的环境。###18.11.05 今天喝了两种茶，均为红茶，但要求用温水冲泡，并且浸泡5秒就应该马上将茶水和茶叶分离。 第一种茶叶是依然是祁门红茶，颜色褐黄，枝叶嫩小，香味浓重，温水尚未倒完就已经浓香四溢，一种发酵带来的厚重感。我们暗数5秒钟，一看茶水颜色已经泛黄，赶紧将茶倒入公道杯中，分而品之。味苦而不涩，数秒后是苦尽甘来之快感。冲泡数遍，茶香愈发浓重。 第二种茶叶是宜兴的红茶。颜色接近黑色，体验和第一种茶接近。###18.11.12 今天喝的仍然是红茶，总共有两种，但每桌只能拿到一种。 没有特别的感觉，可能红茶味道都差不多吧。 关于茶点，他不告诉我们应该要带什么样的茶点，否则我们就像记住知识一样，也就只会带这些过来了，老师说不过多干涉我们的感觉，让我们把握当下的感觉。 还讲了茶叶的产时： >*明前茶，*是清明节前采制的*茶叶*，受虫害侵扰少，芽叶细嫩，色翠香幽，味醇形美，是茶中佳品。 > >*雨前茶*，雨前，即谷雨前，即4月5日以后至4月20日左右采制用细嫩芽尖制成的茶叶称雨前茶。 明前茶是上等茶，刚刚冒芽，茶农一般舍不得摘下，这时的茶是之后各代茶的“祖先”。 而世面上大多好茶其实是多代“子孙”了，其品质远不如源头好，但是经过包装后就买了好价钱。 老师告诉我们，当前社会风气浮夸，各种事物经过层层包装，已经不像中国古时那样展现其本质。###18.11.19 今天喝的是普洱茶，是一位同学从家乡带来的。茶叶呈黑色块状/饼状，是经过压制的，不过冲泡后味道不重。 老师告诉我们，普洱茶本来是一种普通的茶，但自从人们开始注重资产增值后，普洱茶就像房地产一样被炒起来了，价格虚高。 > 普洱茶是发酵茶，但并没有发酵到极点。茶并不是放得越久也好，也不是发酵的程度越深越好，而是**恰如其分**。 什么是**恰如其分**？老师又举了几个例子 > 正如吃大虾沾麻油一样，两滴，让人回味无穷，太少了，没味道，太多了，满嘴是油。 > 又如所谓20年30年老窖，其实是勾兑酒，10斤老酒可以兑3000斤新酒，这种酒给人的感觉刚刚好。 >古代乐器，丝和竹，弦绷太紧，演奏出来鬼哭狼嚎，弦太松，又听起来低沉。 关于茶点，老师说他继续以批判的眼光来评价我们，但只是他个人看法，让我们自己权衡。 他先讲了中国的饮食。 > 中国饮食发展至今，虽然分为八大菜系，但都讲究一个字 ”**平**“，就像天平一样，这边重了，另一边也要加重保持平衡。 > 比如吃螃蟹总要吃生姜，螃蟹是大寒之物，而姜是暖的，二者一合，就平了。 > 再比如，即使你们天天吃麦当劳/肯德基等洋快餐，等你们中年之后，总会有一天，在家自己做饭蒸煮各种营养的食物，这就是人的自我平衡。 > 茶点也是如此，红茶对应的茶点是应该是甜的。日本茶道中的茶点就是一块小方糖，甜甜的，软绵绵的，表面沾有糖浆，入口即化。 老师补充了一些饮食的看法.> 有人说：”我最近营养不足，得多补补。“ > > 其实不对，饮食习惯是慢慢养成的，如果等到缺的时候再一口气补，不如不要。 > > 我有同事，儿子摔伤了，生活不能自理，医院都下病危通知书了，同事还决定给儿子补补身体，每天各种肉，我说都这样了，补是没有用的，反而加重。你就每天给他熬萝卜汤喝，然后用热水从上到下擦拭身体。后来真的好了。###18.11.26 今天喝的茶是“安茶”。 “安茶”又称“六(liu4)安茶”，但产地并非安徽六(lu4)安，而是之前说的祁门县。这种茶不仅可饮用，还能药用，具有祛湿解毒之效，在东南亚一带为人称道，“六安”就是指安定五脏六腑。 安茶颜色黑呦，人们往往认为是黑茶，其实是介于红茶、绿茶之间的后期半发酵紧压茶，不属于传统分类的六种茶。 > 安茶有着极为独特的“日晒夜露”工艺——白天晒太阳晚上吸收露水，或因“汲日月精华”之义，使它与众不同。很多人喝到安茶，弄不懂这是什么茶类，像岩茶又像黑茶，又像绿茶。这是因为安茶的工艺太复杂，太讲究。除了日晒夜露，安茶在制作工艺中还需要多道炭火烘焙，这工艺像极了传统的乌龙茶。安茶的前期炒青工艺使它像绿茶；其后期的蒸压与存储发酵，喝起来的滋味红浓醇陈，带着特殊的粽叶炭火香，故又似黑茶。 > > 安茶性温凉，尤其是陈年安茶，火气退尽，茶性更温，味涩生津，能够祛湿解暑，特别适合广东、南洋一带多湿热地区。 老师往茶壶里放茶的时候，还从装茶的篮子边缘扯下了些许叶片，我们以为那是编竹篮的竹条，后来知道这是箬叶（即粽叶）。 >安茶的包装也别出心裁，祁门安茶是用竹篓包装。 > >将安茶压紧装入竹篓内，放入烘橱内烘干， > >凝结成椭圆形块状，然后依竹篓容量成型。 ![img](茶与健康11.26_pic/f124901ddc0c4039b75c207f6678d032_th.jpeg)关于安茶，有一段坎坷的经历，几近失传。 > 百年前影响世界的安茶，从1937年日军侵华、水路停运导致停产，消失的时间太长了，整整半个多世纪，对于安茶，人们已经淡漠或遗忘，留下了只有东南亚一带的压在茶箱里的一抹陈香。 >1983年，有一个人也是为了寻访安茶，从香港写信并专程寄了篓老安茶过来，这是香港茶叶发展基金会的关奋发老先生。在香港广东一带，海边渔民喝海水后腹胀，把茶叶放在炉子上煮一煮，喝一碗，病就好了。百年前，岭南的医生曾以安茶入药，治好了广东一带流行的瘟疫。因为安茶的药效，被人们称为“圣茶”，但此茶久已湮没，存世仅有少量的老茶。关奋发老人来信，希望茶区能再现半个世纪前的茶香，于是，安徽省茶叶公司一路问到祁门县茶叶局，最后问到芦溪乡。 >只是那时，大家对安茶已经太陌生了，整个祁门没有一片茶园用于生产安茶。当人们看到早期的茶叶与斑驳的茶票，以为只是一种粗老的茶，凭想象收了些下脚料来做安茶，却怎么也做不出安茶的味道来。 >汪镇响当时担任芦溪乡企业办主任，也在祁门县茶科所学习祁门红茶的制作，他开始关注并尝试更好的安茶的制作。到了1989年、1990年，通过拜访早期孙义顺茶号的传人汪寿康老人，汪镇响对工艺做了更大改进，特地使用了祁门的槠叶种，采用雨前上等贡尖，一等嫩芽，通过安徽省茶叶公司送到香港。香港方面反馈说比以前有进步，但工艺上还有些不到位。后来，一心想恢复安茶工艺的汪镇响，诚心诚意把汪寿康老人请到茶厂来指导生产，让老人回顾安茶工艺更细节的技术，又不断拜访其他几个健在的老师傅，安茶终于得到重生的希望。到了1991年送样，香港方面特别高兴，说很好喝了。1992年，就有了江南春茶厂，复产安茶成功。从那几年开始，安茶开始在广东佛山等地引起了反响。1997年，根据广东省土畜产进出口公司的一位陈经理建议，“孙义顺”的商标开始申请注册，1998年正式启用。但那一段时间，安茶并不是很好卖，市场还是很有压力。安茶销售的机遇，出现在2003年的非典期间——在广东当地，安茶被当作药方，市场由此开始突破。 汪镇响老先生是老师的朋友，老师拜访他时，他的外孙子才十几岁。如今，老先生已离世，这位20几岁的小伙子也承担起传承安茶的重任，老师便告诫他一定要保证茶的质量，不要被当今高频的工商信息社会所影响。 这有个纪录片，祁门《安茶事纪》 <video src=\"http://m.qmhtea.com/video/%E7%A5%81%E9%97%A8%E3%80%8A%E5%AE%89%E8%8C%B6%E4%BA%8B%E7%BA%AA%E3%80%8B.mp4\"></video>###18.12.03 今天老师有事没能来上课，由一位博士生来分发茶叶，这次所喝正是上节课所提的安茶。###18.12.10 今天喝的是太平猴魁，这已经是第三次了。在连续喝了几次红茶后，又回归绿茶，重新体会到当初的苦涩感。 然而，今天的重点不是喝茶，老师让我们先”好自为之“，然后他给我们讲两个故事。 先是讲了梁漱溟闭关看《西方哲学》以及他与毛泽东的故事，再讲了一个制茶大师带男女弟子双休的故事。。 下面是穿插其中的一些话语。 > 喝茶，要虚实交替，动静相接，如果我们都实实在在，把活的感觉都变成知识，那会很可悲。 > 现实没有错，不要过分于现实，不要全力于现实，要留一点精神自我，要留一点空间给自己，正如第一次茶艺课所说。 >你把这些感觉弄丢了，然后去研究什么《易经》，那么不是装神就是弄鬼。科大有的学生，学习成绩不好，就再那卖弄，说自己对《易经》很有研究，”易经是万经之首，经中之王“，前几年我就抓到几个易经大师，都是本科生。 >你们今天好好养护自己的身体，比起成绩/保研/郭沫若奖，我个人认为，更加重要。 > 与人相处，有的人内心阳光，有的人内心相对狭隘，但如果你真正的开心，那么周围的人也会被你影响。你什么样的心态，就伴随你四年的科大生活，如何编织这一过程，都只能靠你们自己。 > > 绵里藏针，暗藏杀机，你们好自为之。","tags":["感想"],"categories":[]},{"title":"算法基础上机实验五 图搜索BFS算法及存储优化","url":"/s/p/9vt9c0/","content":"###题目 图搜索BFS算法及存储优化 >#####实验要求： > > 1.模拟数据集 > > 自己随机生成有向图，边数的规模为10，100，1000，10000，100000； > > 进行BFS搜索，记录程序完成时间和所需内存空间大小。 > > 2.真实数据集 > > <https://pan.baidu.com/s/1pvfphiywjSXohO-bSnL1HA> > > 数据集说明：均为twitter真实数据集，数据集规模如下： > > twitter_small:Nodes 81306,Edges 1768149,有向图； > > twitter_large:Nodes 11316811,Edges 85331846,有向图。 > > 进行BFS搜索，设计存储优化方案和加速方案，记录程序时间和内存空间大小。 > >#####实验说明 > > 1）编程语言和实验平台不限，可考虑并行（i.e.,GPU/OpenMP/MapReduce）； > > 2）至少需完成模拟数据集和twitter_small数据集的实验，twitter_large数据集为加分题。###算法设计####BFS算法 BFS（Breadth First Search），即广度优先搜索，从某个结点s开始，自始至终一直通过已找到和未找到顶点之间的边界向外扩展，就是说，算法首先搜索和s距离为k的所有顶点，然后再去搜索和S距离为k+l的其他顶点。该算法需要一个先进先出队列，只要队列不为空，就从队首取出一个结点n，访问它的所有邻居，如果某个邻居未被标记为已访问（visit=0），则将该邻居加入到队列尾，最后将该结点n标记为已访问（visit=1）。 BFS的时间复杂度为O(V+E)，V为结点数，E为边数。因为每个结点都进入队列一次，访问邻居时每条边至多被扫描一遍。 <!--more-->####存储结构 由于结点数很多且边稀疏，故采用邻接表进行存储，定义两种结构体：-nbnode，表示一个结点的某个邻居-p，int类型，该邻居在结点数组中的下标-next，nbnode*类型，指向下一个邻居-node，表示一个结点-id，int类型，表示从文件中读取到的结点ID-visit，char类型（节省存储），-1表示不存在该结点，0表示结点存在但未访问，1表示存在且已访问。-nblisthead，nbnode*类型，指向第一个邻居 全局开设一个node结点数组arr-对于twitter_small.txt文件，81306个结点，其id最大达到九位数，且不连续，直接作为数组下标将造成数组过大，空间浪费多，因此使用c++的map容器，将id映射到数组下标p，每次读入一个id时，用map查询是否存在，若不存在，将该id和当前未分配的最小数组下标(即nodecount)加入map，然后nodecount++。另外，该文件中有重复边，每次为一个结点添加邻居之前先遍历链表判断是否已存在。在BFS时，访问数组直接使用下标，不再使用id。-对于twitter_large.txt，其id最大值等于结点数11316811，id连续，可以直接作为数组下标，且文件中无重复边，可以直接添加邻居无需判断重复。为了实现对node的计数，起使时visit设为-1，读取文件时，如果该结点visit=-1,则nodecount++，并且让visit=0，表示该结点存在（但未访问）。###结果#####使用bfs_random.cpp测试10.txt 100.txt 1000.txt 10000.txt 100000.txt 以上5个文件由GenGraph.py生成。 100000.txt结果如下 读取时间0.019秒，bfs时间几乎为0，内存为5.8MB(不准确，这是包括运行窗口等其他资源使用的内存)![img](lab5/clip_image002.jpg)![img](lab5/clip_image004.jpg)#####使用bfs.cpp测试twitter_small.txt ​ 文件有重复边，序号连续，81306个结点（序号最大有9位数），1768149条边（但文件有2000000多行） ​ 结果如下 4.5秒完成（其中读取4.4秒，bfs小于0.1秒） 内存约36MB ![img](lab5/clip_image006.jpg)![img](lab5/clip_image008.png)#####使用bfs_large_2.cpp测试twitter_large.txt 文件无重复边，序号连续，11316811个结点（最大序号就是11316811），85331845条边 结果如下 42秒完成（其中读取29秒，bfs13秒） 内存约1466MB ![img](lab5/clip_image010.png)![img](lab5/clip_image012.png)###代码#####small ```c++#include <cstdio>#include <ctime>#include <cstdlib>#include <map>#include <queue> using namespace std;typedef struct _nbnode{int p;//该邻居在表中的下标 struct _nbnode*next;_nbnode(int _p):p(_p){}}nbnode,*nblist;typedef struct _node{int id;char visit;nblist nblisthead;_node(){visit=0;nblisthead=NULL;}}node;node*arr=new node[90000];//结点表 map<int,int> nodemap;//id 映射到 p int edgecount=0,nodecount=0;void bfs(int p){queue<int> q;q.push(p);arr[p].visit=1;while(!q.empty()){nbnode*nb=arr[q.front()].nblisthead;while(nb !=NULL){if(!arr[nb->p].visit){q.push(nb->p);arr[nb->p].visit=1;}nb=nb->next;}q.pop();}}void BFS(){int componentcount=0;for(int i=0;i < nodecount;i++){if(arr[i].visit==0){bfs(i);componentcount++;}}printf(\"component:%d\\n\",componentcount);}void Load(){FILE*fp=fopen(\"twitter_small.txt\",\"r+\");nbnode*nb;int ida,idb,pa,pb;map<int,int>::iterator itera,iterb;while(fscanf(fp,\"%d\",&ida)!=EOF){fscanf(fp,\"%d\",&idb);if((itera=nodemap.find(ida))!=nodemap.end()){pa=itera->second;}else{nodemap[ida]=nodecount;//向map中插入(ida,nodecount)pa=nodecount++;arr[pa].id=ida;}if((iterb=nodemap.find(idb))!=nodemap.end()){pb=iterb->second;}else{nodemap[idb]=nodecount;pb=nodecount++;arr[pb].id=idb;}nb=arr[pa].nblisthead;while(nb !=NULL){if(nb->p==pb)//该边已存在 goto LABEL;nb=nb->next;}nb=arr[pa].nblisthead;arr[pa].nblisthead=new nbnode(pb);arr[pa].nblisthead->next=nb;edgecount++;LABEL:;}printf(\"node:%d\\n\",nodecount);printf(\"edge:%d\\n\",edgecount);}int main(){clock_t t1,t2,t3,t4;t1=clock();Load();t2=clock();printf(\"Load time:%lf s\\n\",(double)(t2-t1)/CLK_TCK);printf(\"------------------------\\n\");t3=clock();BFS();t4=clock();printf(\"BFS time:%lf s\\n\",(double)(t4-t3)/CLK_TCK);return 0;}```#####large ```c++#include <cstdio>#include <ctime>#include <cstdlib>#include <queue> using namespace std;typedef struct _nbnode{int p;//该邻居在表中的下标 struct _nbnode*next;_nbnode(int _p):p(_p){}}nbnode,*nblist;typedef struct _node{int id;char visit;nblist nblisthead;_node(){visit=-1;//-1不存在该结点，0存在但未访问，1，已访问 nblisthead=NULL;}}node;node*arr=new node[11500000];//结点表 int edgecount=0,nodecount=0;void bfs(int p){queue<int> q;q.push(p);arr[p].visit=1;while(!q.empty()){nbnode*nb=arr[q.front()].nblisthead;while(nb !=NULL){if(!arr[nb->p].visit){q.push(nb->p);arr[nb->p].visit=1;}nb=nb->next;}q.pop();}}void BFS(){int componentcount=0;for(int i=0;i < nodecount;i++){if(arr[i].visit==0){bfs(i);componentcount++;}}printf(\"component:%d\\n\",componentcount);}void Load(){FILE*fp=fopen(\"twitter_large.txt\",\"r+\");nbnode*nb;int ida,idb,pa,pb;while(fscanf(fp,\"%d,%d\",&ida,&idb)!=EOF){pa=ida;pb=idb;if(arr[pa].visit==-1){nodecount++;arr[pa].visit=0;}if(arr[pb].visit==-1){nodecount++;arr[pb].visit=0;}nb=arr[pa].nblisthead;arr[pa].nblisthead=new nbnode(pb);arr[pa].nblisthead->next=nb;edgecount++;}printf(\"node:%d\\n\",nodecount);printf(\"edge:%d\\n\",edgecount);}int main(){clock_t t1,t2,t3,t4;t1=clock();Load();t2=clock();printf(\"Load time:%lf s\\n\",(double)(t2-t1)/CLK_TCK);printf(\"------------------------\\n\");t3=clock();BFS();t4=clock();printf(\"BFS time:%lf s\\n\",(double)(t4-t3)/CLK_TCK);return 0;}```#####random ```c++#include <cstdio>#include <ctime>#include <cstdlib>#include <queue> using namespace std;typedef struct _nbnode{int p;//该邻居在表中的下标 struct _nbnode*next;_nbnode(int _p):p(_p){}}nbnode,*nblist;typedef struct _node{int id;char visit;nblist nblisthead;_node(){visit=-1;//-1不存在该结点，0存在但未访问，1，已访问 nblisthead=NULL;}}node;node*arr=new node[100010];//结点表 int edgecount=0,nodecount=0;void bfs(int p){queue<int> q;q.push(p);arr[p].visit=1;while(!q.empty()){nbnode*nb=arr[q.front()].nblisthead;while(nb !=NULL){if(!arr[nb->p].visit){q.push(nb->p);arr[nb->p].visit=1;}nb=nb->next;}q.pop();}}void BFS(){int componentcount=0;for(int i=0;i < nodecount;i++){if(arr[i].visit==0){bfs(i);componentcount++;}}printf(\"component:%d\\n\",componentcount);}void Load(){FILE*fp=fopen(\"100000.txt\",\"r+\");nbnode*nb;int ida,idb,pa,pb;while(fscanf(fp,\"%d%d\",&ida,&idb)!=EOF){pa=ida;pb=idb;if(arr[pa].visit==-1){nodecount++;arr[pa].visit=0;}if(arr[pb].visit==-1){nodecount++;arr[pb].visit=0;}nb=arr[pa].nblisthead;arr[pa].nblisthead=new nbnode(pb);arr[pa].nblisthead->next=nb;edgecount++;if(edgecount%1000000==0)printf(\"%d\\n\",edgecount);LABEL:;}printf(\"node:%d\\n\",nodecount);printf(\"edge:%d\\n\",edgecount);}int main(){clock_t t1,t2,t3,t4;t1=clock();Load();t2=clock();printf(\"Load time:%lf s\\n\",(double)(t2-t1)/CLK_TCK);printf(\"------------------------\\n\");t3=clock();BFS();t4=clock();printf(\"BFS time:%lf s\\n\",(double)(t4-t3)/CLK_TCK);return 0;}GenGraph.py import random for n in[10,100,1000,10000,100000]:s=set()while len(s)< n:a=random.randint(1,int(n/3))b=random.randint(1,int(n/3))while a==b:b=random.randint(1,10)s.add((a,b))f=open(str(n)+\".txt\",\"w\")for e in s:f.write(str(e[0])+\" \"+str(e[1])+\"\\n\")f.close()```","tags":["Algorithm"],"categories":[]},{"title":"汇编上机资源","url":"/s/p/9vluo0/","content":"###IDE 1.使用[Emu8086](./lab_res/emu8086setup.exe)仿真(支持DOS16位程序)-emu8086不能用： 1.32位寄存器 2.INVOKE 3.USES 4..IF.ENDIF.ELSEIF 5..REPEAT.UNTIL 2.或者[MASMPlus](./lab_res/MASM_PLUS_1.2.exe)+[DOSBOX](./lab_res/DOSBox0.74-2-win32-installer.exe)(支持DOS16位或32位程序)-详解从零开始配置汇编开发环境(DosBox,MasmPlus)https://blog.csdn.net/yongf2014/article/details/46273949-DOSBOX使用:窗口太小问题 https://blog.csdn.net/m0_37822685/article/details/80241598 挂载指定目录 https://jingyan.baidu.com/article/ce09321b7649012bff858f32.html###Docs-[DOS_Interrupts](./lab_res/DOS_Interrupts.html)-[DOS_Error_Codes](./lab_res/DOS_Error_Codes.html)-Win32汇编--使用 MASM https://www.cnblogs.com/poli/p/4737352.html <!--more-->###Note-PROC里记得RET，否则调用过程后不返回，将顺序执行-MACRO里的LABEL使用前用LOCAL限制在局部，否则多次调用宏会报重复-NUMS是WORD（字）数组，MOV NUMS[BX],AX 后BX应该加2才能下一次使用，如果加1，下一次是存在下一字节，而不是下一字，可能会覆盖之前的数据-int 21h是只能在DOS下使用，但不是只能16位模式，.386开关开启后仍可以使用-masmplus相关-在dos上想使用32位寄存器的话 那就要 >=.386-.386;指明指令集.model flat,stdcall 程序工作模式,flat为Windows程序使用的模式(代码和数据使用同一个4GB段),stdcall为API调用时右边的参数先入栈 option casemap:none;指明大小写敏感-过程结束不能只写`ENDP`,要完整`PROCNAME ENDP`-调用没有参数的PROC时可直接CALL 有参数的应该用`INVOKE` ```assembly INVOKE FGETN,FILEHANDLE,DNUMS[BX]``` INVOKE格式 ``` invoke procedure,parameter1,parameter2,parameter3 ``` 等价于手动PUSH参数，然后用CALL ``` push parameter3 push parameter2 push parameter1 call procedure ```-在masmplus中编译 ```assembly CALC:BIGMUL D_N_FAC,D_TMP,D_I MOV8 D_TMP,D_N_FAC CALL PRINTNHEX PRINTNEWLINE INC D_I[0];I++LOOP CALC ``` 提示 > error A2075:jump destination too far:by 22 byte(s)stackoverflow上查得原因是 > `loop` has limited range.It can only jump up to 127 bytes ahead or 128 back in the instruction stream measured from the start of the following instruction.前面几条宏展开后指令非常长 把LOOP改用 ```assembly DEC CX CMP CX,0 JNE CALC ``` 就行了-使用64位寄存器-https://www.cnblogs.com/DennyChen/p/8143629.html 64位汇编要用ml64.exe https://bbs.csdn.net/topics/392154763?page=1 64位寄存器使用问题 https://blog.csdn.net/cosmoslife/article/details/15020181 x64汇编","tags":["MCPS"],"categories":[]},{"title":"汇编上机题4","url":"/s/p/9vi5c0/","content":"###题目 >编程计算任一整数加减运算表达式，其中，表达式长度不超过1024个字节，从键盘输入，可带括号，操作数为字数据 <!--more-->###代码 ```assembly;思路;(1)读一个取输入字符(存在CHARS数组);(2)读到'('，记下位置，存在POS_LPAREN数组中，同时记下数量NUM_LPAREN，继续读字符;(3)读到'='，结束读,转(5);(4)如果遇到非法字符，报错，退出;(5)开始一轮计算，从最右的左括号开始计算;(6)GET_NUM1;(7)GET_OP,若是')'或'='完成本轮计算，回填结果到CHARS数组，转(5);(8)GET_NUM2;(9)NUM1=NUM1 OP NUM2,转(7);计算过程中已算过的部分用'$'填充，以后读取到直接跳过.MODEL SMALL.STACK 100H.DATA CHARS DB 1024 DUP(0);输入串 POS_LPAREN DB 512 DUP(0);左括号位置数组 NUM_LPAREN DB 0;左括号数量 NUM_LPAREN_UNMATCH DB 0;未配对的左括号数量 LENGTH DW 0;输入串总长度 OP DB 0 CHAR DB 0 TEMP1 DW 0 TEMP2 DW 0 ADDR DW 0;记录每次运算中左括号在CHARS的位置，便于存储 ERRMSG1 DB 0DH,0AH,\"ILLEGAL CHAR!!!\",'$' ERRMSG2 DB 0DH,0AH,\"UNMATCHED BRACKET!!!\",'$' ERRMSG3 DB 0DH,0AH,\"OPERATOR ERROR!!!\",'$' INPUTFLAG DB 0;记录上一个输入字符的类型，1为数字，2为+或-.CODE.STARTUP;=====================================================================GETCHAR MACRO;获取当前输入字符，存在AL MOV AH,1 INT 21H ENDM PRINTS MACRO _PSTRING;打印字符串 PUSH AX PUSH DX MOV AH,9H LEA DX,_PSTRING INT 21H POP DX POP AX ENDM PRINTCHAR MACRO CHAR;打印一个字符 PUSH AX PUSH DX MOV AH,2 MOV DL,CHAR INT 21H POP DX POP AX ENDM PRINTNUM MACRO NUM;打印一个16位整数,AX PUSH AX PUSH BX PUSH CX PUSH DX;----------------MOV AX,NUM MOV BX,10 MOV CX,0 DPUSH:MOV DX,0 DIV BX;DX:AX/10,即AX/10 商在AX，余数在DX PUSH DX;余数即最低位，压栈 INC CX;统计位数 CMP AX,0 JZ DPOP;商为0，已经是最高位，开始出栈 JMP DPUSH DPOP:POP DX ADD DL,30H MOV AH,2H INT 21H;打印栈顶的位 LOOP DPOP;----------------POP DX POP CX POP BX POP AX PRINTN ENDM;=====================================================================LEA BX,CHARS MOV CX,0 LEA DI,POS_LPAREN INC DI;POS_LPAREN[0]不存储，从POS_LPAREN[1]开始 GETC:GETCHAR MOV[BX],AL;当前字符存进CHARS数组 INC BX CMP AL,3DH JE GETC_END;是'=',CMP AL,'(' JNE GETC1;不是'(',继续判断;----------MOV[DI],CL;是'(' 存下当前'('的位置 INC DI INC NUM_LPAREN;'('数量++INC NUM_LPAREN_UNMATCH MOV INPUTFLAG,0 JMP GETC_CONTINUE;----------GETC1:CMP AL,')' JNE GETC2;不是')',继续判断;----------DEC NUM_LPAREN_UNMATCH;是')',减少未配对的'('数 MOV INPUTFLAG,0 JMP GETC_CONTINUE;----------GETC2:CMP AL,'+' JZ GETC_OP_CHECK;---------------CMP AL,'-' JZ GETC_OP_CHECK;---------------CMP AL,'0' JL ERROR1;非法字符 CMP AL,'9' JG ERROR1;非法字符 MOV INPUTFLAG,1;记录当前输入字符是数字 JMP GETC_CONTINUE GETC_OP_CHECK:CMP INPUTFLAG,2 JZ ERROR3;上一个输入字符是+或-,报错 MOV INPUTFLAG,2;记录当前输入字符是+或-GETC_CONTINUE:INC CX JMP GETC GETC_END:INC CX MOV LENGTH,CX CMP NUM_LPAREN_UNMATCH,0 JNZ ERROR2 JMP CAL_PAREN;----------------------------------------------------------CAL_PAREN:;从当前最右的'('开始计算 LEA DI,POS_LPAREN MOV BL,NUM_LPAREN MOV BH,0 ADD DI,BX MOV AL,[DI];读出ARRAY[num];AL=最右的即第NUM_LPAREN个'('的位置 MOV AH,0 LEA DI,CHARS ADD DI,AX;DI加上偏移地址，得到左括号位置，即本轮开始读取的位置 MOV ADDR,DI;记下该位置，本轮结束后从这开始存结果;-----------MOV DH,[DI]CMP DH,28H JNE START_CAL MOV DH,24H MOV[DI],DH INC DI JMP START_CAL;-----------------------------------------------------------START_CAL:PUSH AX PUSH CX PUSH DX MOV AX,0 MOV CX,0 MOV DX,0 GET_NUM1:MOV DH,[DI]CMP DH,24H;读到$继续读 JE L3 CMP DH,3DH;读到=输出 MOV TEMP1,AX JE PRINTRESULT CMP DH,24H JNE L2 L3:INC DI MOV DH,[DI]CMP DH,3DH;读到=输出 JE PRINTRESULT CMP DH,28H;读到（就再读一位 JE L3 CMP DH,24H;读到$再读一位 JE L3 JNE L2 L2:MOV[DI],24H;将$填入 INC DI CMP DH,2DH MOV CHAR,DH;每个字符存入CHAR，若为算符就跳入存进OP JLE RETU1;小于'-'，即不是数字，该整数已完成读取;继续该数的读取 SUB DH,30H;计算第一个数字TEMP1；就每读一个字符（ASCII)，减去30H ，若下一个字符还是数字，就将这个数字乘10再加上下一个字符，依次进行 MOV DL,DH MOV DH,0 PUSH DX MOV CX,10 MUL CX POP DX ADD AX,DX JMP GET_NUM1 RETU1:MOV TEMP1,AX;存入TEMP1 JMP GET_OP;-----------------------------------GET_OP:MOV DH,CHAR CMP DH,3DH;若为=则输出， JE PRINTRESULT CMP DH,29H;若为）则完成本轮计算 JE FINISH_CAL MOV OP,DH MOV AX,0 JMP GET_NUM2;-----------------------------------JUDGE_OP:;读到&就再读一个字符，一定为-INC DI MOV DH,[DI]INC DI CMP DH,OP;与读取NUM2前的OP进行比较，+-为负，--为正 JNE L14 MOV DH,28H;OP更换为+MOV OP,DH JMP GET_NUM2 L14:MOV OP,DH;OP更换为-JMP GET_NUM2;-----------------------------------GET_NUM2:;类似GET_NUM1，一轮中GET_NUM1后，不断GET_OP GET_NUM2 MOV DH,[DI]MOV CHAR,DH CMP DH,3DH;'=' JE RETU2 CMP DH,26H;'&' JE JUDGE_OP CMP DH,24H;'$' JNE L4 L5:INC DI MOV DH,[DI]CMP DH,3DH;'=' JE RETU2 CMP DH,28H;'(' JE L5 CMP DH,24H;'$' JNE L4 JE L5 L4:MOV[DI],24H;将$填入 INC DI CMP DH,2DH;'-' MOV CHAR,DH JLE RETU2;小于'-'，即不是数字，该整数已完成读取;继续该整数的读取，-30H，AX*10再加该位 SUB DH,30H MOV DL,DH MOV DH,0 MOV CX,10 PUSH DX MUL CX POP DX ADD AX,DX JMP GET_NUM2 RETU2:MOV TEMP2,AX JMP CAL1;----------------------------------------------------------CAL1:CMP OP,2DH;'-' MOV AX,0 JE TOSUB JNE TOADD TOSUB:MOV DX,TEMP2 SUB TEMP1,DX MOV TEMP2,0 JMP GET_OP TOADD:MOV DX,TEMP2 ADD TEMP1,DX MOV TEMP2,0 JMP GET_OP;---------------------------------------------------------FINISH_CAL:MOV AX,TEMP1 MOV DI,ADDR;本轮开始读取的位置，从这开始存结果 CMP AX,0 JGE SAVETEMP1;TEMP1大于0,直接存;若TEMP1小于0，则先存入&，再存入-MOV[DI],26H INC DI MOV[DI],2DH INC DI;--------取正TEMP1，用0-TEMP1使其变正 MOV CX,0 SUB CX,AX MOV AX,CX SAVETEMP1:;将（取正后的）TEMP1以字符串存进CHARS数组， PUSH BX PUSH CX PUSH DX;----------------MOV BX,10 MOV CX,0 DPUSH1:MOV DX,0 DIV BX;DX:AX/10,即AX/10 商在AX，余数在DX PUSH DX;余数即最低位，压栈 INC CX;统计位数 CMP AX,0 JZ DPOP1;商为0，已经是最高位，开始出栈 JMP DPUSH1 DPOP1:POP DX ADD DL,30H MOV[DI],DL INC DI LOOP DPOP1;----------------POP DX POP CX POP BX;----------------DEC NUM_LPAREN POP DX POP CX POP AX;-----------------------------------------------------------ENDJUDGE:CMP NUM_LPAREN,0 JGE CAL_PAREN;'('数量>0，开始新的一轮计算 JMP PRINTRESULT;结束，打印;--------------------------------下面是结果输出 PRINTRESULT:MOV AX,TEMP1 CMP AX,0 JGE POSTIVE;大于等于0，直接开始打印 MOV CX,0 SUB CX,AX MOV AX,CX;小于0，取出正数 PRINTCHAR 2DH;打印‘-’ POSTIVE:PRINTNUM AX JMP CEND ERROR1:PRINTS ERRMSG1 JMP CEND ERROR2:PRINTS ERRMSG2 JMP CEND ERROR3:PRINTS ERRMSG3 JMP CEND CEND:.EXIT END ```","tags":["MCPS"],"categories":[]},{"title":"算法基础上机实验四 最佳调度问题","url":"/s/p/9vgao0/","content":"###题目 最佳调度问题###问题描述 设有n个任务由k个可并行工作的机器来完成，完成任务i需要时间为ti。试设计一个算法找出完成这n个任务的最佳调度，使完成全部任务的时间最早。（要求给出调度方案） 完成全部任务的时间为运行时间最长的机器上运行的总时间，所有机器都是相同的。一个任务只能在一个机器上完成，且在完成之前不会被其他任务抢占。###算法设计#####回溯法 回溯法是一个既带有系统性又带有跳跃性的搜索算法。-系统性：它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。-跳跃性：算法搜索至解空间树的任一结点时，判断该结点为根的子树是否包含问题的解，如果肯定不包含，则跳过以该结点为根的子树的搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。 这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。 提高回溯法效率的二种方法-用约束函数剪去不满足约束的子树；-用限界函数剪去不能得到最优解的子树。 最佳调度问题可以用回溯法解决，并且是属于子集树回溯法。对于每个任务i，都可能分配到k台机器的任意一台上，解空间为![img](lab4/clip_image002.png)，现在要求的是使得最长机器时间最短的解。 <!--more--> 回溯算法伪代码如下： ``` BackTrack(int task,int spendtime){if(task==n){//分配完毕 if(spendtime < besttime){besttime=spendtime;记下当前最优解的方案;}return;}for(每台机器j){将任务task分配给当前机器j;机器j的时间+=任务task的时间;BackTrack(task+1,max(spendtime,机器j的时间));回溯，不将任务task分配给当前机器j，用0表示未分配;机器j的时间-=任务task的时间;}return;}``` 初始时调用BackTrack(1,0);如果只是简单的回溯，解空间随着n和k的增大呈指数级增长，时间复杂度达O(k^n)，为此，这里进行了几处优化：-最优化剪枝——如果当前各个机器时间中的最长时间，即spendtime已经大于最佳方案的时间（besttime），则不再继续向下一层搜索。-初始解——使用贪心的方法求得一个初始解，即得到一个初始的besttime，这样可以让besttime尽快地减少至接近最后的结果，使得上面的剪枝能更早地抛弃不需要的子树。贪心的策略是，每次分配当前任务都选择最短时间的机器。-预排序——初始时，任务按时间降序排列，即从时间最长的任务开始分配，这样可以加强上面的剪枝，减少不必要的搜索层次-去除重复的搜索——由于机器之间是无差别的，而一台机器分配的任务也是无序的。对于某个方案，对所有机器进行重新排列，以及对一台机器的任务重新排列，得到的任意一个方案对于这个问题都是等价的（最佳调度时间相同）。因此，搜索时，只考虑按每台机器的最长的任务的时间降序排列的那种方案。由于任务分配前已按时间降序排列，故放入一台空机器的第一个任务就是该机器的最长时间的任务。如果当前要放入一台空机器的任务时间大于前一台机器的最长任务的时间就说明情况重复了，不用继续搜索。###代码 ```c++#include <cstdio>#include <cstdlib>#include <algorithm>#define MAXTASK 100//最大任务数#define MAXMACHINE 100//最大机器数 using namespace std;int n,k;//n：任务数，k:机器数 int times[MAXTASK];//每个任务对应的时间 int schedule[MAXTASK];//当前调度方案，每个任务分配的机器号，取0表示还未分配 int machinetime[MAXMACHINE]={};//每个机器工作的总时间,机器下标从1开始算 int machinemaxtasktime[MAXMACHINE]={};int besttime=999999999;//最优解，即完成全部任务最短时间，初始化为无穷大 int bestschedule[MAXTASK];//最优解的调度方案 int max(int a,int b){return a > b?a:b;}bool cmp(int a,int b){return a > b;}int init(){//贪心地求出初始解 int tmpmachinetime[MAXMACHINE]={};int minmachine,mintime=999999999;int spendtime=0;for(int i=1;i <=k;i++){tmpmachinetime[i]=times[i];//前k个任务分配给k个机器}for(int i=k+1;i <=n;i++){for(int j=1;j <=k;j++){if(tmpmachinetime[j]< mintime){mintime=tmpmachinetime[j];minmachine=j;}}tmpmachinetime[minmachine]+=times[i];spendtime=max(spendtime,tmpmachinetime[minmachine]);}return spendtime;}void BackTrack(int task,int spendtime){//子集树回溯法 if(task==n){//分配完毕 if(spendtime < besttime){//可行解与当前最优解进行比较 besttime=spendtime;for(int i=0;i < n;i++)//记下当前最优解的方案 bestschedule[i]=schedule[i];}return;}for(int j=1;j <=k;j++){if(max(spendtime,machinetime[j]+times[task])< besttime){//剪枝，若当前最长机器时间已经超出最少时间，则不继续搜索 if(machinetime[j]==0){//当前机器是空的 if(machinemaxtasktime[j-1]< times[task])break;//对于一个可行解对应的方案，把各个机器重新排序，是等价的//故我们只保留按每台机器最长任务的时间降序的方案//由于任务分配前按时间降序排列，放入一台空机器的第一个任务就是该机器的最长时间的任务//如果当前要放入一台空机器的任务时间大于前一个机器的最长任务的时间//说明情况重复了 machinemaxtasktime[j]=times[task];}schedule[task]=j;//将任务t分配给当前机器j machinetime[j]+=times[task];BackTrack(task+1,max(spendtime,machinetime[j]));schedule[task]=0;//回溯，不将任务t分配给当前机器j，0表示未分配 machinetime[j]-=times[task];if(machinetime[j]==0)//恢复 machinemaxtasktime[j]=0;}}return;}int main(){FILE*fp=fopen(\"in3.txt\",\"r\");fscanf(fp,\"%d%d\",&n,&k);for(int i=0;i < n;i++){fscanf(fp,\"%d\",&times[i]);}fclose(fp);sort(times,times+n,cmp);//times按降序排序 besttime=init();machinemaxtasktime[0]=999999999;printf(\"----------------------------Input----------------------------\\n\");printf(\"Task Time\\n\");for(int i=0;i < n;i++)printf(\"%4d%4d\\n\",i,times[i]);BackTrack(0,0);//子集树回溯法 printf(\"----------------------------Output----------------------------\\n\");printf(\"Best time:%d\\n\",besttime);printf(\"Task Machine\\n\");//按任务对应的机器输出 for(int i=0;i < n;i++)printf(\"%4d%4d\\n\",i,bestschedule[i]);printf(\"Machine Task_list\\n\");//按机器对应的任务输出 int tmp[MAXMACHINE][MAXTASK]={};//第一维为机器下标，第二维第0个为任务数，之后为任务下标列表 for(int i=0;i < n;i++){//i为任务下标 int j=bestschedule[i];//该任务对应的机器下标 int l=++tmp[j][0];//当前机器分配的任务数+1 tmp[j][l]=i;}for(int j=1;j <=k;j++){printf(\"%4d \",j);for(int i=1;i <=tmp[j][0];i++)printf(\"%4d\",tmp[j][i]);printf(\"\\n\");}return 0;}```","tags":["Algorithm"],"categories":[]},{"title":"汇编上机题3","url":"/s/p/9v56o0/","content":"###题目 > 计算N!（0<N<20） <!--more-->###代码 ```assembly.MODEL SMALL.DATA D_N DW 4 DUP(0);N(64bit)D_N_FAC DW 4 DUP(0);N!(64bit)D_TMP DW 4 DUP(0)D_I DW 4 DUP(0)MAP DB \"0123456789ABCDEF\" Q_TMP DW 0 R_TMP DW 0.CODE PRINTNEWLINE MACRO _PSTRING;打印换行符 PUSH AX PUSH DX MOV AH,2 MOV DL,0DH INT 21H MOV DL,0AH INT 21H POP DX POP AX ENDM PRINTNHEX PROC;打印一个64位整数(16进制)PUSHA;----------------MOV BX,7 MOV CX,8 PLOOP:MOV AL,BYTE PTR D_N_FAC[BX]MOV AH,0;CMP AX,0;JZ PEND:MOV DL,10H DIV DL;商在AL，余数在AH MOV BYTE PTR Q_TMP,AL MOV BYTE PTR R_TMP,AH MOV DI,Q_TMP MOV DL,BYTE PTR MAP[DI]MOV AH,2H INT 21H MOV DI,R_TMP MOV DL,BYTE PTR MAP[DI]MOV AH,2H INT 21H;PEND:DEC BX LOOP PLOOP;----------------POPA RET ENDP MOV8 MACRO DATAA,DATAB PUSH AX MOV AX,DATAB[0]MOV DATAA[0],AX MOV AX,DATAB[2]MOV DATAA[2],AX MOV AX,DATAB[4]MOV DATAA[4],AX MOV AX,DATAB[6]MOV DATAA[6],AX POP AX ENDM BIGMUL MACRO RES,A,B PUSHA;----------------MOV WORD PTR RES[0],0 MOV WORD PTR RES[2],0 MOV WORD PTR RES[4],0 MOV WORD PTR RES[6],0 MOV CX,4 MOV BX,0 LOOP1:MOV DI,0 PUSH CX;------------LOOP2:MOV AX,B[BX]MUL A[DI];DX:AX=A[DI]*B[BX]MOV SI,BX ADD SI,DI;SI=BX+DI ADD WORD PTR RES[SI],AX PUSHF CMP SI,6 JZ AEND POPF ADC WORD PTR RES[SI+2],DX PUSHF CMP SI,4 JZ AEND POPF ADC WORD PTR RES[SI+4],0 PUSHF CMP SI,2 JZ AEND POPF ADC WORD PTR RES[SI+6],0 JMP AEND2 AEND:POPF AEND2:ADD DI,2 LOOP LOOP2;------------POP CX ADD BX,2 LOOP LOOP1;----------------POPA ENDM.STARTUP MOV WORD PTR D_N[0],19 MOV CX,WORD PTR D_N[0];循环次数 MOV D_I[0],1;当前i MOV D_TMP[0],1;临时结果 CALC:BIGMUL D_N_FAC,D_TMP,D_I MOV8 D_TMP,D_N_FAC CALL PRINTNHEX PRINTNEWLINE INC D_I[0];I++LOOP CALC.EXIT END ```","tags":["MCPS"],"categories":[]},{"title":"算法基础上机实验三 最长公共子序列问题","url":"/s/p/9v3c00/","content":"###题目 最长公共子序列问题和调研报告###算法设计**1.****最长公共子序列问题**（Longest common subsequence problem）的定义 ​**子序列**：给定序列X=(x1,x2,…,xm)，序列Z=(z1,z2,…,zk)是X的一个子序列，必须满足：若X的索引中存在一个严格增的序列i1,i2,…,ik，使得对所有的j=1~k，均有xij=zj ​**公共子序列（CS）**：Z是X和Y的子序列，则Z是两者的公共子序列CS。 ​**最长公共子序列（LCS）：**在X和Y的CS中，长度最大者为一个最长公共子序列**2.****用动态规划求解LCS**（1）刻画LCS最优解的结构特征 如果用暴力搜索的方法求解LCS，就要穷举X的所有子序列，对每个子序列检查他是否也是Y的子序列，记录找到的最长子序列。X的每个子序列对应X的下标集合是{1,2,…,m}的一个子集，所以X有2m个子序列，时间复杂度为指数阶，真实情况下无法接受。 通过下面的定理，我们可以知道最长公共子序列问题具有最优子结构性质，可以用动态规划方法解决。**定义**X的ith前缀：Xi=(x1,x2,…,xm)，i=1~m，X0=φ(空集)。**定理**设序列X=(x1,x2,…,xm)和Y=(y1,y2,…,yn)，Z=(z1,z2,…,zk)是X和Y的任意一个LCS，则有 ①若xm=yn,==> zk=xm=yn且Zk-1是Xm-1和Yn-1的一个LCS;②若xm!=yn且zk!=xm,==> Z是Xm-1和Y的一个LCS;③若xm!=yn且zk!=yn,==> Z是X和Yn-1的一个LCS;（证明略去） 由此可见，2个序列的最长公共子序列可由(1)(2)(3)算出，(2)(3)的解是对应子问题的最优解。因此，最长公共子序列问题具有最优子结构性质。 <!--more--> （2）子问题的递归解 上面的定理意味着我们求解X和Y的一个LCS时需要求解一个或两个子问题： ①如果 xm=yn 则 找Xm-1和Yn-1的LCS； ②如果 xm!=yn 则 找Xm-1和Y的LCS 和 找X和Yn-1的LCS； 取两者中的最大的； ​ 定义c[i,j]=Xi和Yj的LCS长度，i=0~m,j=0~n，则有如下公式 ![img](lab3/clip_image002.jpg)（3）计算最优解和构造LCS 根据上面的公式，我们可以使用自底向上的动态规划方法。若X和Y的长度分别为m和n，则时间复杂度为O（mn）。 使用如下变量 c[0..m,0..n]//二维数组，存放最优解值，计算时行优先 b[1..m,1..n]//二维数组，解矩阵，存放构造最优解信息 ![img](lab3/clip_image004.png)当构造解时，从b[m,n]出发，上溯至i=0或j=0止 上溯过程中，当b[i,j]包含“↖”时打印出xi(yj)（4）进一步改进 对于表c，事实上，每个c[i,j]只依赖与其他三项：c[i-1,j]、c[i,j-1]和c[i-1,j-1]，因此，表c可以进一步压缩，无需O（mn）空间。 两种思路： ① c[i-1,j]、c[i,j-1]和c[i-1,j-1]只涉及当前行和上一行，因此表c只需保留两行，反复利用这两行，原先第i行的数据可以覆盖在第i-2行上。同时选取min（m,n）为行的长度。 ②表c只保留一行，选取min（m,n）为行的长度，假设为n，则表c[1…n]。原来计算c[i,j]，现在计算c[j]。另外增设一个变量tmp，每次计算c[j]后，把原先c[j]值保存在tmp中。 ![img](lab3/clip_image006.png)###代码 ```c++#include <stdio.h>#include <string.h>#define MAXLEN 100 int c[MAXLEN][MAXLEN]={};int b[MAXLEN][MAXLEN]={};int m,n;char s1[MAXLEN],s2[MAXLEN];void printlcs(int i,int j){if(i==0||j==0)return;if(b[i][j]==1){//指向左上,i-1,j-1 printlcs(i-1,j-1);printf(\"%c\",s1[i-1]);}else if(b[i][j]==2)//指向上,i-1,j printlcs(i-1,j);else//指向左,i,j-1 printlcs(i,j-1);}void lcs(){m=strlen(s1);n=strlen(s2);int i,j;for(i=1;i<=m;i++){for(j=1;j<=n;j++){if(s1[i-1]==s2[j-1]){//s1[1..i]和s2[1..j]的LCS是s1[1..i-1]和s2[1..j-1]的LCS的长度加1 c[i][j]=c[i-1][j-1]+1;b[i][j]=1;}else if(c[i-1][j]>=c[i][j-1]){//s1[1..i]和s2[1..j]的LCS就是s1[1..i-1]和s2[1..j]的LCS c[i][j]=c[i-1][j];b[i][j]=2;}else{//s1[1..i]和s2[1..j]的LCS就是s1[1..i]和s2[1..j-1]的LCS c[i][j]=c[i][j-1];b[i][j]=3;}}}printlcs(m,n);printf(\"\\n%d\\n\",c[m][n]);}int main(){printf(\"input the first string:\");scanf(\"%s\",s1);printf(\"input the second string:\");scanf(\"%s\",s2);lcs();return 0;}```###总结 这次实验让我比较深入地了解了动态规划的使用条件及其应用。动态规划要求解问题必须满足最优子结构，即该问题的最优解包含其子问题的最优解。动态规划与分治法相似，都是通过组合子问题的解来求解原问题，但分治法将原问题划分为互不相交的子问题，递归地求解子问题，而动态规划适用于子问题重叠的情况，并且对于每个子问题只求解一次，将其解保存在一个表格中，避免了不必要的计算。","tags":["Algorithm"],"categories":[]},{"title":"汇编上机题2","url":"/s/p/9us800/","content":"###题目 >编程实现排序算法，对某文件（txt格式）中的无符号整数进行排序，排序结果输出到屏幕（数据的个数不超过1024） <!--more-->###代码 ```assembly.MODEL SMALL,STDCALL.DATA N DW 0 TMP DW 1 DUP(0)NUMS DW 1024 DUP(0)MSG_ERR DB 0dh,0ah,'THERE ARE SOME ERRORS IN OPERATING THE FILE!','$' MSG_SUCCESS db 0dh,0ah,'SORT RESULT:','$' FILEHANDLE DW 0 FILENAME DB \"test2.txt\" TMPC DB 1 DUP(0).CODE PRINTC MACRO CHAR;打印字符 PUSH AX PUSH DX MOV AH,2 MOV DL,CHAR INT 21H POP DX POP AX ENDM PRINTS MACRO PSTRING;打印字符串 PUSH AX PUSH DX MOV AH,9H LEA DX,PSTRING INT 21H POP DX POP AX ENDM PRINTN PROC;打印一个16位整数,AX;PUSH AX PUSH BX PUSH CX PUSH DX;----------------MOV BX,10 MOV CX,0 DPUSH:MOV DX,0 DIV BX;DX:AX/10,即AX/10 商在AX，余数在DX PUSH DX;余数即最低位，压栈 INC CX;统计位数 CMP AX,0 JZ DPOP;商为0，已经是最高位，开始出栈 JMP DPUSH DPOP:POP DX ADD DL,30H MOV AH,2H INT 21H;打印栈顶的位 LOOP DPOP;----------------POP DX POP CX POP BX;POP AX RET PRINTN ENDP FGETN PROC;从文件读取一个16位整数,结果在AX PUSH BX PUSH CX PUSH DX MOV CX,5;数的文本长度，最长5位 MOV AX,0;乘法用的AX,初始化 LOOP1:;-------------------READCHAR PUSH AX PUSH BX PUSH CX PUSH DX MOV AH,3FH MOV BX,FILEHANDLE MOV CX,1;读取长度 LEA DX,TMPC;用于暂存读取的串 INT 21H;读取后AX存放实际读取出的字符数 JC R_ERR;CF=1 出错 CMP AX,0 JZ R_QUIT;AX=0,EOF CMP TMPC[0],20H JZ R_QUIT;空格 POP DX POP CX POP BX POP AX;-------------------MOV DX,10;DX=10 MUL DX;DX:AX=AX*10 由于读取的是16位无符号整数，最后只会在AX中,DX一直是10 SUB TMPC[0],30H;ADD AX,WORD PTR TMPC[0]LOOP LOOP1 R_QUIT:POP DX POP CX POP BX POP AX;此时AX为读取的数 JMP R_END R_ERR:POP DX POP CX POP BX POP AX R_END:POP DX POP CX POP BX RET FGETN ENDP SORT PROC;冒泡排序 PUSH AX PUSH BX PUSH CX PUSH DX MOV CX,N DEC CX;外循环次数为N-1 SLOOP1:PUSH CX;把外循环计数器存下来;-------------------MOV BX,0 SLOOP2:;外循环计数器也是内循环次数 MOV AX,NUMS[BX]INC BX INC BX MOV DX,NUMS[BX]CMP AX,DX JZ NOEXCHANGE;AX=DX JC NOEXCHANGE;AX<DX EXCHANGE:;AX>DX MOV NUMS[BX],AX DEC BX DEC BX MOV NUMS[BX],DX INC BX INC BX NOEXCHANGE:LOOP SLOOP2;-------------------POP CX;取出外循环计数器 LOOP SLOOP1 POP DX POP CX POP BX POP AX RET SORT ENDP.STARTUP;打开文件 LEA DX,FILENAME;MOV DX,OFFSET _FILENAME MOV AH,3DH MOV AL,2 INT 21H JC ERROR;出错;---------MOV FILEHANDLE,AX;保存句柄 CALL FGETN;读取第一个数，表示接下来有几个数据 MOV N,AX CALL PRINTN PRINTC 0DH PRINTC 0AH MOV BX,0 MOV CX,N FREAD:CALL FGETN MOV NUMS[BX],AX CALL PRINTN PRINTC 20H INC BX INC BX;由于是字节，下标每次要加2 LOOP FREAD;---------CALL SORT;---------PRINTS MSG_SUCCESS PRINTC 0DH PRINTC 0AH MOV CX,N MOV BX,0 PRINTRESULT:MOV AX,NUMS[BX]CALL PRINTN PRINTC 20H INC BX INC BX LOOP PRINTRESULT JMP TOEND;---------ERROR:PRINTS MSG_ERR CALL PRINTN;打印AX存储的错误码 TOEND:MOV AH,4CH;按任意键结束 INT 21H.EXIT END ```","tags":["MCPS"],"categories":[]},{"title":"算法基础上机实验二 红黑树维护算法及其区间树应用","url":"/s/p/9uqdc0/","content":"###题目 红黑树维护算法及其区间树应用###算法设计####（一）红黑树 红黑树是一棵二叉搜索树，是众多平衡二叉树中的一种，它可以保证在最坏情况下基本操作的时间复杂度为O(lgn)红黑树的每个结点包含5个属性：color、key、left、right、parent，分别表示颜色、关键字、左孩子、右孩子、父亲。 ![img](lab2/clip_image002.jpg)红黑树有以下性质： ① 每个节点必须为红色或黑色； ② 根为黑色； ③ 树中的nil叶子为黑； ④ 若节点为红，则其两个孩子必为黑； ⑤ 每节点到其后代叶子的所有路径含有同样多的黑节点； <!--more--> 红黑树的基本操作：#####（1）左旋/右旋 这是一种能保持二叉搜索树性质的局部操作。 ![img](lab2/clip_image004.jpg)以左旋为例，操作顺序如下： ① y←right[x]//记录指向y节点的指针 ② right[x]←left[y],p[left[y]]←x//β连到x右 ③ parent[y]←parent[x],parent[x]的左或右指针指向y//y连到p[x]④ left[y]←x,parent[x]←y//x连到y左 ![img](lab2/clip_image006.jpg)​ 该操作的时间复杂度T(n)=O(1)#####（2）插入 这个操作是在二叉搜索树的插入操作上略作修改，分为三步： ①将z节点按BST树规则插入红黑树中，z是叶子节点； ②将z涂红； ③调整使其满足红黑树的性质； 调整过程分析如下： Z插入之后，为红色结点，其两个孩子为黑色NIL，满足性质1，3，5，可能违反性质2，4，即z是（红色）根或者z的父亲是红色。 调整方案：通过旋转和改变颜色，自下而上调整（z进行上溯），使树满足红黑树性质。(1)若z为根，将其涂黑；(2)若z为非根，则p[z]存在 ①若p[z]为黑，无需调整 ②若p[z]为红，违反性质4，则需调整 具体来说分为6种情况： case1~3为z的双亲p[z]是其祖父p[p[z]]的左孩子，*case4~6为z的双亲p[z]是其祖父p[p[z]]的右孩子（与case1~3对称）。*-Case1:z的叔叔y是红色，这时通过调整叔叔、父亲和祖父的颜色，将违反性质的结点上移，调整最多至根。若红色传播到根，将根涂黑，则树的黑高增1 ![img](lab2/clip_image008.jpg)-Case 2：当z的叔叔y是黑色，且z是双亲p[z]的右孩子，这种情况通过左旋变换为Case3.-Case 3：当z的叔叔y是黑色，且z是双亲p[z]的左孩子 ![img](lab2/clip_image010.jpg)调整算法的时间：O(logn)整个插入算法的时间：O(logn)#####（3）删除 这个操作将树上的一个结点z删除，然后进行z的孩子的调整，使之满足二叉搜索树的性质，最后，然后红黑树性质被破坏，则需要进行颜色的调整。 首先是对删除结点z进行分类讨论，有3种情况：-Case 1：z为叶子；-Case 2：z只有一个孩子(非空)case 1是case 2的特例，处理模式是一样 处理方式：删除z，连接x。这里x是z的中序后继； ![img](lab2/clip_image012.jpg)-Case 3：z的两个孩子均非空； 处理方式：(1)找z的中序后继即找z的右子树中最左下节点y；(2)删除y，将y的内容copy到z，再将y的右子连到p[y]左下。 ![img](lab2/clip_image014.jpg)最后分析颜色的调整： 删红点不影响，删黑点需要调整。 对于结点x，或是y的唯一孩子，或是哨兵nil[T]。 可以想象将y的黑色涂到x上，于是 ① 若x是根，且原为黑，直接移去多余一层黑色(树黑高减1)，终止； ② 若x原为红，将y的黑色涂到x上，终止； ③ 若x非根节点，且原为黑色，则x为双黑。通过变色、旋转使多余黑色向上传播，直到某个红色节点或传到根； 具体来说，分为8种情况， case 1~4为x是p[x]的左子；*case 5~8为x是p[x]的右子（对称地）*以case1~4为例-Case 1：x的兄弟w是红色（w是红，则 p[x]必黑） 处理方式如图，目标是将情况变成Case2,3,4处理 ![img](lab2/clip_image016.jpg)-Case 2：x的黑兄弟w的两个孩子均为黑 处理方式如图，目标是将 x上移到B，通过A和D的黑色上移 ![img](lab2/clip_image018.jpg)-Case 3：x的黑兄弟w的右子为黑且左子为红 处理方式如图，目标是将case3转为case4 ![img](lab2/clip_image020.jpg)-Case 4：x的黑兄弟w的右子为红(左子为黑或红)x的黑色上移给B，B的原色下移给D，D将黑色下移给C和E，通过旋转解决矛盾点C ![img](lab2/clip_image022.jpg)####（二）区间树 区间树是对红黑树的扩张，其每个结点存储一个区间，包括low和high两个值，其中low作为红黑树的key。 为了实现重叠区间的查找，还需要为每个结点添加一个max域，其值为以该结点为根的子树的所有区间的最大端点。 （1）max值的计算：该节点的区间右端点、左子树max值、右子树max值三者中的最大值。 max值的维护：需要在旋转、插入和删除时进行调整。 ①左旋后，y的max更新为x原来的max，x的max重新按上面的方法计算，时间复杂度为O(1)。 ![img](lab2/clip_image023.jpg)②插入z时，z的max值设为自己区间的右端点，然后对于从根到插入位置的每个结点，如果其max值小于z的max值，则更新为z的max值。时间复杂度为O(logn)。 ③删除z时，如果z只有一个孩子或者没有孩子，则直接从z的父亲开始向上到根结点，依次重新计算max值。如z有左右孩子，在找到z的中序遍历后继y后，从y的父亲开始向上至根结点，依次计算max值。时间复杂度为O(logn)。 （2）重叠区间的查找：x从根结点开始，如果x为nil或待查找的区间与其重叠，则返回x。否则，x更新，如果x左孩子不为nil且max值大于待查找区间的左端点，则x更新为x的左孩子，反之更新为x的右孩子。 时间复杂度为O(logn)###代码 ```c++#include <cstdio>#include <cstdlib> enum Color{RED,BLACK};typedef struct RBTreeNode{struct RBTreeNode*parent;struct RBTreeNode*left;struct RBTreeNode*right;Color color;int key;//low int high;//high int maxep;//子树中区间最大端点}node;class RBTree{public:RBTree();~RBTree();struct RBTreeNode*root;struct RBTreeNode*nil;void Insert(node*z);void Delete(node*z);node*Search(int key);node*IntervalSearch(int low,int high);void Print();bool Overlap(int alow,int ahigh,int blow,int bhigh);void pn(node*x);private:void Updatemaxep(node*x);void Updatemaxep2(node*x);void _Print(node*x,int depth);void LRotate(node*x);void RRotate(node*x);void Insert_fixup(node*z);void Transplant(node*u,node*v);node*Minimum(node*x);void Delete_fixup(node*x);};int max(int a,int b){if(a > b)return a;else return b;}RBTree::RBTree(){this->nil=new node;this->nil->color=BLACK;this->nil->left=NULL;this->nil->right=NULL;this->nil->parent=NULL;this->nil->key=-1;this->nil->high=-1;this->nil->maxep=-1;this->root=this->nil;}RBTree::~RBTree(){delete this->nil;}void RBTree::Updatemaxep(node*x){x->maxep=max(x->high,max(x->left->maxep,x->right->maxep));}void RBTree::LRotate(node*x){//左旋 node*y=x->right;x->right=y->left;if(y->left !=this->nil)y->left->parent=x;y->parent=x->parent;if(x->parent==this->nil)this->root=y;else if(x==x->parent->left)x->parent->left=y;else x->parent->right=y;y->left=x;x->parent=y;y->maxep=x->maxep;//区间树维护maxep Updatemaxep(x);//区间树维护maxep}void RBTree::RRotate(node*x){//右旋 node*y=x->left;x->left=y->right;if(y->right !=this->nil)y->right->parent=x;y->parent=x->parent;if(x->parent==this->nil)this->root=y;else if(x==x->parent->right)x->parent->right=y;else x->parent->left=y;y->right=x;x->parent=y;y->maxep=x->maxep;//区间树维护maxep Updatemaxep(x);//区间树维护maxep}void RBTree::Insert_fixup(node*z){//插入后为保存红黑树性质而作的调整 while(z->parent->color==RED){//父亲是黑则无需调整，父亲是红也保证了父亲存在（不是nil）,并且祖父存在 if(z->parent==z->parent->parent->left){//父亲是祖父的左孩子 node*y=z->parent->parent->right;//记录叔节点 if(y->color==RED){//叔是红 z->parent->color=BLACK;//父亲变黑 y->color=BLACK;//叔变黑 z->parent->parent->color=RED;//祖父变红 z=z->parent->parent;//问题向上转移两层}else if(z==z->parent->right){//叔是黑//z是父亲的右孩子，则对z父亲左旋，并且新的z是原来z的父亲，且是原来z的左孩子，统一按下面的情况处理 z=z->parent;LRotate(z);}else{z->parent->color=BLACK;//父变黑 z->parent->parent->color=RED;//祖变红 RRotate(z->parent->parent);//把黑色父亲旋转到祖父的位置，此时红左孩还是左孩，红祖父变成右孩子}}else{//对称情况，父亲是祖父的右孩子 node*y=z->parent->parent->left;//记录叔节点 if(y->color==RED){//叔是红 z->parent->color=BLACK;//父亲变黑 y->color=BLACK;//叔变黑 z->parent->parent->color=RED;//祖父变红 z=z->parent->parent;//问题向上转移两层}else if(z==z->parent->left){//z是父亲的左孩子，则对z父亲右旋，并且新的z是原来z的父亲，且是原来z的右孩子，统一按下面的情况处理 z=z->parent;RRotate(z);}else{z->parent->color=BLACK;//父变黑 z->parent->parent->color=RED;//祖变红 LRotate(z->parent->parent);//把黑色父亲旋转到祖父的位置，此时红右孩还是右孩，红祖父变成左孩子}}}this->root->color=BLACK;}void RBTree::Insert(node*z){//插入 node*y=this->nil;node*x=this->root;z->left=this->nil;z->right=this->nil;z->color=RED;z->maxep=z->high;//区间树维护maxep while(x !=this->nil){x->maxep=max(x->maxep,z->maxep);//区间树维护maxep,从根到z的路径上的节点更新maxep y=x;if(z->key < x->key)x=x->left;else x=x->right;}z->parent=y;if(y==this->nil)this->root=z;else if(z->key < y->key)y->left=z;else y->right=z;Insert_fixup(z);}node*RBTree::Minimum(node*x){//以x为根的子树中的最小key的节点 while(x->left !=this->nil)x=x->left;return x;}void RBTree::Transplant(node*u,node*v){//以v代替u，这里没有处理u和v的孩子,注意：u/v各自的指向结点并没有改变 if(u->parent==this->nil)//u是根 this->root=v;else if(u==u->parent->left)u->parent->left=v;else u->parent->right=v;v->parent=u->parent;}void RBTree::pn(node*x){printf(\"[%d,%d]|%d(%s)\\n\",x->key,x->high,x->maxep,x->color==RED?\"R\":\"B\");}void RBTree::Delete_fixup(node*x){while(x !=this->root&&x->color==BLACK){if(x==x->parent->left){node*w=x->parent->right;if(w->color==RED){w->color=BLACK;x->parent->color=RED;LRotate(x->parent);w=x->parent->right;}if(w->left->color==BLACK&&w->right->color==BLACK){w->color=RED;x=x->parent;}else{if(w->right->color==BLACK){w->left->color=BLACK;w->color=RED;RRotate(w);w=x->parent->right;}w->color=x->parent->color;x->parent->color=BLACK;w->right->color=BLACK;LRotate(x->parent);x=this->root;}}else{//x==x->parent->right node*w=x->parent->left;if(w->color==RED){w->color=BLACK;x->parent->color=RED;RRotate(x->parent);w=x->parent->left;}if(w->right->color==BLACK&&w->left->color==BLACK){w->color=RED;x=x->parent;}else{if(w->left->color==BLACK){w->right->color=BLACK;w->color=RED;LRotate(w);w=x->parent->left;}w->color=x->parent->color;x->parent->color=BLACK;w->left->color=BLACK;RRotate(x->parent);x=this->root;}}}x->color=BLACK;}void RBTree::Updatemaxep2(node*x){while(x !=this->nil){Updatemaxep(x);x=x->parent;}}void RBTree::Delete(node*z){node*x;node*y=z;Color y_original_color=y->color;if(z->left==this->nil){//没有左孩子或者没有孩子 x=z->right;//可能是空 Transplant(z,z->right);Updatemaxep2(z->parent);}else if(z->right==this->nil){//没有右孩子但有左孩子 x=z->left;Transplant(z,z->left);Updatemaxep2(z->parent);}//上面两种情况，直接删除z,以z的一个孩子代替z else{//有左右孩子 y=Minimum(z->right);//寻找z在中序遍历中的下一个结点，以此为新的y，并且y没有左孩子 y_original_color=y->color;node*g=y->parent;x=y->right;if(y->parent==z){//y的父亲是z，则y就是z的右孩子 x->parent=y;}else{//y是z的右子树中最小者，但不是z的右孩子//if(y->right !=this->nil)Transplant(y,y->right);y->right=z->right;y->right->parent=y;}Transplant(z,y);//用y代替z y->left=z->left;y->left->parent=y;y->color=z->color;Updatemaxep2(g);}if(y_original_color==BLACK)Delete_fixup(x);}void RBTree::_Print(node*x,int depth){if(x !=this->nil){_Print(x->right,depth+1);for(int i=0;i < depth-1;i++){printf(\" \");}printf(\"[%d,%d]|%d(%s)\\n\",x->key,x->high,x->maxep,x->color==RED?\"R\":\"B\");_Print(x->left,depth+1);}}void RBTree::Print(){node*p=this->root;printf(\"------------------------------------------------------------------------------------\\n\");_Print(this->root,1);printf(\"------------------------------------------------------------------------------------\\n\");}node*RBTree::Search(int key){node*x=this->root;while(x !=this->nil&&key !=x->key)if(key < x->key)x=x->left;else x=x->right;return x;}bool RBTree::Overlap(int alow,int ahigh,int blow,int bhigh){if(ahigh < blow||alow > bhigh)//a&b do not overlap return 0;return 1;}node*RBTree::IntervalSearch(int low,int high){node*x=this->root;while(x !=this->nil&&!Overlap(low,high,x->key,x->high)){if(x->left !=this->nil&&x->left->maxep >=low)x=x->left;else x=x->right;}return x;}int main(){int sel;int i,n;char path[128]=\"in2.txt\";int low,high;node*tmpnode;RBTree*T=new RBTree();while(1){printf(\"MENU:\\n1-File\\n2-Insert\\n3-Delete\\n4-Find\\n5-Print\\n6-Exit\\nSel:\");scanf(\"%d\",&sel);switch(sel){case 1:{//printf(\"Input file path:\");//scanf(\"%s\",path);FILE*fp=fopen(path,\"r\");fscanf(fp,\"%d\",&n);for(i=1;i<=n;i++){node*p=new node;fscanf(fp,\"%d%d\",&(p->key),&(p->high));T->Insert(p);T->Print();}fclose(fp);break;}case 2:{printf(\"Input low and high:\");scanf(\"%d%d\",&low,&high);node*p=new node;p->key=low;p->high=high;T->Insert(p);T->Print();break;}case 3:{printf(\"Input low:\");scanf(\"%d\",&low);if((tmpnode=T->Search(low))==T->nil){printf(\"can't find this node.\\n\");break;}//printf(\"%d,%d,%d\",tmpnode->key,tmpnode->high,tmpnode->maxep);T->Delete(tmpnode);T->Print();break;}case 4:{printf(\"Input low and high:\");scanf(\"%d%d\",&low,&high);if((tmpnode=T->IntervalSearch(low,high))==T->nil)printf(\"can't find.\\n\");else printf(\"[%d,%d]\\n\",tmpnode->key,tmpnode->high);break;}case 5:{T->Print();break;}case 6:{return 0;}}}delete T;return 0;}```###总结 这次实验让我比较深入地了解了红黑树的性质和操作及其应用。红黑树是高级数据结构，它可以保证在最坏情况下基本操作的时间复杂度为O(lgn)，但编写的代码较为复杂，需要分清楚每种情况及其对应的处理，课本种对情况的分类十分精炼，有的情况不是并列的，不同的情况可能是相互转换的关系，需要仔细思考。","tags":["Algorithm"],"categories":[]},{"title":"汇编上机题1","url":"/s/p/9uf9c0/","content":"###题目 > 把1~36的自然数按行顺序存入一个6*6的二维数组中，然后打印出该数组的左下半三角 <!--more-->###代码 ```assembly.MODEL SMALL.DATA D136 DB 36 DUP(0).CODE PROC PRINT_N;打印换行符 PUSH AX PUSH DX MOV AH,2 MOV DL,0Dh INT 21h MOV DL,0Ah INT 21h POP DX POP AX RET ENDP PROC PRINTC;打印DL的字符 PUSH AX MOV AH,2 INT 21h POP AX RET ENDP.STARTUP;初始化数据 MOV CX,36 MOV BX,36 INIT_LOOP:DEC BX MOV D136[BX],CL LOOP INIT_LOOP MOV CX,0 MAIN:MOV AL,6;AL=6 MUL CH;AL=6*CH ADD AL,CL;AL=AL+CL AL为要打印的数的下标 MOV BX,AX MOV AL,D136[BX];AL为要打印的数 MOV DL,10 DIV DL;AL/10,商在AL,余数在AH MOV DL,AL;十位 ADD DL,30H;转为字符 CALL PRINTC MOV DL,AH;个位 ADD DL,30H;转为字符 CALL PRINTC CMP CH,CL JZ NEXTLINE;行结束，进行判断 MOV DL,32;否则打印空格 CALL PRINTC INC CL JMP MAIN NEXTLINE:CALL PRINT_N MOV CL,0;列=0 INC CH;行++CMP CH,6;CH<6则继续下一行 JNZ MAIN.EXIT END ```","tags":["MCPS"],"categories":[]},{"title":"算法基础上机实验一 求平面上n个顶点的最近点对问题","url":"/s/p/9udeo0/","content":"###题目 求平面上n个顶点的最近点对问题###算法设计**分治法**#####1．先考虑一维的情形，即线段上最近点对。 用x轴上某个点m将S划分为2个子集S1和S2，使得S1={x∈S|x≤m}；S2={x∈S|x>m}，S1∪S2=S ，S1∩S2=Φ，则线段上最近点对为以下三者中的距离最小者： （1）左半边S1的最近点对 （2）右半边S2的最近点对 （3）跨越分点m的最近点对 ![img](lab1/clip_image002.png)左半边S1的最近点对和右半边S2的最近点对的求解可以递归地调用该过程。而跨越分点m的最近点对，我们可以将S1中的一点与S2中的每一点计算距离，但这将花费O(n^2)。 事实上，通过求解左右两个子问题，我们已经得到一个当前最近点对的距离δ，在S1中，任何一个宽度为δ的区间内只分布着一个点，否则，存在两点距离小于δ，同理，S2中也是。因此，我们只需要考虑[m-δ,m+δ]区间内的点对距离，在[m-δ,m]如果有点，只能有一个点，这个点就是S1中距离m最近的点。区间[m,m+δ]同理。如果这两个点都存在，则计算距离，并与δ比较，因此，只需要O(n)时间完成问题的合并。 m点的选取问题：任意选取分割点m，有可能造成划分出的子集S1和S2的不平衡，最坏情况下有递归式： T(n)=T(n-1)+O(n)其解为T(n)=O(n^2)如果我们恰当地选取m，是S1和S2中点的数量基本相同，则有递归式： T(n)=2T(n/2)+O(n)其解为T(n)=O(nlogn)为了选取m，我们可以事先对这些点排序，取m为下标中位数的点的坐标。 <!--more-->#####2.考虑二维的情况，即本次实验求解的问题。 类似一维情况，将平面分为两个半平面，使两边各分布约一半的点，为了确定分割线x=m，先对所有点按x坐标进行排序，取m为下标中位数附近两个点的x的坐标的平均值。 递归地在S1和S2上解最接近点对问题，我们分别得到S1和S2中的最近点对的距离δ1和δ2。现设δ=min(δ1,δ2)。 现在考虑两个点分别在S1和S2中的情况。类似一维的情况，我们只需要考虑条带区域[m-δ,m]和[m,m+δ]中点对的距离，记这两个区域为P1和P2。 ![img](lab1/clip_image004.jpg)在一维的时候，距分割点距离为δ的2个区间P1[m-δ,m]和P2[m,m+δ]中最多各有S中一个点，因而这两个点成为唯一的未检查过的最接近点对候选者。但在二维情况下，P1[m-δ,m]中可能存在多个点，并且他们的距离大于δ，P2[m,m+δ]同理。因此，最坏情况下，S1中的点可能都在P1[m-δ,m]中，S2中的点可能都在P2[m,m+δ]中，这样就需要花费O(n^2)来合并问题（检查跨越P1、P2的所有点对）。 事实上，我们不必检查如此多的点对，考虑P1中任意一点p,它若与P2中的点q构成最接近点对的候选者，则必有d(p,q)< δ。显然，这样的点只会分布在一个δ×2δ的矩形R中，如下图。 ![img](lab1/clip_image006.jpg)由δ的意义可知P2中任何2个S中的点的距离都不小于δ。我们可以将矩形R的长为2δ的边3等分，将它的长为δ的边2等分，形成6个（δ/2）×（2δ/3）的矩形。 ![img](lab1/clip_image008.jpg)若矩形R中有多于6个S中的点，则由抽屉原理易知至少有一个（δ/2）×（2δ/3）的小矩形中有2个以上S中的点。设a,b是这样2个点，它们位于同一小矩形中，则d(a,b)≤sqrt((δ/2)^2+(2δ/3)^2)<δ ，这与δ的意义相矛盾。 由此可以推出矩形R中最多只有6个S中的点，极端情形如下图。 ![img](lab1/clip_image010.jpg)因此，在分治法的合并步骤中，我们最多只需要检查6×n/2=3n对候选者，而不是O(n^2)对候选者。但这不意味着我们可以在O(n)时间内完成分治法的合并步骤。因为我们并不确切地知道要检查哪6个点。 为了解决这个问题，我们需要将P1和P2中的点分别按其y坐标排序，则对P1中每一点最多只要检查P2中排好序的相继6个点。排序花费的时间为O(nlogn)。这样得到递归式 T(n)=2T(n/2)+O(nlogn)其解为T(n)=O(nlognlogn)一种改进的方法是，在最开始的时候，在按x排序后，然后确定完m的坐标后，对所有点按y坐标排序，这样就不用在递归函数中使用排序，合并问题的时间取决于检查跨P1、P2点对的时间O(n)，有递归式 T(n)=2T(n/2)+O(n)其解为T(n)=O(nlogn)###代码 ```c++#include <cstdio>#include <cstdlib>#include <ctime>#include <algorithm>#define INF 99999999#define MAX_DOT_NUM 100000 using namespace std;typedef struct _dot{double x;double y;}dot;typedef struct _dpair{double dis;dot dota;dot dotb;}dpair;int n;dot*dots=new dot[MAX_DOT_NUM+1];dpair dpairmin(dpair dp1,dpair dp2){return dp1.dis<dp2.dis?dp1:dp2;}double distance(const dot&a,const dot&b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}double cmp(const dot&a,const dot&b){return a.x<b.x||a.x==b.x&&a.y<b.y;}double cmpy(const dot&a,const dot&b){return a.y<b.y;}dpair minDistance(int l,int h){dpair tmpdp;if(l==h){tmpdp.dis=INF;return tmpdp;}if(l==h-1){tmpdp.dis=distance(dots[l],dots[h]);tmpdp.dota=dots[l];tmpdp.dotb=dots[h];return tmpdp;}int m=(l+h)/2;dpair dp1=minDistance(l,m);dpair dp2=minDistance(m+1,h);dpair dp=dpairmin(dp1,dp2);dot*ldots=new dot[MAX_DOT_NUM/2+2];dot*rdots=new dot[MAX_DOT_NUM/2+2];double xm=(dots[m].x+dots[m+1].x)/2;int k,i,nl,nr;for(k=m;k>=l;k--){if(dots[k].x>=xm-dp.dis)ldots[m-k+1]=dots[k];else break;}nl=m-k;sort(ldots+1,ldots+nl+1,cmpy);for(i=m+1;i<=h;i++){if(dots[i].x<=xm+dp.dis)rdots[i-m]=dots[i];else break;}nr=i-m-1;sort(rdots+1,rdots+nr+1,cmpy);int istart=1;for(k=1;k<=nl;k++){for(i=istart;i<=nr;i++){if(rdots[i].y-ldots[k].y<=dp.dis){tmpdp.dis=distance(ldots[k],rdots[i]);tmpdp.dota=ldots[k];tmpdp.dotb=rdots[i];dp=dpairmin(dp,tmpdp);}else{istart=i-6<1?1:i-6;break;}}}delete[]ldots;delete[]rdots;return dp;}int main(){int sel;int i;char path[128];srand(time(NULL));printf(\"MENU:\\n1-INPUT\\n2-FILE\\n3-RANDOM\\n\");scanf(\"%d\",&sel);switch(sel){case 1:{printf(\"Input dots,the num of dots 'n' in first line,the next n lines are 'x' and 'y' for each dots.\\n\");scanf(\"%d\",&n);for(i=1;i<=n;i++)scanf(\"%lf%lf\",&(dots[i].x),&(dots[i].y));break;}case 2:{printf(\"Input file path,the data format is same as 1-INPUT.\\nFile path:\");scanf(\"%s\",path);FILE*fp=fopen(path,\"r\");fscanf(fp,\"%d\",&n);for(i=1;i<=n;i++)fscanf(fp,\"%lf%lf\",&(dots[i].x),&(dots[i].y));fclose(fp);break;}case 3:{printf(\"Input n,the program will generate n dots randomly.\\nn:\");scanf(\"%d\",&n);for(i=1;i<=n;i++){dots[i].x=rand()%100;dots[i].y=rand()%100;}break;}}sort(dots+1,dots+n+1,cmp);dpair dp=minDistance(1,n);printf(\"(%lf,%lf)and(%lf,%lf)is dot pair with the min distance:%lf.\",dp.dota.x,dp.dota.y,dp.dotb.x,dp.dotb.y,dp.dis);return 0;}```","tags":["Algorithm"],"categories":[]},{"title":"学习与遗忘","url":"/s/p/9tlmo0/","content":"####缘起 之前一位大一的学弟问我微积分作业，我发现当时觉得还算简单的题，现在竟然已经不会做了。 而且每当考试前我都会发现，平时努力记下的知识，大部分已经生疏了。 我一直在想，如果所有的知识都将被遗忘，那么学习的意义在哪呢？####学习？记忆?学习多年，我相信大部分人和我一样，在认知上认为记忆只是学习的一步，但行动上记忆几乎成为学习的全部，无论是记笔记或是所谓的错题本，都是强行以记忆代替学习。 这些方法固然有效，在信息量小的时候增加强化次数以永久记忆，但在信息爆炸的现在，如何？ 曾经我和同学探讨这个问题。 > “你们是如何记住那些复杂的公式呢？” > > “记不住，马上推导的。” > > “如果过程很繁杂，一时推导不出来呢？” > > “那么就稍微思考下，查些资料。” > > “如何记得推导过程？” > > “学会了就记住了呀” 这似乎陷入了死循环，如果很难记住一件事，那就需要记住这件事的前因后果。####遗忘 遗忘是我们最为讨厌的事情，我们憎恨因为遗忘让我们误了多少重要的事件，但有些痛苦的记忆却也因为始终不能遗忘而如附骨之蛆，让我们长期沉浸在痛苦中。所以，遗忘的所有这些究竟是因为什么呢？ 百度百科给出的定义 > 遗忘是对识记过的材料不能再认与回忆，或者错误的再认与回忆，是一种记忆的丧失。遗忘分为暂时性遗忘和永久性遗忘，前者指在适宜条件下还可能恢复记忆的遗忘；后者指不经重新学习就不可能恢复记忆的遗忘。 Wikipedia给出的定义 >**Forgetting**or**disremembering**is the apparent loss or modification of information already encoded and stored in an individual's long-term memory.如此，遗忘是大脑的本能，它有助于调和新旧知识。 知识会被遗忘，技能也会生疏，他们是`强化次数`和`时间`的函数。####临界点 回忆过去，会发现那些小时候背诵的诗文始终不会忘记，即使有些生疏，只要有些许提示或刺激，你就能很快记忆起来，这就是上面提到的`暂时性遗忘`，因为强化次数已经足够多。相反，对于那些考前恶补的知识，只有一次强化，不久之后便迅速忘记，这就是`永久性遗忘`。如果想要重新回忆起，几乎就是重新学习了。 那么，恰当地选择多个时间点进行强化，能事半功倍，艾宾浩斯遗忘曲线给出了一些似乎可行的时间点。####学习的意义 关于记忆的问题，目前没有太多定论。这是自然规律，无法抗拒。这里不作太多讨论了。 我们学习总是有目的，或是记住各种知识点，获取各种技能提高自己的能力，亦或是显摆？...但是时间有限，要考虑性价比问题。 我们总是习惯于学习各种花哨的， 包装了的， 需要大量机械记忆的知识，比如某些现成工具的各种参数，某些标准的具体细节。或许这些东西对我们当前的工作特别重要，稍微的输入就能带来一时的快感。 那么，长久呢？未来还会有更多的工具，更多的标准。 我有时也会陷入这种短期的，低思考密度的诱惑陷阱。 所以，我以后学习应该学习更加基础，原理性的东西。 当然，有人会说，如果你学习使用那些现成的部分，那么真的需要用时，还是要花时间的。 是啊，这时候就需要快速学习能力了。 这和核心知识的积淀一样重要。 我想这就是一个人的核心竞争力所在吧。","tags":["感想"],"categories":[]},{"title":"计算机组成原理上机实验7 流水线CPU","url":"/s/p/9mnmo0/","content":"##实验目的###设计一个MIPS指令集的CPU，####1、 基本要求： a)多周期 b)包含16条指令 i.add addi addu sub subu ii.and andi or nor xor iii.bgtz bne j jr iv.lw sw####2、 扩展要求 a)在16条的基础上，增加其他指令 b)实现中断功能 c)实现流水 d)实现下载##实验平台####EDA工具为ISE14.7，开发板型号为Digilent的Nexys3，FPGA型号为Spartan-6 XC6SLX16-CS324。##使用部件####开发板上的开关，7段数码管和按钮。##最终实现功能####1、实现五段流水线####2、实现完全转发和冒险检测####3、实现36条指令####4、实现下载并在数码管上动态显示内存 <!--more-->##详细设计过程###1、 MIPS指令格式 MIPS-IV指令集标准下的指令长度为32位，分为R型、I型和J型指令 ![](lab7_Pipeline-CPU/pic1.png)R-Tpye ![](lab7_Pipeline-CPU/pic2.png)I-Tpye ![](lab7_Pipeline-CPU/pic3.png)J-Tpye 它们的共同部分是26-31位的Op码，用来区分不同的指令，其中 （1）R-Type的指令Op=000000，再根据0-5位的Funct部分区分不同指令 （2）I-Type的指令0-15位为立即数，位扩展后用于直接计算或者访存和跳转偏移地址。Op=000001的I-Type指令，根据Rt的不同来区分。 （3）J-Type的指令除了Op之外，0-25位为立即数，位扩展后作为跳转地址偏移。 本次实现的36条指令，详细格式如下表|**Instr**|**31-26**|**25-21**|**20-16**|**15-11**|**10-6**|**5-0**|**备注**||---|---|---|---|---|---|---|---||**op**|**rs**|**rt**|**rd**|**shamt**|**func**||SLL|000000|-|`$2`|`$1`|shamt|000000|`$1`=`$2`<<shamt||SRL|-|`$2`|`$1`|shamt|000010|`$1`=`$2`>>shamt||SRA|-|`$2`|`$1`|shamt|000011|`$1`=`$2`>>>shamt||SLLV|`$3`|`$2`|`$1`|-|000100|`$1`=`$2`<<`$3`||SRLV|`$3`|`$2`|`$1`|-|000110|`$1`=`$2`>>`$3`||SRAV|`$3`|`$2`|`$1`|-|000111|`$1`=`$2`>>>`$3`||JR|`$1`|-|-|-|001000|PC=`$1`||MOVZ|`$3`|`$2`|`$1`||001010|Set `$t1`=`$t2` if `$t3` is zero||MOVN|`$3`|`$2`|`$1`||001011|Set `$t1`=`$t2` if `$t3` is not zero||ADD|`$2`|`$3`|`$1`|-|100000|`$1`=`$2`+`$3`||ADDU|`$2`|`$3`|`$1`|-|100001|`$1`=`$2`+`$3`(unsigned)||SUB|`$2`|`$3`|`$1`|-|100010|`$1`=`$2`-`$3`||SUBU|`$2`|`$3`|`$1`|-|100011|`$1`=`$2`-`$3`(unsigned)||AND|`$2`|`$3`|`$1`|-|100100|`$1`=`$2` and `$3`||OR|`$2`|`$3`|`$1`|-|100101|`$1`=`$2` or `$3`||XOR|`$2`|`$3`|`$1`|-|100110|`$1`=`$2` xor `$3`||NOR|`$2`|`$3`|`$1`|-|100111|`$1`=`$2` nor `$3`||SLT|`$2`|`$3`|`$1`|-|101010|if(`$2`<`$3`)`$1`=1 else `$1`=0||SLTU|`$2`|`$3`|`$1`|-|101011|if(`$2`<`$3`)`$1`=1 else `$1`=0(unsigned)||BLTZ|000001|`$1`|00000|offset|if(`$1`<0)PC=PC+4+(sign-extend)offset<<2||BGEZ|`$1`|00001|offset|if(`$1`>=0)PC=PC+4+(sign-extend)offset<<2||J|000010|immediate|PC=PC[31:28]+immediate<<2||BEQ|000100|`$1`|`$2`|offset|if(`$1`==`$2`)PC=PC+4+(sign-extend)offset<<2||BNE|000101|`$1`|`$2`|offset|if(`$1`!=`$2`)PC=PC+4+(sign-extend)offset<<2||BLEZ|000110|`$1`|-|offset|if(`$1`<=0)PC=PC+4+(sign-extend)offset<<2||BGTZ|000111|`$1`|-|offset|if(`$1`>0)PC=PC+4+(sign-extend)offset<<2||ADDI|001000|`$2`|`$1`|immediate|`$1`=`$2`+(sign-extend)immediate||ADDIU|001001|`$2`|`$1`|immediate|`$1`(unsigned)=`$2`+(sign-extend)immediate||SLTI|001010|`$2`|`$1`|immediate|if(`$2`<(sign-extend)immediate)`$1`=1 else `$1`=0||SLTIU|001011|`$2`|`$1`|immediate|if(`$2`<(sign-extend)immediate)`$1`=1 else `$1`=0||ANDI|001100|`$2`|`$1`|immediate|`$1`=`$2` and(zero-extend)immediate||ORI|001101|`$2`|`$1`|immediate|`$1`=`$2` or(zero-extend)immediate||XORI|001110|`$2`|`$1`|immediate|`$1`=`$2` xor(zero-extend)immediate||LUI|001111|-|`$1`|immediate|`$1`=immediate*65536||LW|100011|`$2`|`$1`|immediate|`$1`=memory[`$2`+10]||SW|101011|`$2`|`$1`|immediate|memory[`$2`+10]=`$1`|###2、 整体设计####(1)分为五个流水段IF、ID、EX、MEM、WB。####(2)clk上升沿为每段的开始，每段长度为一个clk。####(3)每段的相关模块可以和clk上升沿同步也可以与clk下降沿同步。####(4)甘特图如下 ![](lab7_Pipeline-CPU/pic4.png)####(5)详细数据通路图如下 ![](lab7_Pipeline-CPU/pic5.jpg)###3、 各模块设计，主要有以下几个模块####a)alu模块——算术逻辑单元|alu.v|||||---||输入/输出|宽度|信号名|说明||input|[31:0]|alu_a|无符号型的操作数a，如果有负数，是以补码存储||input|[31:0]|alu_b,|无符号型的操作数b，如果有负数，是以补码存储||input|[4:0]|alu_op,|运算类型||output|[31:0]|alu_out|无符号型的运算结果，如果有负数，是以补码存储|alu模块完成大部分R型指令的计算，case判断alu_op的值，使用使用verilog语言中的各运算符完成运算。 这里应该注意的是add和addu的实现是一样的，这是因为当操作数都是补码表示时，符号可以直接参与运算，两条指令的区别在于，add视结果为有符号，因此如果要实现中断功能，就需要判断是否溢出。具体方法是alu_a与alu_b符号同号时，alu_out与它们异号，则表示溢出。 另外，还需要注意slt的实现，比较大小时，不能使用alu_a-alu_b>0，因为它们都是无符号数，相减结果认为无符号数，而无符号数>0是恒成立的。####b)regfile模块——寄存器文件|regfile.v|||||---||输入/输出|宽度|信号名|说明||input|[0:0]|clk|时钟沿||input|[0:0]|rst_n|复位信号，低电平有效||input|[4:0]|rAddr1|读地址1||output|[31:0]|rDout1|读数据1||input|[4:0]|rAddr2|读地址2||output|[31:0]|rDout2|读数据2||input|[4:0]|wAddr|写地址||input|[31:0]|wDin|写数据||input|[0:0]|wEna|写使能，高电平有效|这个模块实现了一个32个32位宽的寄存器组，有两个读端口，一个写端口，读取数据为异步读，写入数据在时钟上升沿且写使能有效，使用非阻塞赋值。####c)mux模块和mux4模块——2路和4路选择器|mux.v|||||---||输入/输出|宽度|信号名|说明||input|[0:0]|sel|选择信号||input|[WIDTH-1:0]|d0|选择数据1||input|[WIDTH-1:0]|d1|选择数据2||output|[WIDTH-1:0]|out|输出|####d)IP核生成的DMem模块和IMem模块——存放数据段和代码段 Mem是同步读，同步写，且由指定coe文件初始化，coe文件的内容是16进制文本，由Mars编译汇编代码生成。####e)IFID模块——IF段和ID段之间的寄存器|IFID.v|||||---||输入/输出|宽度|信号名|说明||input|[0:0]|clk|时钟沿||input|[0:0]|en|使能信号，高电平有效||input|[0:0]|flush|清空信号，高电平有效||input|[31:0]|PCPlus_in|IF段的PC+4||input|[31:0]|IMemout_in|IF段的Imem输出||output|[31:0]|PCPlus_out|ID段的PC+4||output|[31:0]|IMemout_out|ID段的Imem输出|####f)IDEX模块——ID段和EX段之间的寄存器|IDEX.v|||||---||输入/输出|宽度|信号名|说明||input|[0:0]|clk|时钟沿||input|[0:0]|en|使能信号高电平有效||input|[0:0]|flush|清空信号高电平有效||input|[31:0]|PCPlus_in|ID段的PCPlus||input|[31:0]|RegRdout1_in|ID段的RegRdout1||input|[31:0]|RegRdout2_in|ID段的RegRdout2||input|[31:0]|IMMSignExtended_in|ID段的IMMSignExtended||input|[31:0]|IMMZeroExtended_in|ID段的IMMZeroExtended||input|[31:0]|ShamtZeroExtended_in|ID段的ShamtZeroExtended||input|[4:0]|Rs_in|ID段的Rs||input|[4:0]|Rt_in|ID段的Rt||input|[4:0]|RegWtaddr_in|ID段的RegWtaddr||output|[31:0]|PCPlus_out|EX段的PCPlus||output|[31:0]|RegRdout1_out|EX段的RegRdout1||output|[31:0]|RegRdout2_out|EX段的RegRdout2||output|[31:0]|IMMSignExtended_out|EX段的IMMSignExtended||output|[31:0]|IMMZeroExtended_out|EX段的IMMZeroExtended||output|[31:0]|ShamtZeroExtended_out|EX段的ShamtZeroExtended||output|[4:0]|Rs_out|EX段的Rs||output|[4:0]|Rt_out|EX段的Rt||output|[4:0]|RegWtaddr_out|EX段的RegWtaddr||input|[0:0]|RegDst_in|ID段的RegDst||input|[0:0]|ALUSrcASel_in|ID段的ALUSrcASel||input|[1:0]|ALUSrcBSel_in|ID段的ALUSrcBSel||input|[4:0]|ALUControl_in|ID段的ALUControl||input|[0:0]|DMemRead_in|ID段的DMemRead||input|[0:0]|DMemWrite_in|ID段的DMemWrite||input|[0:0]|DMemtoReg_in|ID段的DMemtoReg||input|[0:0]|RegWrite_in|ID段的RegWrite||output|[0:0]|RegDst_out|EX段的RegDst||output|[0:0]|ALUSrcASel_out|EX段的ALUSrcASel||output|[1:0]|ALUSrcBSel_out|EX段的ALUSrcBSel||output|[4:0]|ALUControl_out|EX段的ALUControl||output|[0:0]|DMemRead_out|EX段的DMemRead||output|[0:0]|DMemWrite_out|EX段的DMemWrite||output|[0:0]|DMemtoReg_out|EX段的DMemtoReg||output|[0:0]|RegWrite_out|EX段的RegWrite|####g)EXMEM模块——EX段和MEM段之间的寄存器|EXMEM.v|||||---||输入/输出|宽度|信号名|说明||input|[0:0]|clk|时钟沿||input|[0:0]|en|使能信号高电平有效||input|[0:0]|flush|清空信号高电平有效||input|[31:0]|ALUResult_in|EX段的ALUResult||input|[31:0]|DMemin_in|EX的Dmemin||input|[4:0]|RegWtaddr_in|EX的RegWtaddr||output|[31:0]|ALUResult_out|MEM段的ALUResult||output|[31:0]|DMemin_out|MEM的Dmemin||output|[4:0]|RegWtaddr_out|MEM的RegWtaddr||input|[0:0]|DMemRead_in|EX段的DMemRead||input|[0:0]|DMemWrite_in|EX段的DMemWrite||input|[0:0]|DMemtoReg_in|EX段的DMemtoReg||input|[0:0]|RegWrite_in|EX段的RegWrite||output|[0:0]|DMemRead_out|MEM段的DMemRead||output|[0:0]|DMemWrite_out|MEM段的DMemWrite||output|[0:0]|DMemtoReg_out|MEM段的DMemtoReg||output|[0:0]|RegWrite_out|MEM段的RegWrite|####h)MEMWB模块——MEM段和WB段之间的寄存器|MEMWB.v|||||---||输入/输出|宽度|信号名|说明||input|[0:0]|clk|时钟沿||input|[0:0]|en|使能信号高电平有效||input|[0:0]|flush|清空信号高电平有效||input|[31:0]|ALUResult_in|MEM段的ALUResult||input|[31:0]|DMemout_in|MEM段的Dmemout||input|[4:0]|RegWtaddr_in|MEM段的RegWtaddr||output|[31:0]|ALUResult_out|WB段的ALUResult||output|[31:0]|DMemout_out|WB段的DMemout||output|[4:0]|RegWtaddr_out|WB段的RegWtaddr||input|[0:0]|DMemtoReg_in|MEM段的DMemtoReg||input|[0:0]|RegWrite_in|MEM段的RegWrite||output|[0:0]|DMemtoReg_out|WB段的DMemtoReg||output|[0:0]|RegWrite_out|WB段的RegWrite|####i)dff模块——D触发器，用于各个段寄存器|dff.v|||||---||输入/输出|宽度|信号名|说明||input|[0:0]|clk|时钟沿||input|[0:0]|en|使能信号高电平有效||input|[0:0]|rst|复位信号高电平有效||input|[WIDTH-1:0]|datain|输入数据||output|[WIDTH-1:0]|dataout|输出数据|这是一个通用的D触发器，位数作为参数可根据需要变化，用一个always在时钟沿触发来实现非阻塞赋值。####j)compare模块——用于分支信号的判断|dff.v|||||---||输入/输出|宽度|信号名|说明||input|[31:0]|a,|有符号数a，需加前缀signed||input|[31:0]|b,|有符号数b，需加前缀signed||output|[1:0]|res|比较结果|a等于b返回2’b01，a小于b返回2’b00，a大于b返回2’b10，比较均是基于有符号数。####k)SignExtended模块——立即数符号扩展 过于简单，直接在top中实现了。####l)ZeroExtended模块——立即数无符号扩展 过于简单，直接在top中实现了。####m)forward模块——旁路前推模块，实现转发|forward.v|||||---||输入/输出|宽度|信号名|说明||input|[4:0]|Rs_EX|EX段的Rs||input|[4:0]|Rt_EX|EX段的Rt||input|[0:0]|RegWrite_MEM|MEM段的RegWrite||input|[0:0]|RegWrite_WB|WB段的RegWrite||input|[4:0]|RegWtaddr_MEM|MEM段的RegWtaddr||input|[4:0]|RegWtaddr_WB|WB段的RegWtaddr||output|[1:0]|RegRdout1Sel_Forward_EX|EX段的RegRdout1Sel_Forward||output|[1:0]|RegRdout2Sel_Forward_EX|EX段的RegRdout2Sel_Forward|这个模块实现从DMem输出到ALU输入以及ALU输出到ALU输入的转发。 ![](lab7_Pipeline-CPU/pic6.png)![](lab7_Pipeline-CPU/pic7.png)####n)hazard模块——冒险检测模块，实现插入气泡|hazard.v|||||---||输入/输出|宽度|信号名|说明||input|[4:0]|Rs_ID|ID段的Rs||input|[4:0]|Rt_ID|ID段的Rt||input|[4:0]|RegWtaddr_EX|EX段的RegWtaddr||input|[0:0]|DMemRead_EX|EX段的DMemRead||output|[0:0]|PCEn|允许PC更新，高电平有效||output|[0:0]|IF_ID_En|允许IFID更新，高电平有效||output|[0:0]|ID_EX_Flush|IDEX清空，高电平有效|lw之后R-Type需要使用访存结果，这在时间上是倒流的，不可能，只能插入一个气泡，清空IDEX寄存器，不更新IFID寄存器，不更新PC。 ![](lab7_Pipeline-CPU/pic8.png)####o)control模块——产生控制信号|control.v|||||---||输入/输出|宽度|信号名|说明||input|[0:0]|clk|时钟沿||input|[0:0]|rst|复位信号高电平有效||input|[5:0]|Op|||input|[4:0]|Rt|||input|[5:0]|Funct|||input|[1:0]|RsCMPRt|Rs和Rt寄存器比较结果||input|[1:0]|RsCMPZero|Rs寄存器和0比较结果||output|[1:0]|PCSrc|0:+4，1:Branch，2:J，3:JR||output|[0:0]|RegDst|0:RegWtaddr=rt，1:RegWtaddr=rd||output|[0:0]|ALUSrcASel|0:RegRdout1，1:ShamtZeroExtended||output|[1:0]|ALUSrcBSel|0:RegRdout2，1:IMMSignExtended，2:IMMZeroExtended||output|[4:0]|ALUControl|||output|[0:0]|DMemRead|1:En||output|[0:0]|DMemWrite|1:En||output|[0:0]|DMemtoReg|0:Aluout，1:DMemout||output|[0:0]|RegWrite|1:En|根据输入信号，判断指令类型，输出对应控制信号的取值。####p)debounce模块——去抖动|debounce.v|||||---||输入/输出|宽度|信号名|说明||input|[0:0]|clk|时钟沿||input|[0:0]|in|输入信号，可能有抖动||output|[0:0]|out|输出信号，输入稳定后才变化|####q)seg模块——7段数码管|seg.v|||||---||输入/输出|宽度|信号名|说明||input|[0:0]|clk|时钟沿||input|[0:0]|rst_n|复位信号，低电平有效||input|[31:0]|data32|要显示的数据||output|[3:0]|sel|选择当前显示位，低电平有效||output|[6:0]|segments|选择显示的数码管，高电平有效|####r)top模块——实例化以上模块，连接各个信号|top.v|||||---||输入/输出|宽度|信号名|说明||input|[0:0]|clk|时钟沿||input|[7:0]|sw|开关选择||output|[6:0]|seg7|7段数码管选择||output|[3:0]|an|7段数码管位选择||input|[0:0]|btns|按钮中间，按下复位|###4、 信号命名规则####（1） 信号名称由几个单词（或其简写）构成，每个单词首字母大写####（2） 一般先写该信号对应的部件名，然后紧跟操作或接口名。####（3） 如果该信号是另外一个信号的选择信号，则加上Sel后缀。####（4） 如果该信号涉及在不同段之间传递，则在对应段的信号后加上所在段的名称。####（5） 以上面方法命名基本不会引起混淆。-比如：RegRdout1_EX表示寄存器文件读端口1读出的数据传递到EX段的信号。###5、 DMem和IMem的初始化 IP核选择Block Memory，设置为Single Port RAM， ![](lab7_Pipeline-CPU/pic9.png)宽度为32，深度为256 ![](lab7_Pipeline-CPU/pic10.png)选中Load Init File设置，选择初始化coe文件的路径， ![](lab7_Pipeline-CPU/pic11.png)其中IMem_init_test.coe文件内容为 ``` memory_initialization_radix=16;memory_initialization_vector=20110008 01d17020 21ceffff 11c00001 02200008 20100001 200f2000 20080010 00084040 00084082 ade80000 21ef0004 8de9fffc 01295004 3c090001 ade90000 21ef0004 adea0000 21ef0004 01505022 adea0000 21ef0004 010a4025 01004024 01084027 ade80000 21ef0004 01485826 000b5843 020b5807 adeb0000 21ef0004 000b5842 020b5806 000b5dc0 016b5821 adeb0000 21ef0004 01685823 adeb0000 21ef0004 256b0001 adeb0000 21ef0004 356b0001 316b0003 390b0001 adeb0000 21ef0004 020b602a adec0000 21ef0004 020b602b adec0000 21ef0004 296c0001 adec0000 21ef0004 2d6c0001 adec0000 21ef0004 018c680a aded0000 21ef0004 0210680b aded0000 21ef0004 200e0000 08000062 08000066 21ce0001 adee0000 21ef0004 1560fffb 21ce0001 adee0000 21ef0004 1000fff8 21ce0001 adee0000 21ef0004 1800fff8 21ce0001 adee0000 21ef0004 0560fff8 21ce0001 adee0000 21ef0004 0401fff8 21ce0001 adee0000 21ef0004 1e00fff8 21ce0001 adee0000 21ef0004 1560fff8 21ce0001 adee0000 21ef0004 116bfff8 21ce0001 adee0000 08000068;``` DMem的初始化类似该过程，其coe文件初始全为0。###6、 测试的汇编代码 ```assembly.text addi $17,$0,8#const $17=8 add $14,$14,$17#$14=8 addi $14,$14,-1#$14--beq $14,$0,begin jr $17#jump to IMemAddr 8 begin:addi $16,$0,1#const 1 addi $15,$0,8192#MemAddr addi $8,$0,16#$8=16 sll $8,$8,1#$8=32 srl $8,$8,2#$8=8 sw $8,0($15)#-------Save Value:8------addi $15,$15,4#MemAddr++lw $9,-4($15)#$9=8(32'b00000000_00000001_00000000_00001000)sllv $10,$9,$9#$10=2048(32'b00000000_00000000_00001000_00000000)lui $9,1#$9=32'b00000000_00000001_00000000_00000000 sw $9,0($15)#-------Save Value:32'b00000000_00000001_00000000_00001000------addi $15,$15,4#MemAddr++sw $10,0($15)#-------Save Value:2048------addi $15,$15,4#MemAddr++sub $10,$10,$16#$10=2047(32'b00000000_00000000_00000111_11111111)sw $10,0($15)#-------Save Value:2047------addi $15,$15,4#MemAddr++or $8,$8,$10#$8=2047(32'b111_11111111)and $8,$8,$0#$8=0 nor $8,$8,$8#$8=2^32-1 sw $8,0($15)#-------Save Value:2^32-1------addi $15,$15,4#MemAddr++xor $11,$10,$8#$11=32'b11111111_11111111_11111000_00000000 sra $11,$11,1#$11=32'b11111111_11111111_11111100_00000000 srav $11,$11,$16#$11=32'b11111111_11111111_11111110_00000000 sw $11,0($15)#-------Save Value:32'b11111111_11111111_11111110_00000000------addi $15,$15,4#MemAddr++srl $11,$11,1#$11=32'b01111111_11111111_11111111_00000000 srlv $11,$11,$16#$11=32'b00111111_11111111_11111111_10000000 sll $11,$11,23#$11=32'b01000000_00000000_00000000_00000000 addu $11,$11,$11#$11=32'b10000000_00000000_00000000_00000000 sw $11,0($15)#-------Save Value:32'b10000000_00000000_00000000_00000000------addi $15,$15,4#MemAddr++subu $11,$11,$8#$11=32'b10000000_00000000_00000000_00000001 sw $11,0($15)#-------Save Value:32'b10000000_00000000_00000000_00000001------addi $15,$15,4#MemAddr++addiu $11,$11,1#$11=32'b10000000_00000000_00000000_00000010 sw $11,0($15)#-------Save Value:32'b10000000_00000000_00000000_00000010------addi $15,$15,4#MemAddr++ori $11,$11,1#$11=32'b10000000_00000000_00000000_00000011 andi $11,$11,3#$11=32'b00000000_00000000_00000000_00000011 xori $11,$8,1#$11=32'b11111111_11111111_11111111_11111110 sw $11,0($15)#-------Save Value:32'b11111111_11111111_11111111_11111100------addi $15,$15,4#MemAddr++slt $12,$16,$11#$12=0 sw $12,0($15)#-------Save Value:0------addi $15,$15,4#MemAddr++sltu $12,$16,$11#$12=1 sw $12,0($15)#-------Save Value:1------addi $15,$15,4#MemAddr++slti $12,$11,1#$12=1 sw $12,0($15)#-------Save Value:1------addi $15,$15,4#MemAddr++sltiu $12,$11,1#$12=0 sw $12,0($15)#-------Save Value:0------addi $15,$15,4#MemAddr++movz $13,$12,$12#because $12=0,set $13=$12,sw $13,0($15)#-------Save Value:0------addi $15,$15,4#MemAddr++movn $13,$16,$16#because $16=1(!=0),set $13=$16,sw $13,0($15)#-------Save Value:1------addi $15,$15,4#MemAddr++addi $14,$0,0#count j a i:j end h:addi $14,$14,1#count++sw $14,0($15)#-------Save Value:$14------addi $15,$15,4#MemAddr++bne $11,$0,i#to i g:addi $14,$14,1#count++sw $14,0($15)#-------Save Value:$14------addi $15,$15,4#MemAddr++beq $0,$0,h#to h f:addi $14,$14,1#count++sw $14,0($15)#-------Save Value:$14------addi $15,$15,4#MemAddr++blez $0,g#to g e:addi $14,$14,1#count++sw $14,0($15)#-------Save Value:$14------addi $15,$15,4#MemAddr++bltz $11,f#to f d:addi $14,$14,1#count++sw $14,0($15)#-------Save Value:$14------addi $15,$15,4#MemAddr++bgez $0,e#to e c:addi $14,$14,1#count++sw $14,0($15)#-------Save Value:$14------addi $15,$15,4#MemAddr++bgtz $16,d#to d b:addi $14,$14,1#count++sw $14,0($15)#-------Save Value:$14------addi $15,$15,4#MemAddr++bne $11,$0,c#to c a:addi $14,$14,1#count++sw $14,0($15)#-------Save Value:$14------addi $15,$15,4#MemAddr++beq $11,$11,b#to b end:addi $14,$14,1#count++sw $14,0($15)#-------Save Value:$14------out:j out ``` 完整汇编代码如上，36条指令均测试到了，每条语句的执行结果在该语句后面给出了注释，每测试几条指令就将结果写入内存，方便查看，并且3种相关有包括在上面的代码中。 ​##实验结果###（1）仿真结果 汇编代码在Mars编译运行得到Data段为 ![](lab7_Pipeline-CPU/pic12.png)而ISE仿真结果显示DMem为 ![](lab7_Pipeline-CPU/pic13.png)汇编代码在Mars编译运行得到结束时寄存器数据和仿真结果的regfile数据 ![](lab7_Pipeline-CPU/pic14.png)![](lab7_Pipeline-CPU/pic15.png)可见测试程序在编写的MIPS CPU上运行结果与Mars运行结果一致，并且符合上面注释的的预期结果。###（2）下载结果 按下按钮中键复位，拨动开关选择地址，数码管显示对应地址内存。 ![](lab7_Pipeline-CPU/pic16.png)由于数据为32位，4个数码管只能显示16位，为此还实现了动态显示，数字会向左移动循环显示。 ![](lab7_Pipeline-CPU/pic17.png)##附录:###一、 编写过程中遇到问题和一些发现####1、如果位拼接作为左值，单个变量也要花括号，如 ```{{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9'b100100100;```####2、\"==\"会严格匹配每一位，比如module内5位数字比较（一个常量，一个input），但外部传入的是3位的，高位自动拓展好像是x，就导致“==”不成立，这是一个不好发现的问题。####3、仿真遇到高阻态，多半是这个信号不存在，经常是拼写错了，有时候ise检查不出来。####4、在top里的wire信号，如果通过control模块（或其他模块）进行控制，那么这个信号不能直接在top里赋初值，要到仿真模块里赋值，不然control里改变这个信号的值时，会变成不确定。####5、在clk边缘用<=对某信号进行赋值时，如果同时刻需要对该信号进行判断（如状态机，根据状态以完成对应操作），则判断时信号的值是本次改变前的。（非阻塞赋值的特性体现）####6、 srl是逻辑右移，高位直接补零，而sra是算术右移，高位补符号，在Verilog中，既可以自行实现，也可以这样实现 `$signed(alu_a)>>> alu_b`####应该注意， >>> 是算术右移，但对于无符号数，高位仍然补0，所以需要用`$signed()`转为有符号数 `$signed(alu_a)>> alu_b `####这样写也不行，>>不具有算术右移的功能####7、reset的时候应该把各段寄存器的各信号置0，否则将导致forward，hazard模块输出的值不确定进而使相关的选择信号不确定（比如PCEn不确定，这样一开始就不能更新PC）。###二、 模块源代码####top.v ```verilog module top(input clk,input[7:0]sw,output[6:0]seg7,output[3:0]an,input btnr,btnl,btns,btnd,btnu);//_后缀表示该信号所在的流水段 wire ALUSrcASel_ID;wire ALUSrcASel_EX;wire[1:0]ALUSrcBSel_ID;//alu B在regout2和imm之间选择 wire[1:0]ALUSrcBSel_EX;wire[31:0]ALUSrcA_EX;wire[31:0]ALUSrcB_EX;wire[4:0]ALUControl_ID;wire[4:0]ALUControl_EX;wire[31:0]ALUResult_EX;wire[31:0]ALUResult_MEM;wire[31:0]ALUResult_WB;wire[1:0]RsCMPZero;wire[1:0]RsCMPRt;wire[31:0]IMMSignExtended_ID;wire[31:0]IMMSignExtended_EX;wire[31:0]IMMZeroExtended_ID;wire[31:0]IMMZeroExtended_EX;wire[31:0]ShamtZeroExtended_ID;wire[31:0]ShamtZeroExtended_EX;wire[1:0]RegRdout1Sel_Forward_EX;//旁路单元产生的选择信号 wire[1:0]RegRdout2Sel_Forward_EX;wire[31:0]RegRdout1_Forward_EX;//旁路数据 wire[31:0]RegRdout2_Forward_EX;wire[4:0]RegRdaddr1_ID;wire[31:0]RegRdout1_ID;wire[31:0]RegRdout1_EX;wire[4:0]RegRdaddr2_ID;wire[31:0]RegRdout2_ID;wire[31:0]RegRdout2_EX;wire[4:0]RegWtaddr_ID;wire[4:0]RegWtaddr_EX;wire[4:0]RegWtaddr_MEM;wire[4:0]RegWtaddr_WB;wire[31:0]RegWtin_WB;wire RegWrite_ID;wire RegWrite_EX;wire RegWrite_MEM;wire RegWrite_WB;wire RegDst_ID;wire[31:0]IMemaddr;wire[31:0]IMemout;wire[31:0]DMemaddr_MEM;wire[31:0]DMemin_MEM;wire DMemRead_MEM;wire[31:0]DMemout_MEM;wire[31:0]DMemout_WB;wire DMemWrite_MEM;wire DMemtoReg_EX;wire DMemtoReg_MEM;wire DMemtoReg_WB;wire[31:0]PC;wire[31:0]PCPlus_IF;wire[31:0]PCPlus_ID;wire[31:0]PCPlus_EX;wire[31:0]EPC;wire[31:0]nextPC;wire PCEn;wire[1:0]PCSrc_ID;//Control输出的，0:+4,1:Branch,2:J,3:JR wire IF_ID_En;wire IF_ID_Flush;wire ID_EX_Flush;wire[31:0]PCJump_ID;wire[31:0]PCJR_ID;wire[31:0]PCBranch_ID;wire[31:0]Instr;wire[5:0]Funct;wire[4:0]Shamt;wire[15:0]IMM16;wire[4:0]Rd;wire[4:0]Rt;wire[4:0]Rs;wire[5:0]Op;wire[4:0]Rt_EX;//为了旁路判断 wire[4:0]Rs_EX;//为了旁路判断 wire[25:0]JumpIMM;wire[31:0]IMMSignExtendedShiftLeft2;wire btns_d;debounce debounce(clk,btns,btns_d);//中键去抖动 reg rst;assign Led=rst;always @(posedge btns_d)rst=~rst;//--------------regfile_copy_DMem是DMem的一份复制--------------wire[4:0]addr_show;wire[31:0]out_show;assign addr_show=sw;//开关输输入要显示的地址 seg seg1(clk,1'b1,out_show,an,seg7);//显示数据 regfile_copy_DMem regfile_copy_DMem(clk,~rst,addr_show,out_show,DMemaddr_MEM >> 2,DMemin_MEM,DMemWrite_MEM);//---------------方便显示内存-------------------------//=======================IF========================mux4 MUXPC(.sel(PCSrc_ID),.d0(PCPlus_IF),//+4直接用IF的.d1(PCBranch_ID),.d2(PCJump_ID),.d3(PCJR_ID),.out(nextPC));dff DFFPC(.clk(~clk),//下降沿更新PC.en(PCEn),.rst(rst),.datain(nextPC),.dataout(PC));alu ALUPCPlus(PC,4,5'd01,PCPlus_IF);assign IMemaddr=PC >> 2;//>>2是因为这里IMem是每个地址存储4字节，和实际上的（一地址一字节）不一样 IMem IMem(clk,1'b0,IMemaddr,32'b0,IMemout);//上升沿读指令//======================IFID========================IFID IFID(.clk(~clk),.en(IF_ID_En),.flush(IF_ID_Flush||rst),.PCPlus_in(PCPlus_IF),.IMemout_in(IMemout),.PCPlus_out(PCPlus_ID),.IMemout_out(Instr));//=======================ID==========================assign JumpIMM=Instr[25:0];assign Funct=Instr[5:0];assign Shamt=Instr[10:6];assign IMM16=Instr[15:0];assign Rd=Instr[15:11];assign Rt=Instr[20:16];assign Rs=Instr[25:21];assign Op=Instr[31:26];//*******Control*******control control(//in.clk(clk),.rst(rst),.Op(Op),.Rt(Rt),.Funct(Funct),.RsCMPRt(RsCMPRt),.RsCMPZero(RsCMPZero),//out.PCSrc(PCSrc_ID),//ID.RegDst(RegDst_ID),//EX.ALUSrcASel(ALUSrcASel_ID),.ALUSrcBSel(ALUSrcBSel_ID),.ALUControl(ALUControl_ID),//MEM.DMemRead(DMemRead_ID),.DMemWrite(DMemWrite_ID),//WB.DMemtoReg(DMemtoReg_ID),.RegWrite(RegWrite_ID));//*******Control*******assign RegRdaddr1_ID=Rs;assign RegRdaddr2_ID=Rt;mux#(5)MUXRegWtaddr(RegDst_ID,Rt,Rd,RegWtaddr_ID);assign ShamtZeroExtended_ID={{27{1'b0}},Shamt};assign IMMSignExtended_ID={{16{IMM16[15]}},IMM16};assign IMMZeroExtended_ID={{16{1'b0}},IMM16};assign IMMSignExtendedShiftLeft2=IMMSignExtended_ID << 2;alu BranchALU(PCPlus_ID,IMMSignExtendedShiftLeft2,5'd01,PCBranch_ID);assign PCJump_ID={{PCPlus_ID[31:28]},{{2'b00,JumpIMM}<<2}};assign PCJR_ID=RegRdout1_ID;assign IF_ID_Flush=(PCSrc_ID !=2'b00);//有跳转则清空IF_ID寄存器 regfile regfile(clk,~rst,RegRdaddr1_ID,RegRdout1_ID,RegRdaddr2_ID,RegRdout2_ID,RegWtaddr_WB,RegWtin_WB,RegWrite_WB);compare compare1(RegRdout1_ID,RegRdout2_ID,RsCMPRt);//for beq,bne compare compare2(RegRdout1_ID,0,RsCMPZero);//for movz,movn,blez,bgtz,bltz,bgez hazard hazard(Rs,Rt,RegWtaddr_EX,DMemRead_EX,PCEn,IF_ID_En,ID_EX_Flush);//======================IDEX=========================IDEX IDEX(.clk(~clk),.en(1'b1),.flush(ID_EX_Flush||rst),//data//in.PCPlus_in(PCPlus_ID),.RegRdout1_in(RegRdout1_ID),.RegRdout2_in(RegRdout2_ID),.IMMSignExtended_in(IMMSignExtended_ID),.IMMZeroExtended_in(IMMZeroExtended_ID),.ShamtZeroExtended_in(ShamtZeroExtended_ID),.Rs_in(Rs),.Rt_in(Rt),.RegWtaddr_in(RegWtaddr_ID),//out.PCPlus_out(PCPlus_EX),.RegRdout1_out(RegRdout1_EX),.RegRdout2_out(RegRdout2_EX),.IMMSignExtended_out(IMMSignExtended_EX),.IMMZeroExtended_out(IMMZeroExtended_EX),.ShamtZeroExtended_out(ShamtZeroExtended_EX),.Rs_out(Rs_EX),.Rt_out(Rt_EX),.RegWtaddr_out(RegWtaddr_EX),//control sign//in.RegDst_in(RegDst_ID),.ALUSrcASel_in(ALUSrcASel_ID),.ALUSrcBSel_in(ALUSrcBSel_ID),.ALUControl_in(ALUControl_ID),.DMemRead_in(DMemRead_ID),.DMemWrite_in(DMemWrite_ID),.DMemtoReg_in(DMemtoReg_ID),.RegWrite_in(RegWrite_ID),//out.RegDst_out(RegDst_EX),.ALUSrcASel_out(ALUSrcASel_EX),.ALUSrcBSel_out(ALUSrcBSel_EX),.ALUControl_out(ALUControl_EX),.DMemRead_out(DMemRead_EX),.DMemWrite_out(DMemWrite_EX),.DMemtoReg_out(DMemtoReg_EX),.RegWrite_out(RegWrite_EX));//========================EX=========================forward forward(Rs_EX,Rt_EX,RegWrite_MEM,RegWrite_WB,RegWtaddr_MEM,RegWtaddr_WB,RegRdout1Sel_Forward_EX,RegRdout2Sel_Forward_EX);mux4 MUXRegRdout1FW(RegRdout1Sel_Forward_EX,RegRdout1_EX,RegWtin_WB,ALUResult_MEM,0,RegRdout1_Forward_EX);//forward mux4 MUXRegRdout2FW(RegRdout2Sel_Forward_EX,RegRdout2_EX,RegWtin_WB,ALUResult_MEM,0,RegRdout2_Forward_EX);//forward mux MUXALUSrcA(ALUSrcASel_EX,RegRdout1_Forward_EX,ShamtZeroExtended_EX,ALUSrcA_EX);mux4 MUXALUSrcB(ALUSrcBSel_EX,RegRdout2_Forward_EX,IMMSignExtended_EX,IMMZeroExtended_EX,0,ALUSrcB_EX);alu alu(ALUSrcA_EX,ALUSrcB_EX,ALUControl_EX,ALUResult_EX);//======================EXMEM========================EXMEM EXMEM(.clk(~clk),.en(1'b1),.flush(rst),//data//in.ALUResult_in(ALUResult_EX),.DMemin_in(RegRdout2_Forward_EX),.RegWtaddr_in(RegWtaddr_EX),//out.ALUResult_out(ALUResult_MEM),.DMemin_out(DMemin_MEM),.RegWtaddr_out(RegWtaddr_MEM),//control sign//in.DMemRead_in(DMemRead_EX),.DMemWrite_in(DMemWrite_EX),.DMemtoReg_in(DMemtoReg_EX),.RegWrite_in(RegWrite_EX),//out.DMemRead_out(DMemRead_MEM),.DMemWrite_out(DMemWrite_MEM),.DMemtoReg_out(DMemtoReg_MEM),.RegWrite_out(RegWrite_MEM));//=======================MEM=========================assign DMemaddr_MEM=ALUResult_MEM;DMem DMem(clk,DMemWrite_MEM,DMemaddr_MEM >> 2,DMemin_MEM,DMemout_MEM);//======================MEMWB========================MEMWB MEMWB(.clk(~clk),.en(1'b1),.flush(rst),//data//in.ALUResult_in(ALUResult_MEM),.DMemout_in(DMemout_MEM),.RegWtaddr_in(RegWtaddr_MEM),//out.ALUResult_out(ALUResult_WB),.DMemout_out(DMemout_WB),.RegWtaddr_out(RegWtaddr_WB),//control sign//in.DMemtoReg_in(DMemtoReg_MEM),.RegWrite_in(RegWrite_MEM),//out.DMemtoReg_out(DMemtoReg_WB),.RegWrite_out(RegWrite_WB));//========================WB=========================mux MUXDMemtoReg(DMemtoReg_WB,ALUResult_WB,DMemout_WB,RegWtin_WB);endmodule ```####alu.v ```verilog `define A_NOP 5'd00//nop `define A_ADD 5'd01//signed_add `define A_SUB 5'd02//signed_sub `define A_AND 5'd03//and `define A_OR 5'd04//or `define A_XOR 5'd05//xor `define A_NOR 5'd06//nor `define A_ADDU 5'd07//unsigned_add `define A_SUBU 5'd08//unsigned_sub `define A_SLT 5'd09//slt `define A_SLTU 5'd10//unsigned_slt `define A_SLL 5'd11//sll `define A_SRL 5'd12//srl `define A_SRA 5'd13//sra `define A_MOV 5'd14//movz,movn `define A_LUI 5'd15//lui module alu(input[31:0]alu_a,//无符号型的，如果有负数，是以补码存储 input[31:0]alu_b,input[4:0]alu_op,output reg[31:0]alu_out);always@(*)case(alu_op)`A_NOP:alu_out=0;`A_ADD:alu_out=alu_a+alu_b;`A_SUB:alu_out=alu_a-alu_b;`A_AND:alu_out=alu_a&alu_b;`A_OR:alu_out=alu_a|alu_b;`A_XOR:alu_out=alu_a^alu_b;`A_NOR:alu_out=~(alu_a|alu_b);`A_ADDU:alu_out=alu_a+alu_b;`A_SUBU:alu_out=alu_a-alu_b;`A_SLT://a<b(signed)return 1 else return 0;begin if(alu_a[31]==alu_b[31])alu_out=(alu_a < alu_b)?32'b1:32'b0;//对于不加signed的变量类型，运算和比较视为无符号，但依然可以存储有符号数，这里相当于自行根据首位判断//首位相等，即同号情况，直接比较，如果同正，后面31位大的，原数就大，如果同负，后面31位（补码）大的，依然是原数大 else alu_out=(alu_a[31]< alu_b[31])?32'b0:32'b1;//异号情况，直接比较符号 end `A_SLTU:alu_out=(alu_a < alu_b)?32'b1:32'b0;`A_SLL:alu_out=alu_b << alu_a;`A_SRL:alu_out=alu_b >> alu_a;`A_SRA:alu_out=$signed(alu_b)>>> alu_a;//使用>>>为算术右移，高位补符号，应该注意，如果是无符号数，>>>仍是逻辑右移，故应该$signed `A_MOV:alu_out=alu_b;//原样输出，相当于reg[rt],mov本不需要通过alu，但因为是RType格式，故统一 `A_LUI:alu_out=alu_b << 16;default:;endcase endmodule ```####regfile.v ```verilog module regfile(input clk,input rst_n,input[4:0]rAddr1,//读地址1 output[31:0]rDout1,//读数据1 input[4:0]rAddr2,//读地址2 output[31:0]rDout2,//读数据2 input[4:0]wAddr,//写地址 input[31:0]wDin,//写数据 input wEna//写使能);reg[31:0]data[0:31];integer i;assign rDout1=data[rAddr1];//读1 assign rDout2=data[rAddr2];//读2 always@(posedge clk or negedge rst_n)//写和复位 if(~rst_n)begin for(i=0;i<32;i=i+1)data[i]<=0;end else begin if(wEna)data[wAddr]<=wDin;end endmodule ```####dff.v ```verilog module dff#(parameter WIDTH=32)(//Data Flip-Flop input clk,input en,input rst,input[WIDTH-1:0]datain,output reg[WIDTH-1:0]dataout);always@(posedge clk)begin if(rst)dataout <=0;else if(en)dataout <=datain;end endmodule ```####mux.v ```verilog module mux#(parameter WIDTH=32)(//2路选择器 input sel,input[WIDTH-1:0]d0,input[WIDTH-1:0]d1,output[WIDTH-1:0]out);assign out=(sel==1'b1?d1:d0);endmodule ```####mux4.v ```verilog module mux4#(parameter WIDTH=32)(//4路选择器 input[1:0]sel,input[WIDTH-1:0]d0,input[WIDTH-1:0]d1,input[WIDTH-1:0]d2,input[WIDTH-1:0]d3,output reg[WIDTH-1:0]out);always@(*)case(sel)2'b00:out=d0;2'b01:out=d1;2'b10:out=d2;2'b11:out=d3;default:;endcase endmodule ```####IFID.v ```verilog module IFID(input clk,input en,input flush,input[31:0]PCPlus_in,input[31:0]IMemout_in,output[31:0]PCPlus_out,output[31:0]IMemout_out);dff dff1(clk,en,flush,PCPlus_in,PCPlus_out);dff dff2(clk,en,flush,IMemout_in,IMemout_out);endmodule ```####IDEX.v ```verilog module IDEX(input clk,input en,input flush,//flush for stall or start input[31:0]PCPlus_in,input[31:0]RegRdout1_in,input[31:0]RegRdout2_in,input[31:0]IMMSignExtended_in,input[31:0]IMMZeroExtended_in,input[31:0]ShamtZeroExtended_in,input[4:0]Rs_in,input[4:0]Rt_in,input[4:0]RegWtaddr_in,output[31:0]PCPlus_out,output[31:0]RegRdout1_out,output[31:0]RegRdout2_out,output[31:0]IMMSignExtended_out,output[31:0]IMMZeroExtended_out,output[31:0]ShamtZeroExtended_out,output[4:0]Rs_out,output[4:0]Rt_out,output[4:0]RegWtaddr_out,//control input RegDst_in,input ALUSrcASel_in,input[1:0]ALUSrcBSel_in,input[4:0]ALUControl_in,input DMemRead_in,input DMemWrite_in,input DMemtoReg_in,input RegWrite_in,output RegDst_out,output ALUSrcASel_out,output[1:0]ALUSrcBSel_out,output[4:0]ALUControl_out,output DMemRead_out,output DMemWrite_out,output DMemtoReg_out,output RegWrite_out);dff dff1(clk,en,flush,PCPlus_in,PCPlus_out);dff dff2(clk,en,flush,RegRdout1_in,RegRdout1_out);dff dff3(clk,en,flush,RegRdout2_in,RegRdout2_out);dff dff4(clk,en,flush,IMMSignExtended_in,IMMSignExtended_out);dff dff5(clk,en,flush,IMMZeroExtended_in,IMMZeroExtended_out);dff dff6(clk,en,flush,ShamtZeroExtended_in,ShamtZeroExtended_out);dff#(5)dff7(clk,en,flush,Rs_in,Rs_out);dff#(5)dff8(clk,en,flush,Rt_in,Rt_out);dff#(5)dff9(clk,en,flush,RegWtaddr_in,RegWtaddr_out);dff#(1)dff10(clk,en,flush,RegDst_in,RegDst_out);dff#(1)dff11(clk,en,flush,ALUSrcASel_in,ALUSrcASel_out);dff#(2)dff12(clk,en,flush,ALUSrcBSel_in,ALUSrcBSel_out);dff#(5)dff13(clk,en,flush,ALUControl_in,ALUControl_out);dff#(1)dff14(clk,en,flush,DMemRead_in,DMemRead_out);dff#(1)dff15(clk,en,flush,DMemWrite_in,DMemWrite_out);dff#(1)dff16(clk,en,flush,DMemtoReg_in,DMemtoReg_out);dff#(1)dff17(clk,en,flush,RegWrite_in,RegWrite_out);endmodule ```####EXMEM.v ```verilog module EXMEM(input clk,input en,input flush,input[31:0]ALUResult_in,input[31:0]DMemin_in,input[4:0]RegWtaddr_in,output[31:0]ALUResult_out,output[31:0]DMemin_out,output[4:0]RegWtaddr_out,//control input DMemRead_in,input DMemWrite_in,input DMemtoReg_in,input RegWrite_in,output DMemRead_out,output DMemWrite_out,output DMemtoReg_out,output RegWrite_out);dff dff1(clk,en,flush,ALUResult_in,ALUResult_out);dff dff2(clk,en,flush,DMemin_in,DMemin_out);dff#(5)dff3(clk,en,flush,RegWtaddr_in,RegWtaddr_out);dff#(1)dff14(clk,en,flush,DMemRead_in,DMemRead_out);dff#(1)dff15(clk,en,flush,DMemWrite_in,DMemWrite_out);dff#(1)dff16(clk,en,flush,DMemtoReg_in,DMemtoReg_out);dff#(1)dff17(clk,en,flush,RegWrite_in,RegWrite_out);endmodule ```####MEMWB.v ```verilog module MEMWB(input clk,input en,input flush,input[31:0]ALUResult_in,input[31:0]DMemout_in,input[4:0]RegWtaddr_in,output[31:0]ALUResult_out,output[31:0]DMemout_out,output[4:0]RegWtaddr_out,//control input DMemtoReg_in,input RegWrite_in,output DMemtoReg_out,output RegWrite_out);dff dff1(clk,en,flush,ALUResult_in,ALUResult_out);dff dff2(clk,en,flush,DMemout_in,DMemout_out);dff#(5)dff3(clk,en,flush,RegWtaddr_in,RegWtaddr_out);dff#(1)dff16(clk,en,flush,DMemtoReg_in,DMemtoReg_out);dff#(1)dff17(clk,en,flush,RegWrite_in,RegWrite_out);endmodule ```####compare.v ```verilog `define LESS 2'b00 `define EQUAL 2'b01 `define GREATER 2'b10 module compare(//为了判断分支 input signed[31:0]a,input signed[31:0]b,output reg[1:0]res);always @(*)if(a==b)res=2'b01;else if(a < b)res=2'b00;else if(a > b)res=2'b10;endmodule ```####forward.v ```verilog module forward(//前推 input[4:0]Rs_EX,input[4:0]Rt_EX,input RegWrite_MEM,input RegWrite_WB,input[4:0]RegWtaddr_MEM,input[4:0]RegWtaddr_WB,output reg[1:0]RegRdout1Sel_Forward_EX,output reg[1:0]RegRdout2Sel_Forward_EX);always @(*)begin RegRdout1Sel_Forward_EX[0]=RegWrite_WB&&(RegWtaddr_WB !=0)&&(RegWtaddr_MEM !=Rs_EX)&&(RegWtaddr_WB==Rs_EX);RegRdout1Sel_Forward_EX[1]=RegWrite_MEM&&(RegWtaddr_MEM !=0)&&(RegWtaddr_MEM==Rs_EX);RegRdout2Sel_Forward_EX[0]=RegWrite_WB&&(RegWtaddr_WB !=0)&&(RegWtaddr_MEM !=Rt_EX)&&(RegWtaddr_WB==Rt_EX);RegRdout2Sel_Forward_EX[1]=RegWrite_MEM&&(RegWtaddr_MEM !=0)&&(RegWtaddr_MEM==Rt_EX);end endmodule ```####hazard.v ```verilog module hazard(//上一条指令是LW指令且当前指令ID级读的是同一个寄存器,则插入bubble input[4:0]Rs_ID,input[4:0]Rt_ID,input[4:0]RegWtaddr_EX,input DMemRead_EX,output PCEn,output IF_ID_En,output ID_EX_Flush);assign ID_EX_Flush=((RegWtaddr_EX==Rs_ID)||(RegWtaddr_EX==Rt_ID))&&DMemRead_EX;//条件成立则为1，清空 assign IF_ID_En=~ID_EX_Flush;//条件成立则为0，保持 assign PCEn=~ID_EX_Flush;//条件成立则为0，保持 endmodule ```####control.v ```verilog module control(input clk,rst,input[5:0]Op,//instr[31:26]input[4:0]Rt,//instr[20:16]input[5:0]Funct,//instr[5:0]input[1:0]RsCMPRt,input[1:0]RsCMPZero,output reg[1:0]PCSrc,//0:+4,1:Branch,2:J,3:JR//ID output reg RegDst,//0:RegWtaddr=rt,1:RegWtaddr=rd//EX output reg ALUSrcASel,//0:RegRdout1,1:ShamtZeroExtended output reg[1:0]ALUSrcBSel,//0:RegRdout2,1:IMMSignExtended,2:IMMZeroExtended output reg[4:0]ALUControl,//MEM output reg DMemRead,//1:En output reg DMemWrite,//1:En//WB output reg DMemtoReg,//0:Aluout,1:DMemout output reg RegWrite//1:En);reg[1:0]tmpsrc;always @(*)begin if(rst)begin{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_00},{`A_NOP},{4'b0001}};end else case(Op)6'b000000://R-Type case(Funct)//SLL的rs rt rd shamt全0时是nop，本来nop没有对应的 6'b000000://SLL,注意Alu_a来自Shamt的无符号拓展,即ALUSrcASel=1，下面两个同理{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_1_00},{`A_SLL},{4'b0001}};//6'b000001://MOVCI 6'b000010://SRL{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_1_00},{`A_SRL},{4'b0001}};6'b000011://SRA{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_1_00},{`A_SRA},{4'b0001}};6'b000100://SLLV，注意Alu_a来自reg[rs],即ALUSrcASel=0，下面两个同理{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_SLL},{4'b0001}};//6'b000101://*6'b000110://SRLV{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_SRL},{4'b0001}};6'b000111://SRAV{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_SRA},{4'b0001}};6'b001000://JR{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b11_z_z_zz},{`A_NOP},{4'b00z0}};//6'b001001://JALR 6'b001010://MOVZ,如果 reg[rs]=0 则 reg[rd]=reg[rt],此时RsCMPZero=01,所以 RegWrite=RsCMPZero[0]{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_MOV},{3'b000},{RsCMPZero[0]}};6'b001011://MOVN,如果 reg[rs]!=0 则 reg[rd]=reg[rt],此时RsCMPZero=00或10,所以 RegWrite=~RsCMPZero[0]{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_MOV},{3'b000},{~RsCMPZero[0]}};6'b100000://ADD{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_ADD},{4'b0001}};6'b100001://ADDU{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_ADDU},{4'b0001}};6'b100010://SUB{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_SUB},{4'b0001}};6'b100011://SUBU{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_SUB},{4'b0001}};6'b100100://AND{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_AND},{4'b0001}};6'b100101://OR{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_OR},{4'b0001}};6'b100110://XOR{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_XOR},{4'b0001}};6'b100111://NOR{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_NOR},{4'b0001}};6'b101010://SLT{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_SLT},{4'b0001}};6'b101011://SLTU{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_SLTU},{4'b0001}};endcase 6'b000001:case(Rt)6'b00000://BLTZ,Reg[rs]<0则跳转 begin if(RsCMPZero==`LESS)tmpsrc=2'b01;else tmpsrc=2'b00;{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{tmpsrc},{4'bz_z_zz},{`A_NOP},{4'b00z0}};end 6'b00001://BGEZ,Reg[rs]>=0则跳转 begin if(RsCMPZero==`GREATER||RsCMPZero==`EQUAL)tmpsrc=2'b01;else tmpsrc=2'b00;{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{tmpsrc},{4'bz_z_zz},{`A_NOP},{4'b00z0}};end endcase 6'b000010://J,无条件跳转{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b10_z_z_zz},{`A_NOP},{4'b00z0}};//6'b000011://JAL 6'b000100://BEQ,Reg[rs]==Reg[rt]则跳转,RsCMPRt=01(==),则PCSrc=01，否则PCSrc=00(不跳转){{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{{1'b0},{RsCMPRt[0]}},{4'bz_z_zz},{`A_NOP},{4'b00z0}};6'b000101://BNE,Reg[rs]!=Reg[rt]则跳转,RsCMPRt=00(<)或10(>),则PCSrc=01，否则PCSrc=00(不跳转){{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{{1'b0},{~RsCMPRt[0]}},{4'bz_z_zz},{`A_NOP},{4'b00z0}};6'b000110://BLEZ,Reg[rs]<=0则跳转 begin if(RsCMPZero==`LESS||RsCMPZero==`EQUAL)tmpsrc=2'b01;else tmpsrc=2'b00;{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{tmpsrc},{4'bz_z_zz},{`A_NOP},{4'b00z0}};end 6'b000111://BGTZ,Reg[rs]>0则跳转 begin if(RsCMPZero==`GREATER)tmpsrc=2'b01;else tmpsrc=2'b00;{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{tmpsrc},{4'bz_z_zz},{`A_NOP},{4'b00z0}};end 6'b001000://ADDI,注意RegDst=0,AluBSrcSel=01(IMMSignExtended),下面三个同理{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_01},{`A_ADD},{4'b0001}};6'b001001://ADDIU{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_01},{`A_ADDU},{4'b0001}};6'b001010://SLTI{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_01},{`A_SLT},{4'b0001}};6'b001011://SLTIU{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_01},{`A_SLTU},{4'b0001}};6'b001100://ANDI,注意RegDst=0,AluBSrcSel=10(IMMZeroExtended),下面三个同理{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_10},{`A_AND},{4'b0001}};6'b001101://ORI{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_10},{`A_OR},{4'b0001}};6'b001110://XORI{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_10},{`A_XOR},{4'b0001}};6'b001111://LUI{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_10},{`A_LUI},{4'b0001}};6'b100011://LW,注意RegDst=0(写到Reg[rt]),AluBSrcSel=01(IMMSignExtended),DMemtoReg=1(来自DMem),{{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_01},{`A_ADD},{4'b1011}};6'b101011://SW,注意RegDst=x(不写Reg),AluBSrcSel=01(IMMSignExtended){{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_z_0_01},{`A_ADD},{4'b01z0}};default:;endcase end endmodule ```####debounce.v ```verilog module debounce(//去抖动 input clk,input in,output reg out=0);reg[31:0]cnt=0;always@(posedge clk)begin if(in!=out)begin cnt=cnt+1;if(cnt==100000)begin out=~out;cnt=0;end end else cnt=0;end endmodule ```####seg.v ```verilog module seg(input clk,input rst_n,input[31:0]data32,output reg[3:0]sel,output reg[6:0]segments);integer clk_25=0;//4位数码管循环显示用 integer clk_50000000=0;//2hz，移动显示用 reg[1:0]cnt;reg[3:0]cnt2;reg[15:0]data16;//data32的16bit reg[3:0]data4;//data16的4bit reg[3:0]empty;//空白位 always@(*)//组合逻辑，控制七段数码管 begin if(!rst_n)segments=7'b000_0000;else case(data4)0:segments=~7'b011_1111;//0 1:segments=~7'b000_0110;//1 2:segments=~7'b101_1011;//2 3:segments=~7'b100_1111;//3 4:segments=~7'b110_0110;//4 5:segments=~7'b110_1101;//5 6:segments=~7'b111_1101;//6 7:segments=~7'b000_0111;//7 8:segments=~7'b111_1111;//8 9:segments=~7'b110_1111;//9 10:segments=~7'b111_0111;//A 11:segments=~7'b111_1100;//b 12:segments=~7'b011_1001;//C 13:segments=~7'b101_1110;//d 14:segments=~7'b111_1001;//E 15:segments=~7'b111_0001;//F default:segments=7'b000_0000;//required endcase end always@(posedge clk)//时序逻辑，产生位选择信号段选择信号 begin//if(!rst_n)//cnt=2'b00;//else if(clk_25==400000)begin clk_25=0;cnt=cnt+2'b01;end else clk_25=clk_25+1;if(clk_50000000==50000000)//begin clk_50000000=0;cnt2=cnt2+1;if(cnt2==4'b1010)cnt2=4'b0000;end else clk_50000000=clk_50000000+1;end always@(*)//组合逻辑，选择当前显示段 begin case(cnt2)4'b0000:begin data16={8'bzzzzzzzz,data32[31:24]};empty=4'b1100;end 4'b0001:begin data16={4'bzzzz,data32[31:20]};empty=4'b1000;end 4'b0010:begin data16=data32[31:16];empty=4'b0000;end 4'b0011:begin data16=data32[27:12];empty=4'b0000;end 4'b0100:begin data16=data32[23:8];empty=4'b0000;end 4'b0101:begin data16=data32[19:4];empty=4'b0000;end 4'b0110:begin data16=data32[15:0];empty=4'b0000;end 4'b0111:begin data16={data32[11:0],4'bzzzz};empty=4'b0001;end 4'b1000:begin data16={data32[7:0],8'bzzzzzzzz};empty=4'b0011;end 4'b1001:begin data16={data32[3:0],8'bzzzzzzzz,data32[31:28]};empty=4'b0110;end default:;endcase end always@(*)//组合逻辑，选择当前显示位 begin case(cnt)2'b00:sel=4'b1110|empty;2'b01:sel=4'b1101|empty;2'b10:sel=4'b1011|empty;2'b11:sel=4'b0111|empty;default:sel=4'b1110;endcase end always@(*)//组合逻辑，选择当前显示位的数据 begin case(cnt)2'b00:data4=data16[3:0];2'b01:data4=data16[7:4];2'b10:data4=data16[11:8];2'b11:data4=data16[15:12];default:data4=16'b0;endcase end endmodule ```####test.v ```verilog module test;//Inputs reg clk;reg rst;//Instantiate the Unit Under Test(UUT)top uut(.clk(clk),.rst(rst),);initial begin//Initialize Inputs clk=1;rst=0;#100;rst=1;//Wait 100 ns for global reset to finish#100;clk=~clk;#10;clk=~clk;rst=0;forever begin#10;clk=~clk;end//Add stimulus here end endmodule ```","tags":["Verilog","COD"],"categories":[]},{"title":"Verilog中的有符号数与无符号数","url":"/s/p/9mls00/","content":"#Verilog中的有符号数与无符号数##缘起-在用Verilog编写流水线CPU时，ALU需要实现add、addu、sub、subu、slt、sltu功能，分别是加、减、小于则置位的有符号和无符号版本，不过之前使用Verilog编写代码的时候从来没有考虑过符号问题，基本都是按无符号处理，除了在立即数符号拓展部分涉及到了符号 `assign SignExtented={{16{IMM16[15]}},IMM16};` 这里相当于是手动按符号拓展。-那么，现在要实现的addu和add的区别在哪呢？还有溢出如何判断？##回顾-马上回想了下原码和补码的问题，但是这只是在有符号情况下对正负数表示的统一，现在的问题是Verilog中“+”这个运算符是认为操作数是有符号还是无符号呢？（当然，正数的情况没有区别）。马上测试了一下： ​ ```verilog reg[3:0]a； reg[3:0]b； reg[3:0]out； initial begin a=-1;b=-2;out=a+b;end ``` 结果out=-3，我以为“+”是计算有符号的情况的。 以二进制查看了一下波形，是`a=4'b1111,b=4'1110,out=4'b1101` 看来如果赋值为负数，是以补码的形式存储的 那么如果操作数是两个无符号数，且足够大，首位是1，不就也被“+”当成有符号负数了吗？这就不能实现无符号的加法了。 <!--more-->##初步理解-查看一本编写cpu的参考书，里面是这样写的 ![](verilog_signed_and_unsigned/alupic1.png)![](verilog_signed_and_unsigned/alupic2.png)![](verilog_signed_and_unsigned/alupic3.png)![](verilog_signed_and_unsigned/alupic4.png)![](verilog_signed_and_unsigned/alupic5.png)-这有符号和无符号有什么区别！！！-发现wire后面带着signed，马上查了下，这是Verilog2001新增的关键字，目的是为了方便处理有符号数，如果不加signed，就是按无符号处理。-signed类型的变量，在位数增加要拓展高位的时候，是按符号拓展，也就是说，前面的我们手动实现的符号拓展，这里自动实现了。-那么为什么它的有符号计算和无符号计算都还是同样用无符号数int_0,int_1处理，而溢出的判断是专门增加一个signed型的变量s_out，用$signed()把out转成有符号存在s_out，然后判断？-花了一点时间遍访了博客后，发现了这张图 ![](verilog_signed_and_unsigned/ss.png)这不就是在模2^n意义下的加法吗？ 等等，我再去看一下a,b，a=4'b1111,b=4'1110,直接相加，舍弃最高进位（mod 2^4），这不就是out=4'b1101吗？可是刚刚明明是解释为负数啊。。 思考了许久，啊，突然意识到，这个“+”确实是无符号的加，也就是电路中最基本的加法器的功能，这也是为什么负数要表示成补码的原因了（符号直接参与运算），看来之前没有真正理解补码的优越性。-这样一来，只要有符号时负数按补码存储，那么有符号和无符号的计算就是一样的-那么signed类型和unsigned类型的区别在哪呢？即使使用$signed()转换后，二进制代码并没有变，也就是，一串二进制代码，是有符号还是无符号，完全取决于你如何解释，不同解释就导致转换为十进制的时候得到不同的值，比较大小的时候也得到不同的结果。##进阶-那么溢出是如何判断的？-Mars的指令解释里add和addu的唯一区别在于addu不考虑溢出-我就想，无符号为什么就不会溢出了？最高位如果进位不就是溢出了吗？-又是一番思索后，翻出了数电课本（啊，当时没认真学的后果），再参考博客后，得到判断溢出的方法 > >补码加法运算溢出判断三种方法： > >［方法一］ Xf、Yf分别两个数的符号位,Zf为运算结果符号位。 当Xf=Yf=0（两数同为正）,而Zf=1(结果为负)时,负溢出； 当出现Xf=Yf=1（两数同为负）,而Zf=0（结果为正），正溢出.>［方法二］ Cs表示符号位的进位，Cp表示最高数值位进位，⊕表示异或。 若 Cs⊕Cp=0 ，无溢出； 若 Cs⊕Cp=1 ，有溢出。 >［方法三］ 用变形补码进行双符号位运算（正数符为00,负数符号以11） 若运算结果的符号位为\"01\",则正溢； 若结果双符号为10,则负溢出； 若结果的双符号位为00或11，无溢出。-从方法一，我才意识到之前理解的溢出是错误的，溢出并不是最高位有进位，而是有符号情况下同号相加时得到结果符合相反（也就是超过了可表示范围，当然，异号相加的时候不可能超过表示范围），而无符号的时候是没有溢出的，因为它满足模n加法。-搞清楚了溢出后，上面参考书的写法也就不难理解了，就是判断两个源操作数的符号和结果符号。-不过有一点值得注意，s_out是signed型，那么\"<\"和\">\"就是针对有符号的运算了（相当于C++中运算符的“重载”）。有符号的变量有可能“<0”，而一个不加signed的变量\">0\"是恒成立的。所以，在比较两个无符号数大小时，应该写成if(a>b)而不能写成if(a-b>0)，a-b得到还是无符号数，这个判断恒成立。##相关-Verilog中有符号和无符号混合运算：两个有符号数运算、两个无符号数运算、有符号数运算和无符号数运算。 只有两个操作数都是有符号数，才会把两个操作数都看作有符号数计算，否则无论是有符号数还是无符号数都会按照无符号数计算。##ALU中SLT的实现-明白了上面的知识，slt的实现也就非常简单了，可以两种写法：-一是无符号变量存储，自行判断符号 ```verilog if(alu_a[31]==alu_b[31])alu_out=(alu_a < alu_b)?32'b1:32'b0;//对于不加signed的变量类型，运算和比较视为无符号，但依然可以存储有符号数，这里相当于自行根据首位判断//首位相等，即同号情况，直接比较，如果同正，后面31位大的，原数就大，如果同负，后面31位（补码）大的，依然是原数大 else alu_out=(alu_a[31]< alu_b[31])?32'b0:32'b1;//异号情况，直接比较符号 ```-二是转为有符号，直接用“<”比较 `alu_out=($signed(alu_a)< $signed(alu_b))?32'b1:32'b0;`-测试一下，两种方法结果一样 ![](verilog_signed_and_unsigned/sltpic1.png)","tags":["Verilog"],"categories":[]},{"title":"操作系统阅读报告：大容量存储器与文件系统","url":"/s/p/9liw00/","content":"#大容量存储器与文件系统##大容量存储器简介-我们知道，程序执行时主要将信息存储在内存中，但由于内存太小，且具有易失性，并不适合长久保存数据。因此，计算机需要一些大容量外部存储器来备份信息，比如磁盘、磁带、光盘和固态硬盘等等，其中磁盘和固态硬盘是目前主要的外部存储器。速度、可靠性和价格是衡量大容量存储器性能的三个重要指标。##磁盘**（1）磁盘的结构**-**磁盘（Magnetic Disk）**由许多扁圆盘片堆叠而成，每个盘片两面涂有磁性材料，旁边是机械臂杆及其磁臂，磁臂上的磁头在盘片上移动并进行磁记录来实现信息的读取和写入。磁盘片的表面被逻辑地划分为多个**磁道（Track）**，磁道再被划分为**扇区（Secto）**，位于同一磁臂位置的磁道集合组成**柱面（Cylinder）**。 ![](File System/20180526055814104-1.jpg)图1-磁盘使用时会被驱动器高速旋转，磁头飞行于盘片的空气层上，定位到数据所在位置所需的时间由两部分组成：**寻道时间**（移动磁臂到所在的柱面）和**旋转等待时间**（等待某扇区旋转至磁头下）。定位时间越小，数据传输速率越高。磁盘旋转的角速度可以是匀速的或者变速的，由于扇区按角度划分，则前者的传输速率是内侧磁道高而外侧低，后者的传输速率是不变的，现在的磁盘主要采用前一方案。**（2）磁盘的管理**-良好的管理可以更高效地使用磁盘。磁盘在低级格式化后被划分为许多扇区（带有特殊数据结构的逻辑块），一般并不直接使用（当成巨大的顺序数组），而是进一步分为一个或多个柱面组成的分区，然后进行逻辑格式化，创建某种**文件系统（File System）**对磁盘进行管理。其中一个重要的方面是对坏块的管理，当某些逻辑块损坏时，一种方法是跳过坏块，顺序后移后续块，另一种方法是每条磁道预留一些块作为备用。 <!--more-->**（3）磁盘的调度**-由于磁盘具有特殊结构，在转速一定时，需要对磁盘的访问队列进行**调度**才能避免过长的寻道时间。-**FCFS**（先来先服务）调度是一种公平的调度算法，但一般性能不高。-**SSTF**（最短寻道时间优先）调度优先处理靠近当前磁头位置的请求，性能有了很大提高，但可能导致一些请求长时间得不到满足。-**SCAN**（扫描）调度将磁臂从一端移到另一端，顺序处理所到之处的请求，到达一端后反向扫描，如此循环，这种算法的问题在于，当一个请求在磁头从请求位置移动走后才被加入队列，则必须等待磁头到达一端并反向移动回来后才能处理。-**C-SCAN**调度是前者的一种改进，磁头到达一端后并不反向扫描，而是直接返回起始端重新开始扫描，这就解决了前一个问题，但实际上，如果在到达一端之前剩余的位置都没有请求，则磁头可以立刻返回，这就是**C-LOOK**调度，磁头只移动到一个方向上最远的请求。 ![](File System/20180526055814104-3.jpg)FCFS ![](File System/20180526055814104-4.jpg)SSTF ![](File System/20180526055814104-5.jpg)SCAN ![](File System/20180526055814104-6.jpg)C-SCAN ![](File System/20180526055814104-7.jpg)C-LOOK 图2##固态硬盘-**固态硬盘（SSD，Solid-State Drives）**主要由控制器和**闪存（Flash）**芯片组成，它具有速度快、质量轻、能耗小等优点，近来被广泛使用，但容量小，价格昂贵。闪存芯片被划分为不同的层次（Package>Die/Chip>Plane>Block>Page），最基本的存储单元是晶体管，每个单元可以存储一个bit（**SLC**），也可以存储多个bit（**MLC**）。固态硬盘的读写以Page（4KB）为单位，当一个Page的信息需要被删除时，它只是被标记为无效，而且不支持对一个Page进行修改，只有在适当的时候以Block为单位进行擦除，而一个Block可以擦除的次数是**有限**的，因此固态硬盘需要地址映射机制和垃圾回收机制，以此延长使用寿命。##RAID-单个磁盘读写性能并不高，而且一旦损坏，将导致数据丢失。随着单位存储价格的降低，人们通过增加大量磁盘形成**磁盘冗余阵列（RAID）**，以此提高**性能**和**可靠性**。一方面，通过**冗余**提高可靠性，最简单也最昂贵的方法是**镜像**，即复制每个磁盘。另一方面，通过**分散和并行**改善性能，最简单的方式是**位级分散**，即一个字节的8个位分散到8个磁盘上，则并行读取时可以提高为8倍传输速率，也可以用**块级分散**的方式，一个文件的块分散在多个磁盘上。-RAID具有不同的**级别**，体现对价格和效果的不同**权衡**，以下以4个盘为例介绍各级别。-RAID0：使用块级分散，但没有任何冗余，因此没有提高可靠性。-RAID1：即磁盘镜像，大大提高了可靠性，但花费巨大。-RAID01：即RAID0+1，先将数据分散到两块磁盘，再整体做镜像，这种方案同时提高了性能和可靠性，然而只要任意一块磁盘损坏，都只剩下一份镜像可用。-RAID10：即RAID1+0，先做镜像，再整体将数据分散到两块磁盘，这种方案比RAID01更优，当一个磁盘损坏时，RAID10的两份分散皆可用，而RAID01只有一份可用。这两种方案都存在开销过大的问题。-RAID2：以**汉明码（Hamming Code）**的方式将数据进行编码后按位级分散到各个磁盘上，汉明码方式是在原有数据中插入若干校验码，并且支持一位数据的纠错，如果某个磁盘损坏，可以通过其他磁盘重新计算以恢复数据。4位数据的存储需要额外增加3位校验码，这比RAID1节省了一个磁盘，但读写时需要对数据即时地进行校验，因此效率较低。-RAID3：以**奇偶校验（Parity Check）**的方式在多位数据后增加一位校验位，表示前面数据位中1的个数是奇数或偶数。这种方案使用位级分散，只需要一个额外的校验磁盘，但是当读写较频繁时，校验盘将会负载过大，成为系统性能的瓶颈。-RAID4：和RAID3类似，但使用块级分散。-RAID5：是对RAID4的改进，将奇偶校验信息分散存储到各个磁盘上而不是单个校验磁盘，这就避免了校验盘负载过大的情况，是目前应用较广泛的方案。-RAID6：在RAID5基础上增加了一位校验码（不再是奇偶校验），这样就可以容忍两个磁盘出错。##文件系统概述-如前文所述，磁盘只是纯粹的存储介质，一般磁盘格式化并不直接顺序存储数据，而是建立特定的**文件系统（File System）**来更好地管理磁盘。文件系统本身并不是磁盘也不是操作系统，而是存储在磁盘上，一个磁盘通常可以支持不同的文件系统。-文件系统通常具有**文件**和**目录**两种抽象的对象。-**文件（File）**是创建者定义的相关信息的集合，操作系统将其映射到存储器中，对用户而言，文件是最小的逻辑分配单元。文件的内容可以是文本、数字或二进制数据，其组织形式可以是自由的，也可以具有严格的格式，这通常由创建者定义。-为了能识别和引用不同的文件，文件通常具有各种**属性（Attributes）**。文件名是一个字符串，它独立于进程、用户甚至操作系统，这个字符串是否区分大小写取决于具体的操作系统。标识符是在文件系统中识别文件的唯一标签，通常为数字。类型则指明了这是特定类型的文件系统的文件。位置是文件在存储设备上的位置指针。大小记录了文件的当前大小或者最大允许容量。时间日期包括文件创建或者上次修改的相关时间信息。保护和权限则指明了不同用户能否对文件进行相关操作（读、写、执行等）。通常文件都具有以上这些属性，还有一些其他属性，但个别文件系统可能并不支持某些属性。值得注意的是，文件内容并不包括属性，所有的文件属性信息都存储在目录结构中。 ![](File System/20180526055814104-9.jpg)图3-**目录（Directory）**是用来管理和组织文件的结构，其本质也是一个文件，如右图。一个目录文件包含许多目录项，每一个**目录项（Entry）**保存一个文件的属性信息（名称、位置等），表示这个文件属于这个目录。一个目录下的允许再包含目录文件，这就形成了以根目录”/”为根的多层次的树状结构，其叶结点为文件。一个文件的名称前面加上各级父目录名称，用”/”分隔，这就形成了文件的路径名称。文件路径通常用于定位一个文件在文件系统中的层次和位置，因为它在整个文件系统中是独一无二的。如果以根目录为起点，称为**绝对路径**，如果以某个目录为起点，则称为**相对路径**。##文件系统的布局与操作-各种文件系统的本质区别在于采用不同的存储**布局结构（Layout）**，以及对文件的**操作（Operations）**的不同实现方式。-用户或进程通过操作系统的调用接口对文件进行操作，而操作系统为了能支持不同的文件系统，通常先实现一个**虚拟文件系统（VFS）**，在这个层面上隐藏了实现的细节，定义了抽象的操作集合，在它之下才是各个文件系统具体操作的实现。-**（1）**操作系统对文件进行的**操作**主要有：-**①创建：**在磁盘中申请一块空间，然后在文件所在的目录增加一个目录项，记录新文件的相关属性。值得注意的是，创建一个文件并不同时打开文件。-**②打开：**对文件进行操作时，需要通过路径逐级搜索和定位文件，为了避免频繁地进行这个过程，在首次使用文件时，需要显式（或隐式）地调用open()来“打开”文件，这将在内存中创建一个FILE类型结构体来存储文件的位置信息和其他属性，操作系统则维护一个包括所有打开文件的FILE结构体的列表，称为**打开文件表（Open-files table）**。进程需要对文件进行操作时，提供**文件标识符（File Descriptor）**即打开文件表的索引，而不再是路径。由于多个进程可以同时打开一个文件，为了避免相互影响，每个进程还需要单独维护一个进程的打开文件表，用于存储与进程相关的信息，比如对文件读写的偏移指针。-**③读：**首先进程向操作系统提供文件标识符，操作系统在打开文件表中查找到对应的FILE结构，从中获取文件位置和属性，在磁盘中定位和读取相应的数据后存储在内核空间中，最后写入进程指定的用户内存空间中。-**④写：**与读相反，先从用户内存空间读取数据到内核空间，然后操作系统将根据不同的策略适时地将数据写回磁盘。若采用**写直达法（Write-through mode）**，内核中的数据立刻被写入磁盘；若采用**写回法（Write-back mode）**，只有当内核空间中的数据需要进行更新时，这些数据才被写入磁盘。-**⑤文件内重定位：**直接修改文件偏移指针为指定值。-**⑥关闭：**当一个文件不再被使用时，关闭这个文件，打开文件表将移除对应的项。-**⑦删除：**将文件在磁盘中的空间释放，并删除目录文件中的对应项。-**⑧截短：**删除文件的内容但保留其属性，文件长度变为0。-以上①③④⑤⑦⑧构成了对文件操作的最小集合，由它们可以组合出其他的文件操作。-**（2）文件系统的布局实例**-对于连续的磁盘空间，不同的文件系统对其进行不同的**划分和组织**，这就形成了不同的布局。文件系统的实现至少应该满足以下几条要求： ①被写入的数据能够被重新检索出并读取。 ②对文件的操作应该是高效的。 ③当删除一个文件时，文件系统能清除对应的空间。 更详细的要求就是对上面各种文件操作的具体实现以及空间的具体分配和对空闲空间的管理，下面介绍几种布局的实现并逐步进行改进。**①连续分配方式**-这是最直接最朴素的想法，在磁盘连续空间的头部存放根目录，目录中记录各个文件的起始位置和结束位置，文件紧跟着存放在目录的后续空间中（如图4）。这种策略使得删除操作十分简单，只需要在目录文件中删除对应项就可以了。但是，在经过长时间使用后，磁盘的空闲空间将**碎片化**地分散在各个位置，文件系统无法迅速统计空闲空间大小。最大的问题是，如果需要存储一个大文件，有可能无法找到一个足够大的空闲片段来存放，即使存在并且使用了最优策略分配后，在需要增加文件内容时将面临两端皆有其他文件而无法**扩展**的窘境。一种解决方法是移动现有的文件使空闲空间连续，但是这将开销巨大。 ![](File System/20180526055814104-10.jpg)图4**②链式分配方式**-既然大文件可能没有足够大的空闲片段来存放，一个自然的想法是将磁盘划分为**相等大小的块/簇（Cluster）**，文件按块进行存储（如图5）。这些块可以不在连续的空间里，只需要在目录文件中记录每个文件占用的块的序号即可。但是，由于目录文件是目录项的数组，每一项的长度是固定的，因而对于分散的块序号的记录是比较困难的。 ![](File System/20180526055814104-11.png)图5-一种改进的方法是，目录项只记录文件起始块的序号，而在每个块中留出部分空间存放指向下一个块的指针（如图6），这种情况下，目录项中还需要记录文件的大小，因为文件的最后一块可能并没有填满。另外，还需要在磁盘最前端留出一块空间指向空闲空间的链表。这种策略带来的问题是随机访问性差，访问一个文件需要从头部开始。还有一个问题是关于块大小的选择，如果块太小，则块的指针占用了太多空间，如果块太大，则每个文件最后一个块的浪费将是巨大的。 ![](File System/20180526055814104-14.jpg)图6**③链式分配方式的改进——FAT**-为了改善随机读写性能，可以将下一个块的位置信息以数组形式统一存放在磁盘头部（如图7），称为**文件分配表（FAT，File Allocation Table）**。数组中每一项存放着当前下标对应的块的下一个块的序号（地址），根据地址长度的不同，可以分为不同版本**（FAT12/16/32）**。这种策略下寻找文件的方式为先从根目录中读取文件的第一个块的地址，然后到FAT中依次获得下一个块的地址并读取每个块。写入文件时，则先从空闲空间信息获取下一个空闲块的位置，然后写入数据并更新FAT和空闲块信息。删除文件时，相关的FAT置为0，更新空闲空间信息并删除目录中相关项。 ![](File System/20180526055814104-16.jpg)图7-以FAT32为例，磁盘空间分配如图8 所示，头部是引导扇区（存储扇区大小等信息）、文件系统的相关信息（包括空闲空间信息）和预留的空间，其后是两个文件分配表，接下来就是根目录和存储的文件。 ![](File System/20180526055814104-19.jpg)图8**④索引分配方式**-如果对FAT进行分割，每个文件对应的FAT单独存放在一个**索引节点（Index Node）**中，而目录项中指向每个文件对应的索引节点，这就是索引分配方式（如图9）。由于每个文件的FAT大小不同，则索引节点将是变长的，这对于管理十分不便。事实上的做法是，维护一个索引数组，每个索引节点长度固定，索引节点内部有12个指针指向**直接块（Direct Block）**，即数据块，还有一个指针指向**一级间接块（Indirect Block）**，间接块中的每一项才指向数据块，另外还各有一个指针指向二级间接块和三级间接块。假设一个块的大小为![](File System/20180526055814104-23.png)byte，块地址32位（4byte），则这种方式下单个文件最大可存储![](File System/20180526055814104-24.png)。 ![](File System/20180526055814104-20.jpg)图9-UNIX和Linux使用类似的索引方式的文件系统，称为**Ext2/Ext3/Ext4**。以Ext2为例，磁盘被划分为许多组（如图11）。每个组的头部都是一个**超级块（Superblock）**，其中包括全部索引节点数、全部空闲块数等信息。其后是**组描述符表（GDT，Group Descriptor Table）**，包括之后各部分的起始位置信息。然后是**块位图（Block Bitmap）**和**索引位图（Inode Bitmap）**，它们的每一位表示一个块/索引是否已经被使用（1表示已使用），最后就是索引节点数组和数据块了。 ![](File System/20180526055814104-22.jpg)图10 ![](File System/20180526055814104-25.jpg)图11##参考文献[1]Abraham Silberschatz.操作系统概念.高等教育出版社,2010.1.","tags":["OS"],"categories":[]},{"title":"计算机组成原理上机实验6 多周期CPU","url":"/s/p/9kutc0/","content":"##实验目的 1.实现一个多周期MIPS指令集的CPU，支持包括lw、sw、R-type、addi、beq、bgtz、j等指令。 2.运行一个计算斐波那契数列的程序，初始为3，3。##实验平台-ISE 14.7##实验过程（分析） 1.模块化设计，主要有以下几个模块 a)alu模块——算术逻辑单元 b)regfile模块——寄存器文件 c)mux模块和mux4模块——2路和4路选择器 d)IP核生成的Mem模块——存放数据段和代码段 e)nextpclogic模块——计算下一个PC f)dff模块——D触发器，用于多周期各段寄存 g)control模块——FSM控制regfile、IMem、DMem、nextpclogic和alu h)top模块——实例化前几个模块，连接各个信号 2.alu模块使用case语句判断8种操作类型。 3.regfile模块用组合逻辑读，时序逻辑写。 4.Mem是同步读，同步写，且由指定coe文件初始化，coe文件的内容是16进制文本，由Mars编译一个汇编代码生成。 5.nextpclogic模块通过组合逻辑计算出nextPC的值。 6.dff模块用一个always在时钟沿触发实现非阻塞赋值。 7.control模块内实现一个有限状态机，三段式实现： （1）时钟上升沿，改变当前状态，cstate<=nstate （2）组合逻辑根据当前状态和指令计算次态nstate （3）时钟下降沿，根据次态nstate，更新各控制信号（将在下一个上升沿起作用），下一周期需要使用的信号置为对应值，不使用的选择信号置x，不使用的使能置0。 控制信号如下表：|状态|S15|S0|S1|S2|S3|S4|S5|S6|S7|S8|S9|S10|S11||---|---|---|---|---|---|---|---|---|---|---|---|---|---||功能信号|Rst|Start|Instr decode|MM addr|MM read|read WB|MM write|R-type EXE|R-type WB|Beq|Addi EXE|Addi WB|Jump||LorD|0|0|x|x|1|x|1|x|x|x|x|x|x||MemRead||1|0|0|1|0|0|0|0|0|0|0|0||MemWrite||0|0|0|0|0|1|0|0|0|0|0|0||IRWrite||1|0|0|0|0|0|0|0|0|0|0|0||RegDst||x|x|x|x|0|x|x|1|x|x|0|x||MemtoReg||x|x|x|x|1|x|x|0|x|x|0|x||RegWrite||0|0|0|0|1|0|0|1|0|0|1|0||ALUSrcASel||0|0|1|x|x|x|1|x|1|1|x|x||ALUSrcBSel||01|11|10|xx|xx|xx|00|xx|00|10|xx|xx||ALUControl||001|001|001|xxx|xxx|xxx|②|xxx|010|001|xxx|xxx||Branch||0|0|0|0|0|0|0|0|1|0|0|0||PCWrite|1|1|0|0|0|0|0|0|0|0|0|0|1||PCSrc|11①|00|xx|xx|xx|xx|xx|xx|xx|01|xx|xx|10|注：①rst状态下PCSrc=11，利用4路选择器的剩余1路，置初始nextPC=0.②根据Funct具体设置不同的ALUControl ​ 状态机如下： ![](lab6_Multi-CycleCPU/pic1.png)8.top模块实例化其他所有模块，连接各个信号。 9.bgtz的实现：bgtz是伪指令（类似地有la和li），不是MIPS指令集的指令，编译时会进行处理，转换为几条指令实现。 这里我用以下三条指令 slt $t6,$zero,$t1#if $t1 > 0,that $t6=1,else $t6=0 addi $t7,$zero,1#set $t7=1 beq $t6,$t7,loop#jump if $t6=1,that is to say,$t1 > 0 实现 bgtz $t1,loop#repeat if not finished yet.<!--more--> 10.ram模块的初始化 IP核选择Block Memory，设置为Single Port RAM， ![](lab6_Multi-CycleCPU/pic2.png)宽度为32，深度为256 ![](lab6_Multi-CycleCPU/pic3.png)选中Load Init File设置，选择初始化coe文件的路径， ![](lab6_Multi-CycleCPU/pic4.png)其中coe文件内容为（Text段为0-63，Data段为64-255） MEMORY_INITIALIZATION_RADIX=16;MEMORY_INITIALIZATION_VECTOR=20080100 200d0150 8dad0000 200b0154 8d6b0000 200c0154 8d8c0004 ad0b0000 ad0c0004 21a9fffe 8d0b0000 8d0c0004 016c5020 ad0a0008 21080004 2129ffff 0009702a 200f0001 11cffff7 08000013 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000014 00000003 00000003 … 11.完整的数据通路 ![](lab6_Multi-CycleCPU/pic5.png)12.分析结果.data fibs:.word 0:20#\"array\" of 20 words to contain fib values size:.word 20#size of \"array\" temp:.word 3 3.text la $t0,fibs#load address of array la $t5,size#load address of size variable lw $t5,0($t5)#load array size la $t3,temp#load lw $t3,0($t3)la $t4,temp lw $t4,4($t4)sw $t3,0($t0)#F[0]=$t3 sw $t4,4($t0)#F[1]=$t4 addi $t1,$t5,-2#Counter for loop,will execute(size-2)times loop:lw $t3,0($t0)#Get value from array F[n]lw $t4,4($t0)#Get value from array F[n+1]add $t2,$t3,$t4#$t2=F[n]+F[n+1]sw $t2,8($t0)#Store F[n+2]=F[n]+F[n+1]in array addi $t0,$t0,4#increment address of Fib.number source addi $t1,$t1,-1#decrement loop counter slt $t6,$zero,$t1#if $t1 > 0,that $t6=1,else $t6=0 addi $t7,$zero,1#set $t7=1 beq $t6,$t7,loop#jump if $t6=1,that is to say,$t1 > 0 out:j out 完整汇编代码如上，可知程序先向内存数据段读取数组首地址（`$t0`）和大小（`$t5`，循环次数），读取并写入f[0]=3,f[1]=3，然后循环18次，执行f[i]=f[i-1]+f[i-2]计算斐波那契数列。 如果CPU编写正确，Mem[0-19]（由于Data和Text在同一个Ram，故实际上是在64-83）内容将是3、3、6、9、15、24、39、63、102、165、267、432、699、1131、1830、2961、4791、7752、12543、20295 Reg内容将是： $t0：最后一次循环后数组基址——256+4*18=328 $t1：剩余循环次数——0 $t2：最后一次的计算结果——20295 $t3：最后一次的计算数1——7752 $t4：最后一次的计算数2——12543 $t5：数组大小——20 $t6：最后一次不跳转——0 $t7：1##实验结果-仿真结果： 仿真得Mem和reg数据为 ![](lab6_Multi-CycleCPU/pic6.png)Mem ![](lab6_Multi-CycleCPU/pic7.png)Regfile 可见运行结果符合分析。##附录:-编写过程中遇到问题和一些发现 1.如果位拼接作为左值，单个变量也要花括号，如 `{{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9'b100100100;` 当然，本次实验中，我没有用位拼接赋值，这样写一行太长了，也不够清晰。 2.\"==\"会严格匹配每一位，比如module内5位数字比较（一个常量，一个input），但外部传入的是3位的，高位自动拓展好像是x，就导致“==”不成立，这是一个不好发现的问题。 3.仿真遇到高阻态，多半是这个信号不存在，经常是拼写错了，有时候ise检查不出来。 4.发现如果Mars的memory configuration设置为默认，则编译后导出代码里面的所有la（给某个寄存器赋值一个32位地址）被翻译为连续两句lui和ori；若memory configuration设置为text at address 0则编译后导出代码里面的所有la被翻译为一句addi。我觉得原因是text地址从0 开始的话，如果text部分较短，地址非0部分未超过16位，那么la只需要给低16位赋值就行了，就可以直接用addi实现（addi指令末16位为立即数）。如果地址是实打实的32位那addi就无能为力了，这时候需要lui给高16位赋值，低16位用ori（ori的rs取$0，作用就和addi一样）。 5.在top里的wire信号，如果通过control模块（或其他模块）进行控制，那么这个信号不能直接在top里赋初值，要到仿真模块里赋值，不然control里改变这个信号的值时，会变成不确定。 6.在clk边缘用<=对某信号（如state）进行赋值时，如果同时刻需要对该信号进行判断（如状态机，根据状态以完成对应操作），则判断时信号的值是本次改变前的。（非阻塞赋值的特性体现）-模块源代码-top.v ```verilog module top(//顶层模块 input clk,input rst_n,);wire ALUSrcASel;wire[1:0]ALUSrcBSel;wire[31:0]ALUSrcA;wire[31:0]ALUSrcB;wire[2:0]ALUControl;wire[31:0]ALUResult;wire[31:0]ALUResult_DFF;//加_DFF表示对应D触发器的输出，下同 wire Zero;wire[31:0]SignExtented;wire[5:0]RegRdaddr1;wire[31:0]RegRdout1;wire[31:0]RegRdout1_DFF;wire[5:0]RegRdaddr2;wire[31:0]RegRdout2;wire[31:0]RegRdout2_DFF;wire[5:0]RegWdaddr;wire[31:0]RegWdin;wire RegWrite;wire RegDst;wire[31:0]Memaddr_src;//这是计算出来的访存地址 wire[31:0]Memaddr;//这是计算出来的访存地址右移了两位，原因见下面 wire[31:0]Memout;wire[31:0]Memin;wire MemRead;wire MemWrite;wire MemtoReg;wire[31:0]Instr;wire[31:0]Data;wire[31:0]PC;wire[31:0]nextPC;wire PCEn;wire PCWrite;wire LorD;wire IRWrite;wire[5:0]Funct;wire[15:0]IMM16;wire[4:0]Rd;wire[4:0]Rt;wire[4:0]Rs;wire[5:0]Op;wire[25:0]JumpIMM;wire[1:0]PCSrc;wire Branch;//以上信号基本按数据通路图的命名，意义很明显，不多做注释了//=======================PC========================nextpclogic nextpclogic(PC,PCWrite,PCSrc,JumpIMM,Branch,Zero,ALUResult,ALUResult_DFF,nextPC,PCEn);dff DFFPC(~clk,nextPC,PC,PCEn);mux MUXPCALUout(LorD,PC,ALUResult_DFF,Memaddr_src);//=======================Memory========================assign Memaddr=Memaddr_src >> 2;//>>2是因为这里Mem是每个地址存储4字节，和实际上的（一地址一字节）不一样 Mem Mem(clk,MemWrite,Memaddr,Memin,Memout);dff DFFInstr(~clk,Memout,Instr,IRWrite);dff DFFData(~clk,Memout,Data,1'b1);assign JumpIMM=Instr[25:0];assign Funct=Instr[5:0];assign IMM16=Instr[15:0];assign Rd=Instr[15:11];assign Rt=Instr[20:16];assign Rs=Instr[25:21];assign Op=Instr[31:26];assign Memin=RegRdout2_DFF;//=======================Regfile========================assign RegRdaddr1=Rs;assign RegRdaddr2=Rt;mux#(6)MUXRegWdaddr(RegDst,{1'b0,Rt},{1'b0,Rd},RegWdaddr);mux MUXMemtoReg(MemtoReg,ALUResult_DFF,Data,RegWdin);regfile regfile(clk,rst_n,RegRdaddr1,RegRdout1,RegRdaddr2,RegRdout2,RegWdaddr,RegWdin,RegWrite);dff DFFRegRdout1(~clk,RegRdout1,RegRdout1_DFF,1'b1);dff DFFRegRdout2(~clk,RegRdout2,RegRdout2_DFF,1'b1);//=========================ALU==========================assign SignExtented={{16{IMM16[15]}},IMM16};mux MUXALUSrcA(ALUSrcASel,PC,RegRdout1_DFF,ALUSrcA);mux4 MUXALUSrcB(ALUSrcBSel,RegRdout2_DFF,4,SignExtented,SignExtented << 2,ALUSrcB);alu alu(ALUSrcA,ALUSrcB,{2'b00,{ALUControl}},ALUResult,Zero,Sign);dff DFFALUResult(~clk,ALUResult,ALUResult_DFF,1'b1);//=======================Control========================control control(clk,rst_n,Op,Funct,LorD,MemRead,MemWrite,IRWrite,RegDst,MemtoReg,RegWrite,ALUSrcASel,ALUSrcBSel,ALUControl,Branch,PCWrite,PCSrc,tcstate);endmodule ```-alu.v ```verilog parameter A_NOP=5'h00;//nop parameter A_ADD=5'h01;//sign_add parameter A_SUB=5'h02;//sign_sub parameter A_AND=5'h03;//and parameter A_OR=5'h04;//or parameter A_XOR=5'h05;//xor parameter A_NOR=5'h06;//nor parameter A_SLT=5'h07;//slt module alu(input[31:0]alu_a,input[31:0]alu_b,input[4:0]alu_op,output reg[31:0]alu_out,output zero);assign zero=(alu_out==32'b0)?1:0;always@(*)case(alu_op)A_NOP:alu_out=0;A_ADD:alu_out=alu_a+alu_b;A_SUB:alu_out=alu_a-alu_b;A_AND:alu_out=alu_a&alu_b;A_OR:alu_out=alu_a|alu_b;A_XOR:alu_out=alu_a^alu_b;A_NOR:alu_out=~(alu_a|alu_b);A_SLT://if a<b(signed)return 1 else return 0;begin if(alu_a[31]==alu_b[31])alu_out=(alu_a < alu_b)?32'b1:32'b0;//同号情况，后面的小于是视为无符号的比较 else alu_out=(alu_a[31]< alu_b[31])?32'b0:32'b1;//有符号比较符号 end default:;endcase endmodule ```-regfile.v ```verilog module regfile(//寄存器文件 input clk,input rst_n,input[5:0]rAddr1,//读地址1 output[31:0]rDout1,//读数据1 input[5:0]rAddr2,//读地址2 output[31:0]rDout2,//读数据2 input[5:0]wAddr,//写地址 input[31:0]wDin,//写数据 input wEna//写使能);reg[31:0]data[0:63];integer i;assign rDout1=data[rAddr1];//读1 assign rDout2=data[rAddr2];//读2 always@(posedge clk or negedge rst_n)//写和复位 if(~rst_n)begin for(i=0;i<64;i=i+1)data[i]<=0;end else begin if(wEna)data[wAddr]<=wDin;end endmodule ```-nextpclogic.v ```verilog module nextpclogic(//生成下一个PC input[31:0]PC,input PCWrite,input[1:0]PCSrc,input[25:0]JumpIMM,input Branch,input Zero,input[31:0]ALUResult,input[31:0]ALUResult_DFF,output[31:0]nextPC,output PCEn);wire[31:0]ShiftLeft2;wire[31:0]PCJump;wire tmp;assign ShiftLeft2=JumpIMM << 2;assign PCJump={{PC[31:28]},{{2'b00,JumpIMM}<<2}};mux4 MUXPC(PCSrc,ALUResult,ALUResult_DFF,PCJump,0,nextPC);and(tmp,Branch,Zero);or(PCEn,tmp,PCWrite);endmodule ```-dff.v ```verilog module dff#(parameter WIDTH=32)(//Data Flip-Flop input clk,input[WIDTH-1:0]datain,output reg[WIDTH-1:0]dataout,input en);always@(posedge clk)begin if(en)dataout <=datain;end endmodule ```-mux.v ```verilog module mux#(parameter WIDTH=32)(//2路选择器 input sel,input[WIDTH-1:0]d0,input[WIDTH-1:0]d1,output[WIDTH-1:0]out);assign out=(sel==1'b1?d1:d0);endmodule ```-mux4.v ```verilog module mux4#(parameter WIDTH=32)(//4路选择器 input[1:0]sel,input[WIDTH-1:0]d0,input[WIDTH-1:0]d1,input[WIDTH-1:0]d2,input[WIDTH-1:0]d3,output reg[WIDTH-1:0]out);always@(*)case(sel)2'b00:out=d0;2'b01:out=d1;2'b10:out=d2;2'b11:out=d3;default:;endcase endmodule ```-control.v ```verilog module control(//控制模块，各信号的控制 input clk,rst_n,input[5:0]Op,//instr[31:26]input[5:0]Funct,//instr[5:0]output reg LorD,output reg MemRead,output reg MemWrite,output reg IRWrite,output reg RegDst,output reg MemtoReg,output reg RegWrite,output reg ALUSrcASel,output reg[1:0]ALUSrcBSel,output reg[2:0]ALUControl,output reg Branch,output reg PCWrite,output reg[1:0]PCSrc,output[3:0]tcstate);reg[3:0]cstate;reg[3:0]nstate;assign tcstate=cstate;always @(posedge clk or negedge rst_n)//上升沿改变状态 if(~rst_n)cstate <=4'd15;//reset状态 else cstate <=nstate;always @(*)//计算次态 case(cstate)4'd15://reset nstate=4'd0;4'd0://fetch nstate=4'd1;4'd1://decode case(Op)6'b000000:nstate=4'd6;//R type 6'b100011:nstate=4'd2;//lw 6'b101011:nstate=4'd2;//sw 6'b000100:nstate=4'd8;//beq 6'b000010:nstate=4'd9;//jump 6'b001000:nstate=4'd10;//addi endcase 4'd2://memaddr case(Op)6'b100011:nstate=4'd3;//lw 6'b101011:nstate=4'd5;//sw endcase 4'd3://memread nstate=4'd4;4'd4://memwriteback nstate=4'd0;4'd5://memwrite nstate=4'd0;4'd6://execute nstate=4'd7;4'd7://aluwriteback nstate=4'd0;4'd8://branch nstate=4'd0;4'd9://jump nstate=4'd0;4'd10://addi execute nstate=4'd11;4'd11://addi writeback nstate=4'd0;endcase//根据下一状态更改控制信号（有使用的信号将更改并做注释，不使用的选择信号置x,不使用的使能置0）//这里虽然在下降沿更改，但信号将在下一周期（上升沿）起作用(也就是同在这个下降沿的操作读取到的信号是改变前的)always @(negedge clk or negedge rst_n)//下降沿时，根据次态，更改信号 begin if(~rst_n)begin LorD=1'b0;PCSrc=2'b11;//nextPC=0;利用4路选择器的剩余1路 PCWrite=1'b1;end else case(nstate)4'd0://fetch begin LorD=1'b0;//------Memaddr:PC MemRead=1'b1;//------enable Mem read MemWrite=1'b0;IRWrite=1'b1;//------enable save Instr RegDst=1'bx;MemtoReg=1'bx;RegWrite=1'b0;ALUSrcASel=1'b0;//------srcA:PC ALUSrcBSel=2'b01;//------srcB:4 ALUControl=3'b001;//------ALU's func:add Branch=1'b0;PCWrite=1'b1;//------enable update PC PCSrc=2'b00;//------select nextPC=PC+4 end 4'd1://decode begin LorD=1'bx;MemRead=1'b0;MemWrite=1'b0;IRWrite=1'b0;RegDst=1'bx;MemtoReg=1'bx;RegWrite=1'b0;ALUSrcASel=1'b0;//------srcA:PC ALUSrcBSel=2'b11;//------srcB:SignExtended<<2 ALUControl=3'b001;//------ALU's func:add Branch=1'b0;PCWrite=1'b0;PCSrc=2'bxx;end 4'd2://memaddr begin LorD=1'bx;MemRead=1'b0;MemWrite=1'b0;IRWrite=1'b0;RegDst=1'bx;MemtoReg=1'bx;RegWrite=1'b0;ALUSrcASel=1'b1;//------srcA:RegRdout1_DFF ALUSrcBSel=2'b10;//------srcB:SignExtended ALUControl=3'b001;//------ALU's func:add Branch=1'b0;PCWrite=1'b0;PCSrc=2'bxx;end 4'd3://memread begin LorD=1'b1;//------Memaddr:ALUResult_DFF MemRead=1'b1;//------enable Mem read MemWrite=1'b0;IRWrite=1'b0;RegDst=1'bx;MemtoReg=1'bx;RegWrite=1'b0;ALUSrcASel=1'bx;ALUSrcBSel=2'bxx;ALUControl=3'bxxx;Branch=1'b0;PCWrite=1'b0;PCSrc=2'bxx;end 4'd4://memwriteback begin LorD=1'bx;MemRead=1'b0;MemWrite=1'b0;IRWrite=1'b0;RegDst=1'b0;//------RegWdaddr:Rt MemtoReg=1'b1;//------RegWdin:Memout RegWrite=1'b1;//------enable Reg write ALUSrcASel=1'bx;ALUSrcBSel=2'bxx;ALUControl=3'bxxx;Branch=1'b0;PCWrite=1'b0;PCSrc=2'bxx;end 4'd5://memwrite begin LorD=1'b1;//------Memaddr:ALUResult_DFF MemRead=1'b0;MemWrite=1'b1;//------enable Mem write IRWrite=1'b0;RegDst=1'bx;MemtoReg=1'bx;RegWrite=1'b0;ALUSrcASel=1'bx;ALUSrcBSel=2'bxx;ALUControl=3'bxxx;Branch=1'b0;PCWrite=1'b0;PCSrc=2'bxx;end 4'd6://R type execute begin LorD=1'bx;MemRead=1'b0;MemWrite=1'b0;IRWrite=1'b0;RegDst=1'bx;MemtoReg=1'bx;RegWrite=1'b0;ALUSrcASel=1'b1;//------srcA:RegRdout1_DFF ALUSrcBSel=2'b00;//------srcB:RegRdout2_DFF case(Funct)//------ALU's func:decided by 'Funct' 6'b100000:ALUControl=5'h01;//add 6'b100010:ALUControl=5'h02;//sub 6'b100100:ALUControl=5'h03;//and 6'b100101:ALUControl=5'h04;//or 6'b100110:ALUControl=5'h05;//xor 6'b100111:ALUControl=5'h06;//nor 6'b101010:ALUControl=5'h07;//slt endcase Branch=1'b0;PCWrite=1'b0;PCSrc=2'bxx;end 4'd7://aluwriteback begin LorD=1'bx;MemRead=1'b0;MemWrite=1'b0;IRWrite=1'b0;RegDst=1'b1;//------RegWdaddr:Rd MemtoReg=1'b0;//------RegWdin:ALUResult_DFF RegWrite=1'b1;//------enable Reg write ALUSrcASel=1'bx;ALUSrcBSel=2'bxx;ALUControl=3'bxxx;Branch=1'b0;PCWrite=1'b0;PCSrc=2'bxx;end 4'd8://branch begin LorD=1'bx;MemRead=1'b0;MemWrite=1'b0;IRWrite=1'b0;RegDst=1'bx;MemtoReg=1'bx;RegWrite=1'b0;ALUSrcASel=1'b1;//------srcA:RegRdout1_DFF ALUSrcBSel=2'b00;//------srcB:RegRdout2_DFF ALUControl=3'b010;//------ALU's func:sub Branch=1'b1;//------enable update PC if beq PCWrite=1'b0;PCSrc=2'b01;//------select nextPC=ALUResult_DFF(PCBeq)end 4'd9://jump begin LorD=1'bx;MemRead=1'b0;MemWrite=1'b0;IRWrite=1'b0;RegDst=1'bx;MemtoReg=1'bx;RegWrite=1'b0;ALUSrcASel=1'bx;ALUSrcBSel=2'bxx;ALUControl=3'bxxx;Branch=1'b0;PCWrite=1'b1;//------enable update PC PCSrc=2'b10;//------select nextPC=PCJump end 4'd10://addi execute begin LorD=1'bx;MemRead=1'b0;MemWrite=1'b0;IRWrite=1'b0;RegDst=1'bx;MemtoReg=1'bx;RegWrite=1'b0;ALUSrcASel=1'b1;//------srcA:RegRdout1_DFF ALUSrcBSel=2'b10;//------srcB:SignExtended ALUControl=3'b001;//------ALU's func:add Branch=1'b0;PCWrite=1'b0;PCSrc=2'bxx;end 4'd11://addi regwriteback begin LorD=1'bx;MemRead=1'b0;MemWrite=1'b0;IRWrite=1'b0;RegDst=1'b0;//------RegWdaddr:Rt MemtoReg=1'b0;//------RegWdin:ALUResult_DFF RegWrite=1'b1;//------enable Reg write ALUSrcASel=1'bx;ALUSrcBSel=2'bxx;ALUControl=3'bxxx;Branch=1'b0;PCWrite=1'b0;PCSrc=2'bxx;end endcase end endmodule ```-test.v ```verilog module test;//Inputs reg clk;reg rst_n;//Instantiate the Unit Under Test(UUT)top uut(.clk(clk),.rst_n(rst_n),);initial begin//Initialize Inputs clk=1;//rst_n=1;#100;//rst_n=0;//Wait 100 ns for global reset to finish#100;rst_n=1;forever begin#10;clk=~clk;end//Add stimulus here end endmodule ```","tags":["Verilog","COD"],"categories":[]},{"title":"计算机组成原理上机实验5 单周期CPU","url":"/s/p/9kjpc0/","content":"##实验目的-综合前几次实验的结果，实现一个单周期MIPS指令集的CPU， 然后运行一个计算斐波那契数列的程序。##实验平台-ISE 14.7##实验过程（分析） 1.模块化设计，主要有以下几个模块 a)alu模块——算术逻辑单元 b)regfile模块——寄存器文件 c)mux模块——选择器 d)IP核生成的IMem模块和DMem模块——存放数据段和代码段 e)nextpclogic模块——计算下一个PC f)control模块——控制regfile、IMem、DMem、nextpclogic和alu g)top模块——实例化前几个模块，连接各个信号 2.alu模块使用case语句判断8种操作类型。 3.regfile模块用组合逻辑读，时序逻辑写。 4.IMem和DMem是异步读，同步写，且由指定coe文件初始化，coe文件的内容是16进制文本，由Mars编译一个汇编代码生成。 5.nextpclogic模块通过组合逻辑计算出nextPC的值。 6.control模块根据输入的操作符Op对各控制变量进行赋值，根据ALUOp对ALUControl进行赋值。 7.top模块实例化前几个模块，连接各个信号。 8.bgtz的实现：bgtz是伪指令（类似地有la和li），不是MIPS指令集的指令，编译时会进行处理，转换为几条指令实现。 这里我用以下三条指令 ```assembly slt $t6,$zero,$t1#if $t1 > 0,that $t6=1,else $t6=0 addi $t7,$zero,1#set $t7=1 beq $t6,$t7,loop#jump if $t6=1,that is to say,$t1 > 0 ``` 实现 ```assembly bgtz $t1,loop#repeat if not finished yet.``` 9.完整的数据通路 ![](lab5_SingleCycleCPU/20180527111736051-1.png)10、分析结果 ```assembly.data fibs:.word 0:20#\"array\" of 20 words to contain fib values size:.word 20#size of \"array\" temp:.word 3 3.text la $t0,fibs#load address of array la $t5,size#load address of size variable lw $t5,0($t5)#load array size la $t3,temp#load lw $t3,0($t3)la $t4,temp lw $t4,4($t4)sw $t3,0($t0)#F[0]=$t3 sw $t4,4($t0)#F[1]=$t4 addi $t1,$t5,-2#Counter for loop,will execute(size-2)times loop:lw $t3,0($t0)#Get value from array F[n]lw $t4,4($t0)#Get value from array F[n+1]add $t2,$t3,$t4#$t2=F[n]+F[n+1]sw $t2,8($t0)#Store F[n+2]=F[n]+F[n+1]in array addi $t0,$t0,4#increment address of Fib.number source addi $t1,$t1,-1#decrement loop counter slt $t6,$zero,$t1#if $t1 > 0,that $t6=1,else $t6=0 addi $t7,$zero,1#set $t7=1 beq $t6,$t7,loop#jump if $t6=1,that is to say,$t1 > 0 out:j out ```-完整汇编代码如上，可知程序先向内存数据段读取数组首地址和大小（循环次数），读取并写入f[0]=3,f[1]=3，然后循环18次，执行f[i]=f[i-1]+f[i-2]计算斐波那契数列。-如果CPU编写正确，DMem[0-19]内容 将是3、3、6、9、15、24、39、63、102、165、267、432、699、1131、1830、2961、4791、7752、12543、20295 <!--more-->##实验结果-仿真结果 IP核ram设置界面中Load In设置初始化coe文件的路径， 其中IMem内容为 MEMORY_INITIALIZATION_RADIX=16;MEMORY_INITIALIZATION_VECTOR=20080000,200d0050,8dad0000,200b0054,8d6b0000,200c0054,8d8c0004,ad0b0000,ad0c0004,21a9fffe,8d0b0000,8d0c0004,016c5020,ad0a0008,21080004,2129ffff,1d20fff9,08000011,DMem内容为 MEMORY_INITIALIZATION_RADIX=16;MEMORY_INITIALIZATION_VECTOR=00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000014 00000003 00000003 仿真得DMem和reg数据为 ![](lab5_SingleCycleCPU/20180527111736051-2.png)DMem ![](lab5_SingleCycleCPU/20180527111736051-3.png)Regfile 可见运行结果符合分析。##附录:-编写过程中遇到问题和一些发现 1.位拼接作为左值，单个变量也要花括号，如 `{{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9'b100100100;` 2.\"==\"会严格匹配每一位，比如module内5位数字比较（一个常量，一个input），但外部传入的是3位的，高位自动拓展好像是x，就导致“==”不成立，这是一个不好发现的问题。 3.仿真遇到高阻态，多半是这个信号不存在，经常是拼写错了，有时候ise检查不出来。 4.发现如果Mars的memory configuration设置为默认，则编译后导出代码里面的所有la（给某个寄存器赋值一个32位地址）被翻译为连续两句lui和ori；若memory configuration设置为text at address 0则编译后导出代码里面的所有la被翻译为一句addi。我觉得原因是text地址从0 开始的话，如果text部分较短，地址非0部分未超过16位，那么la只需要给低16位赋值就行了，就可以直接用addi实现（addi指令末16位为立即数）。如果地址是实打实的32位那addi就无能为力了，这时候需要lui给高16位赋值，低16位用ori（ori的rs取$0，作用就和addi一样）。-模块源代码-top.v ```verilog module top(input clk,input rst_n,);wire ALUSrc;wire[31:0]ALUSrcA;wire[31:0]ALUSrcB;wire[2:0]ALUControl;wire[31:0]ALUResult;wire Zero;wire[31:0]SignExtented;wire[5:0]RegRdaddr1;wire[31:0]RegRdout1;wire[5:0]RegRdaddr2;wire[31:0]RegRdout2;wire[5:0]RegWdaddr;wire[31:0]RegWdin;wire RegWrite;wire RegDst;wire[31:0]DMemaddr;wire[31:0]DMemout;wire[31:0]DMemin;wire DMemWrite;wire[31:0]IMemRdaddr;wire[31:0]IMemRdout;wire MemtoReg;wire[31:0]Instr;reg[31:0]PC=0;wire[31:0]nextPC;wire[5:0]Funct;wire[15:0]IMM16;wire[4:0]Rd;wire[4:0]Rt;wire[4:0]Rs;wire[5:0]Op;wire[25:0]JumpIMM;wire Jump;wire Branch;integer first;//=======================PC========================always @(posedge clk or negedge rst_n)if(~rst_n)begin first <=1;PC <=0;end else if(first==1)begin first <=0;PC <=PC;end else PC <=nextPC;nextpclogic nextpclogic(PC,Jump,JumpIMM,Branch,Zero,SignExtented,nextPC);//=====================Instruction Memory======================assign IMemRdaddr=PC >> 2;//>>2是因为这里IMem是每个地址存储4字节，和实际上的（一地址一字节）不一样 IMem IMem(0,0,IMemRdaddr,0,0,IMemRdout);assign Instr=IMemRdout;assign JumpIMM=Instr[25:0];assign Funct=Instr[5:0];assign IMM16=Instr[15:0];assign Rd=Instr[15:11];assign Rt=Instr[20:16];assign Rs=Instr[25:21];assign Op=Instr[31:26];//=======================Regfile========================assign RegRdaddr1=Rs;assign RegRdaddr2=Rt;mux#(6)MUXRegWdaddr(RegDst,{1'b0,Rt},{1'b0,Rd},RegWdaddr);regfile regfile(~clk,rst_n,RegRdaddr1,RegRdout1,RegRdaddr2,RegRdout2,RegWdaddr,RegWdin,RegWrite);//=========================ALU==========================assign SignExtented={{16{IMM16[15]}},IMM16};assign ALUSrcA=RegRdout1;mux MUXALUSrc(ALUSrc,RegRdout2,SignExtented,ALUSrcB);alu alu(ALUSrcA,ALUSrcB,{2'b00,{ALUControl}},ALUResult,Zero);//=======================Control========================control control(clk,Op,Funct,RegDst,ALUSrc,MemtoReg,RegWrite,DMemWrite,Branch,ALUControl,Jump);//=======================Data Memory========================assign DMemaddr=ALUResult >> 2;//>>2理由同上 assign DMemin=RegRdout2;DMem DMem(DMemaddr,DMemin,~clk,DMemWrite,DMemout);mux MUXtoReg(MemtoReg,ALUResult,DMemout,RegWdin);endmodule ```-alu.v ```verilog parameter A_NOP=5'h00;//nop parameter A_ADD=5'h01;//sign_add parameter A_SUB=5'h02;//sign_sub parameter A_AND=5'h03;//and parameter A_OR=5'h04;//or parameter A_XOR=5'h05;//xor parameter A_NOR=5'h06;//nor parameter A_SLT=5'h07;//slt module alu(input[31:0]alu_a,input[31:0]alu_b,input[4:0]alu_op,output reg[31:0]alu_out,output zero);assign zero=(alu_out==32'b0)?1:0;always@(*)case(alu_op)A_NOP:alu_out=0;A_ADD:alu_out=alu_a+alu_b;A_SUB:alu_out=alu_a-alu_b;A_AND:alu_out=alu_a&alu_b;A_OR:alu_out=alu_a|alu_b;A_XOR:alu_out=alu_a^alu_b;A_NOR:alu_out=~(alu_a|alu_b);A_SLT://a<b(signed)return 1 else return 0;begin if(alu_a[31]==alu_b[31])alu_out=(alu_a < alu_b)?32'b1:32'b0;//同号情况，后面的小于是视为无符号的比较 else alu_out=(alu_a[31]< alu_b[31])?32'b0:32'b1;//有符号比较符号 end default:;endcase endmodule ```-regfile.v ```verilog module regfile(input clk,input rst_n,input[5:0]rAddr1,//读地址1 output[31:0]rDout1,//读数据1 input[5:0]rAddr2,//读地址2 output[31:0]rDout2,//读数据2 input[5:0]wAddr,//写地址 input[31:0]wDin,//写数据 input wEna//写使能);reg[31:0]data[0:63];integer i;assign rDout1=data[rAddr1];//读1 assign rDout2=data[rAddr2];//读2 always@(posedge clk or negedge rst_n)//写和复位 if(~rst_n)begin for(i=0;i<64;i=i+1)data[i]<=0;end else begin if(wEna)data[wAddr]<=wDin;end endmodule ```-nextpclogic.v ```verilog module nextpclogic(input[31:0]PC,input Jump,input[25:0]JumpIMM,input Branch,input Zero,input[31:0]SignExtented,output[31:0]nextPC);wire[31:0]ShiftLeft2;wire PCSrc;wire[31:0]PCPlus4;wire[31:0]PCBeq;wire[31:0]tmpPC;wire tmpzero1,tmpzero2;//no used assign ShiftLeft2=SignExtented << 2;alu ALUPCPlus4(PC,4,A_ADD,PCPlus4,tmpzero1);alu ALUPCOffset(ShiftLeft2,PCPlus4,A_ADD,PCBeq,tmpzero2);and(PCSrc,Branch,Zero);mux MUXPC(PCSrc,PCPlus4,PCBeq,tmpPC);mux MUXPC2(Jump,tmpPC,{{PCPlus4[31:28]},{{2'b00,JumpIMM}<<2}},nextPC);endmodule ```-control.v ```verilog module control(input clk,input[5:0]Op,//instr[31:26]input[5:0]Funct,//instr[5:0]output reg RegDst,output reg ALUSrc,output reg MemtoReg,output reg RegWrite,output reg MemWrite,output reg Branch,output reg[2:0]ALUContol,output reg Jump);reg[1:0]ALUOp;always @(*)begin case(Op)6'b000000://R type{{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9'b100100100;6'b100011://lw{{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9'b011100000;6'b101011://sw{{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9'bx1x010000;6'b000100://beq{{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9'bx0x001010;6'b000010://jump{{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9'bxxxxxxxx1;6'b001000://addi{{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9'b010100000;default:;endcase end always @(*)begin case(ALUOp)2'b00://lw,sw,addi ALUContol=5'h01;//add 2'b01://beq ALUContol=5'h02;//sub 2'b10://R type case(Funct)6'b100000:ALUContol=5'h01;//add 6'b100010:ALUContol=5'h02;//sub 6'b100100:ALUContol=5'h03;//and 6'b100101:ALUContol=5'h04;//or 6'b100110:ALUContol=5'h05;//xor 6'b100111:ALUContol=5'h06;//nor 6'b101010:ALUContol=5'h07;//slt default:;endcase 2'b11:ALUContol=5'h00;//nop default:;endcase end endmodule ```-mux.v ```verilog module mux#(parameter WIDTH=32)(input sel,input[WIDTH-1:0]d0,input[WIDTH-1:0]d1,output[WIDTH-1:0]out);assign out=(sel==1'b1?d1:d0);endmodule ```-test.v ```verilog module test;//Inputs reg clk;reg rst_n;//Instantiate the Unit Under Test(UUT)top uut(.clk(clk),.rst_n(rst_n),);always#10 clk=~clk;initial begin//Initialize Inputs clk=0;rst_n=0;//Wait 100 ns for global reset to finish#100;rst_n=1;//Add stimulus here end endmodule ```","tags":["Verilog","COD"],"categories":[]},{"title":"操作系统阅读报告：进程通信与同步、进程调度","url":"/s/p/9k31c0/","content":"#进程通信与同步、进程调度##进程间通信-进程在执行过程中，如果不被其他进程影响或影响其他进程，则称该进程是独立的，否则称为协作的。进程协作可能是出于以下几个目的：信息共享、提高计算速度、模块化设计…进程间要实现协作就需要一套**通信机制（IPC）**，目前主要有两种模式：共享内存和消息传递。-**消息传递模型。**通过在进程间交换消息来实现通信，它易于实现，不需要避免冲突，但是需要内核介入，时间消耗大，且只能传递少量信息。消息传递可以分为直接通信和间接通信，直接通信明确指定了接收者和发送者，而间接通信在多个进程间共享了一个虚拟邮箱，消息经过邮箱中转。另外，消息传递的实现可以是阻塞（同步）或非阻塞（异步）的，阻塞指发送者（接收者）一直等待直至消息被接收（有消息可用），非阻塞则不等待，如果二者皆阻塞，则它们之间就有一个“集合点”。-**共享内存模型。**通过建立一块允许多个进程读写的内存区域实现通信，它能以较快的速度通信，可以传递较多信息，但实现较为复杂。共享内存有一个典型的生产者-消费者问题，生产者产生信息以供消费者使用，为了使它们能并发执行，在共享内存中设置一个缓冲队列，生产者可以加入一项信息，消费者可以取走一项信息。如果缓冲为空，则消费者必须等待，如果缓冲有限且已满，则生产者必须等待。-进程间通信还可以通过**套接字（Socket）**和**管道（Pipe）**实现。套接字由一个IP地址和端口组成，它必须独一无二，确保服务器和客户端的连接，这种方法通常用在不同计算机之间。管道可以实现父子进程之间的通信，可以是匿名或者命名的，但是只能单向传递信息。-进程间协作的一个关键问题是出现**竞争（Race）**，即同时操作一个变量，这将导致执行结果与访问的特定顺序有关。 <!--more-->##进程同步-为了解决进程的竞争问题，**进程同步**是十分必要的。同步的一个基本要求是**互斥**，即两个进程不能同时操作一个共享的资源，为此，需要定义一个**临界区**，多个进程不能同时处在临界区中，并且等待进入临界区的时间应该是有限的，即临界区应该尽可能地短。此外，还要实现进入临界区和退出临界区的操作，并且能够选择一个合适的进程进入临界区。-目前有几种实现方式，一方面是从硬件来考虑。当进程要进入临界区时，关闭中断，退出临界区时，开启中断，这种方式使得其他进程不能运行，并且在多处理器环境中开销巨大。-另一方面是在软件层面来解决。-一个简单的方法是**严格的轮换法**，通过设置一个变量turn标识，仅取值0/1，代表允许哪个进程进入临界区，进程要进入临界区时检查turn，如果不是自己则等待，退出临界区时，将turn置为对方标识，这种方法会导致CPU资源的浪费，并且一个进程不能连续两次进入临界区。-**Peterson****方法**则对此进行了改进，增加了一个布尔型数组表示每个进程是否希望进入临界区，每个进程要进入临界区时检查该数组，如果其他进程也想进入则该进程做出让步。这种方法不会形成严格的轮换，相反地，有可能一个进程一直占着临界区导致一个更高优先级的进程无法进入。-还有一种实现方法是**互斥锁**，通过共享一个新的变量lock，进程要进入临界区时请求锁并等待至锁被释放，退出临界区时释放锁。这种方法要求请求和释放锁的操作是一种**原子操作**（不可中断地），但这种硬件层面的实现并不简单。以上几种方法都存在的问题是等待进入临界区时CPU资源的浪费。-实际上，一个较好的方法是通过**信号量（Semaphore）**实现，这类似一个交通指挥者。它定义一个共享的变量Semaphore，可以是二值的（0/1，类似于互斥锁）或者是多值/计数的（表示资源数量），还实现了两个对信号量的操作up()和down()，进程请求资源时down()，释放资源时up()。当down()操作不能被满足时，该进程不是wait而是通过特殊的sleep使自己进入等待队列，这样就不会浪费CPU资源，并且其他进程up()时会唤醒队列中等待的进程（只能是一个），该进程的down()继续执行，并进入临界区。-使用信号量能较好地解决几个经典问题：**生产者****-****消费者问题、哲学家进餐问题**（哲学家围绕而坐，相邻两人共享一根筷子）、**读者****-****写者问题**（读者与写者以及两个写者之间不能同时操作）。如对于生产者-消费者问题，设置一个二值信号量mutex（确保互斥）和两个计数信号量empty/full（监视缓存的情况），生产者生产一个资源之前要先down(empty)，再down(mutex)，完成后先up(mutex)再up(full)，消费者的过程类似。-进程同步经常遇到的一个问题是**死锁（Deadlock）**。死锁的出现的原因是一个资源只能同时被一个进程使用，而进程占用一个资源时又在等待其他资源，并且不能抢占，这就形成了一个循环等待的情况。比如生产者-消费者问题中将两个down()的顺序弄反了，生产者获得mutex等待empty，而消费者等待mutex，这就形成了死锁。##进程调度-多道程序设计允许同时运行多个进程，通过在进程间切换以达到该效果。一般进程执行过程中包括了多个CPU区间和I/O等待区间，在I/O区间时，CPU空闲，为了不浪费CPU这个宝贵的资源，因此需要进程调度，当一个进程等待时（如I/O等待），操作系统将CPU使用权交给其他进程，确保CPU不会空闲。-进程调度包括**抢占**的和**非抢占**的。如果调度只发生在进程必须等待或者结束时，则为非抢占调度，否则称为抢占调度。非抢占调度允许进程更连续地执行，但可能发生CPU占用时间过长，抢占调度则使得每个进程能更快得到CPU的响应。现代操作系统几乎都是抢占调度。-进程调度的**准则**主要有CPU使用率、吞吐量、周转时间、等待时间和响应时间等。CPU使用率应该尽可能高，实际情况在40%~90%较好。吞吐量指单位时间完成进程的数量，也是越高越好。周转时间指从进程提交到完成的所有时间段之和（包括等待进入内存、在就绪队列等待、执行和I/O），等待时间即在就绪队列花费的时间，响应时间即进程提交到开始响应的时间，这三者都是越低越好。但是，这些准则之间是有冲突的，在不同环境下各有所侧重。-进程调度的**算法**主要包括先到先服务（FCFS）、最短作业优先（SJF）、轮转法（RR）、优先级调度和多级队列调度。-**先到先服务**顾名思义，由一个FIFO队列实现，并且是非抢占的，进程执行直到等待或结束，如果一个长进程先到达，这将导致平均等待时间过长。-**最短作业调度**每次选择一个CPU区间最短的进程执行，并且可以分为抢占式和非抢占式的，这种调度方法最大的困难在于不知道下一个CPU区间的长度，一种解决方法是通过公式![](Process Communication&Synchronization&Scheduling/20180526054518142-1.png)来预测。-**轮转法**是定义了一个较小的时间单元（时间片），就绪队列作为循环队列，被调度执行的进程在达到一个时间片的时间后被重新加入队尾，显然，这是抢占的（除非进程长度小于时间片）。时间片的大小很大程度上决定了RR调度的性能，过长将变成FCFS，过短将导致进程切换开销过大，根据经验，80%的CPU区间应该小于时间片。-**优先级调度**为每个进程设置了优先级，优先级高（数值不一定是高）的进程先执行，同样也可以分为抢占和非抢占的，这种调度的主要问题是无穷阻塞（饥饿），即低优先级的进程可能很久都不能得到执行。-**多级队列调度**则是优先级调度的一种拓展，进程被划分为多个队列，每个队列有不同的优先级，队列内部则可以根据不同属性采取以上几种不同的调度方法。进一步地，如果允许进程在不同队列之间转移，这就形成了多级反馈队列调度。-**多级反馈队列调度**，根据进程的执行和等待时间动态调整优先级，可以防止饥饿发生，当然这种调度算法也最为复杂。##参考文献:[1]Abraham Silberschatz.操作系统概念.高等教育出版社,2010.1.","tags":["OS"],"categories":[]},{"title":"计算机组成原理上机实验4 有限状态机","url":"/s/p/9jrxc0/","content":"##实验目的-综合利用三次实验的结果，完成以下功能：-通过例化，向ram中0地址到13地址存入14个数，比如10-23；向ram中100地址到106地址存入7个数，比如0~6，分别代表运算符（与ALU的操作符对应），最后向ram 107地址写入-1-运算控制：-从ram 0地址开始的地方取两个数，分别放在reg0和reg1，然后从ram 100地址开始的地方取一个运算符，放到reg2，计算之后，把结果存入ram地址200-从ram 2地址开始的地方取两个数，分别放在reg0和reg1，从ram 101地址开始的地方取一个运算符，放到reg2，计算之后，把结果存入ram地址201-……-如果取出操作符为-1，则结束。##实验平台 ISE 14.7##实验过程（分析） 1.模块化设计，一个alu模块，一个regfile模块，一个IP核生成的ram模块，一个control模块，控制reg、ram和alu，顶层一个top模块实例化前几个模块，ram初始化有coe文件读入。 2.alu模块使用case语句判断7种操作类型。 3.regfile模块用组合逻辑读，时序逻辑写。 4.control模块思路（4周期）由于reg在这里没有实质作用（仅是复制了一份存储），故不考虑相关控制 ![](lab4_FiniteStateMachine/pic1.png)其中ram_ra为ram读地址，ram_rd为ram读数据，ram_we为ram写使能，tda、tdb为临时寄存上一周期的结果。 5.分析结果|Op|Data1|Data2|Result||---|:---:|:---:|:---:||0(nop)|11|10|0||1(add)|13|12|25||2(sub)|15|14|1||3(and)|17(32’b0…10001)|16(32’b0…10000)|16(32’b0…10000)||4(or)|19(32’b0…10011)|18(32’b0…10010)|19(32’b0…10011)||5(xor)|21(32’b0…10101)|20(32’b0…10100)|1(32’b0…00001)||6(nor)|23(32’b0…10111)|22(32’b0…10110)|-24(32’b1…101000)|<!--more-->##实验结果-仿真结果 IP核ram设置界面中Load In设置ram初始化coe文件的路径，其中文件内容为 MEMORY_INITIALIZATION_RADIX=10;MEMORY_INITIALIZATION_VECTOR=10,11,12,13,14,15,16,17,18,19,20,21,22,23,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 仿真得ram和reg数据为 ![](lab4_FiniteStateMachine/pic2.png)…… ![](lab4_FiniteStateMachine/pic3.png)…… ![](lab4_FiniteStateMachine/pic4.png)可见计算结果符合分析。##附录:-模块源代码 top.v ```verilog module top(input clk,input rst_n);wire[5:0]ra;wire[5:0]wa;wire[31:0]rd;wire[31:0]wd;wire[31:0]aluout;reg we=1'b1;wire[31:0]tda;wire[31:0]tdb;wire clkb;wire ram_we;wire[7:0]ram_ra;wire[7:0]ram_wa;wire[31:0]ram_rd;wire[31:0]ram_wd;alu alu1(ram_rd,tdb,tda,aluout);regfile regfile1(clk,rst_n,ra,wa,wd,we,rd);control control1(clk,rst_n,aluout,ra,rd,wa,wd,tda,tdb,ram_we,ram_ra,ram_rd,ram_wa,ram_wd);ram ram1(clk,ram_we,ram_wa,ram_wd,clk,ram_ra,ram_rd);endmodule ``` alu.v ```verilog parameter A_NOP=5'h00;//nop parameter A_ADD=5'h01;//sign_add parameter A_SUB=5'h02;//sign_sub parameter A_AND=5'h03;//and parameter A_OR=5'h04;//or parameter A_XOR=5'h05;//xor parameter A_NOR=5'h06;//nor module alu(input[31:0]alu_a,input[31:0]alu_b,input[4:0]alu_op,output reg[31:0]alu_out);always@(*)case(alu_op)A_NOP:alu_out=0;A_ADD:alu_out=alu_a+alu_b;A_SUB:alu_out=alu_a-alu_b;A_AND:alu_out=alu_a&alu_b;A_OR:alu_out=alu_a|alu_b;A_XOR:alu_out=alu_a^alu_b;A_NOR:alu_out=~(alu_a|alu_b);default:alu_out=0;endcase endmodule ``` regfile.v ```verilog module regfile(input clk,input rst_n,input[5:0]rAddr1,//读地址 input[5:0]wAddr,//写地址 input[31:0]wDin,//写数据 input wEna,//写使能 output[31:0]rDout1//读数据1);reg[31:0]data[0:63];integer i;assign rDout1=data[rAddr1];//读 always@(posedge clk or rst_n)//写和复位 if(~rst_n)begin for(i=0;i<64;i=i+1)data[i]<=0;end else begin if(wEna)data[wAddr]<=wDin;end endmodule ``` control.v ```verilog module control(input clk,rst_n,input[31:0]aluout,output reg[5:0]ra=6'd0,//reg read addr input[31:0]rd,//reg read data output reg[5:0]wa=6'd0,//reg write addr output reg[31:0]wd,//reg write data output reg[31:0]tda,//tmp data a output reg[31:0]tdb,//tmp data b output reg ram_we,//ram write enable output reg[7:0]ram_ra,//ram read addr input[31:0]ram_rd,//ram read data output reg[7:0]ram_wa,//ram write addr output reg[31:0]ram_wd//ram write data);reg[2:0]cstate;//current state reg[2:0]nstate;//next state reg endflag=0;integer i=0;always @(posedge clk or negedge rst_n)if(~rst_n)cstate<=3'd0;else cstate<=nstate;always @(*)if(cstate==3'd0)nstate=3'd1;else if(cstate==3'd1&endflag==1'd0)nstate=3'd2;else if(cstate==3'd1&endflag==1'd1)nstate=3'd5;else if(cstate==3'd2)nstate=3'd3;else if(cstate==3'd3)nstate=3'd4;else if(cstate==3'd4)nstate=3'd1;else if(cstate==3'd5)nstate=3'd5;always @(negedge clk or negedge rst_n)begin if(~rst_n)begin ram_ra<=0;ram_wa<=0;i<=0;end else if(cstate==3'd1)begin ram_ra<=100+i;end else if(cstate==3'd2)begin ram_ra<=2*i;tda<=ram_rd;if(ram_rd==-1)endflag<=1;end else if(cstate==3'd3)begin ram_ra<=2*i+1;tdb<=ram_rd;end else if(cstate==3'd4)begin ram_wa<=200+i;ram_we<=1;ram_wd<=aluout;i<=i+1;end end endmodule ``` test.v ```verilog module test();reg clk,rst_n;top test(.clk(clk),.rst_n(rst_n),);always#10 clk=~clk;initial begin clk=0;rst_n=0;#20;rst_n=1;end endmodule ```","tags":["Verilog","COD"],"categories":[]},{"title":"操作系统阅读报告：进程与线程","url":"/s/p/9isqo0/","content":"#进程与线程##进程的概念-我们知道，人们通过操作系统来更方便地操作硬件，提高使用计算机的效率。早期的计算机只允许一次执行一个程序，这样的程序完全控制了系统，能访问所有的资源。但随着操作系统的功能愈加复杂，计算机的应用更加广泛，人们往往需要同时进行多个作业，因此就有了进程的概念，不同的进程同时运行，互相独立，进行不同的工作。-进程（Process），可以认为是执行中的程序。值得注意的是，程序本身不是进程。程序是被动实体，是存储在磁盘上的包含一系列指令的文件，而进程是活动实体，当一个程序被载入内存后并进行了相关资源分配后，才可以说进程开始运行了。##进程的信息-一个进程开始运行后，用户内存中将有一段空间被分配给这个进程，具体结构见右图1。其中，文本段（Text）存放程序代码，数据段（Data）存放全局变量，栈（Stack）存放函数参数、局部变量等，堆（Heap）用于动态分配空间。栈和堆朝着相反的方向增长，这是为了提高内存空间利用率。 ![](Process Concepts&Operations,Thread/20180526050442907-1.png)-同时，操作系统会为每个进程在内核空间中设置一个进程控制块（Process Control Block，PCB），其结构如图2。进程状态由当前进行的活动定义，包括new（正在被创建）、Running（正在执行指令）、Waiting（等待某事件发生，如I/O完成）、Ready（等待处理器分配）、Terminated（终止），它们之间的相互转化见图3。进程编号是操作系统为每个进程分配的唯一的身份标识。进程计数器表示将要执行的下一个指令的地址。寄存器则存放进程执行时的中间信息。-PCB的一个重要作用就是多道程序设计中操作系统在切换执行的进程时，可以将当前进程状态保存在PCB中，并从PCB读取新的进程的信息。 ![](Process Concepts&Operations,Thread/20180526050442907-2.png)![](Process Concepts&Operations,Thread/20180526050442907-3.jpg)<!--more-->##进程的操作-进程的操作主要包括获取进程ID、创建进程、终止进程和进程间的通信，这些操作都可以通过系统调用来实现，下面介绍前三者的实现。**1.获取进程的ID。**-进程独一无二的身份标识（PID）可以通过getpid()直接获取。**2.创建进程。**-一个进程可以通过系统调用来创建新的进程，则它本身称为父进程，新进程称为子进程。子进程还能再创建它的子进程，因此于是便形成了进程树。通常操作系统以一个初始进程（如init）为根形成进程树。-进程创建的一些细节实现可能并不唯一。如进程创建时需要一定的资源（如内存，I/O），它可能从操作系统那里直接获取，也可能从父进程获取。另一方面，子进程创建时，父进程可能与其并发执行，也可能等待子进程执行完后才继续执行。下面以UNIX系统为例，说明进程创建的基本过程。-在UNIX中，通过系统调用fork()来创建子进程，它将是父进程的一份完全拷贝，包括用户内存空间和PCB中的信息，同时进程PCB被加入到任务链表中。接下来，子进程的PID将被修改为一个与父进程不同的值，进程时间被置为0，同时它与父进程将相互记录为父子关系。由于PCB程序计数器也被完全复制，则子进程将与父进程继续执行相同的代码。另外，一个明显的差别是父进程的fork()将返回子进程的PID，而子进程的fork()将返回0，在代码中可以据此区分它们。-对于子进程，在创建完成后，可以不执行其他代码，与父进程保持相同。然而更有意义的做法是通过系统调用exec()来载入指定路径下的程序，这样进程将执行一个全新的程序，除了保留PID、程序运行时间和父子关系，包括内存和寄存器中的信息几乎都被丢弃，代码段被重置为载入程序的代码。-对于父进程，在调用fork()后，如果没有什么事情可做，可以调用wait()来将自身挂起，等待子进程执行直到结束。**3.终止进程。**-当进程完成执行后，通过调用exit()请求系统删除自身，所有的内存信息都将被释放。然而，进程将保留一个空的PCB在系统进程链表中，成为“僵尸”进程，同时向父进程发送一个SIGCHLD信号。这样做的一个原因是，子进程结束时，父进程可能由于有其他任务而还没有调用wait()或及时响应。直到wait()调用后，僵尸子进程才真正从任务链表中被删除。-另外，进程也可能通过系统调用来终止其他进程，通常只能对子进程实施这种操作。当一个进程被终止时，在一些系统中，子进程也被一并结束，另一些系统中，子进程将以init为父进程。##线程的概念和优点-进程帮助人们将不同的工作分离开来，各自运行。更具体地看，一项工作往往需要同时处理多个任务（如服务器同时响应多个客户，浏览器同时获取数据和渲染页面），但我们并不因此创建多个进程，而是在一个进程下创建多个线程（Thread）来实现。这样做的主要原因或者说线程相对于进程的优点有以下几点：进程的创建和切换很耗费时间和资源，而线程之间可以共享进程的代码、数据和文件，大大减小了创建和切换的开销，同时更易于相互之间的通信。另一方面，线程能充分利用处理器的多个核心，真正实现并行，当一个线程出现阻塞时，其他线程并不因此受到影响。-当然，线程也存在一些问题，如怎样分配任务，使每个线程的工作相对平衡？如何保证数据的同步和一致性？##多线程模型-线程可以分为用户线程和内核线程（由系统直接管理），它们之间有三种关系 1.多对一模型：既多个用户线程对应一个内核线程，这种做法效率较高，但如果有一个线程执行了阻塞系统调用，那么整个进程都会被阻塞。 2.一对一模型：既一个用户线程对应一个内核线程，这种做法允许多个线程并行运行在多处理器上，缺点是大多数系统的内核线程数量是有限的。 3.多对多模型：这种做法多路复用了内核线程，允许任意多的用户线程，当一个线程执行了阻塞调用时，内核可以调度另一个线程来执行。##多线程相关问题-线程库（Thread library）是为开发人员提供的创建和管理线程的API，目前主要有三种线程库：POSIX Pthread、Win32和Java。-多线程中fork()调用有两种，一种复制所有线程，一种只复制调用了fork()的线程，而exec()与进程中的相同。-线程池（Thread pool）是一种在进程开始时创建一定数量的线程放入池中的机制，当有任务请求时，它唤醒一个线程来处理，完成任务后，线程返回池中再等待工作。线程池解决了服务器中接受大量请求时各自频繁地创建和删除线程带来的巨大耗费。##参考文献[1]Abraham Silberschatz.操作系统概念.高等教育出版社,2010.1.","tags":["OS"],"categories":[]},{"title":"操作系统阅读报告：系统调用","url":"/s/p/9i4o00/","content":"#系统调用##概述 通过上一章，我们知道操作系统的设计目的是为了让人们更加方便、高效地使用计算机。因此，人们编写程序的时候，往往不会直接操纵硬件和关注十分细枝末节的方面，而是通过对操作系统提供的所谓的“**系统调用（System Call）**”进行组织来实现相应的操作。实际上，系统调用是多层次的，每一层次只关心如何组织低层次的系统调用来实现本层次的功能，而不关心低层次的系统调用具体是如何实现的。具体到使用高级语言编写程序的开发人员来说，他们也不直接使用实际的系统调用，而是使用操作系统提供的**应用程序接口（****Application Programming Interface****，简称API****）**。API是一系列适应于具体程序开发的函数，开发人员通过向函数传递参数，来得到相应的返回值或实现某种操作。包括API在内的系统调用为开发人员带来的巨大的便利，它向开发人员隐藏了大部分的细节，开发人员只需要知道如何使用它们，这样一来，开发人员可以站在更高、更抽象的层次上来思考问题和编写程序。##分类 系统调用大致可以分为五类：**进程控制、文件管理、设备管理、信息维护和通信**。-进程控制相关的系统调用包括创建和终止进程、获取进程信息、跟踪进程等等。创建进程的系统调用能决定进程的属性，如优先级和最大允许执行时间。一旦一个进程不再需要或者发生了异常，可以使用系统调用来终止它，同时可以获得内存转储信息来分析和调试程序。通过系统调用还可获得程序的时间表，它具有跟踪功能和定时时间中断，如果中断足够频繁，可以得到程序各部分所用的时间。-文件管理相关的系统调用主要包括创建、读写、删除文件，查看、修改文件属性等操作，更高级的系统调用还可以定位、移动、复制文件。另外，可以通过系统调用创建目录来组织和管理文件。-设备管理相关的系统调用包括对物理设备的识别、访问等。用户程序通过请求操作系统来获得对设备进行访问的权限，一旦获得使用权限，就可通过系统调用进行读写等操作，正如对待文件一样。用户使用完成后，通过系统调用释放它。-信息维护相关的系统调用包括获取当前的时间和日期、获取当前空闲内存/磁盘大小、获取当前用户数以及一些操作系统的其他信息等等，通过系统调用实现用户与系统之间的信息交换。-通信模型包括消息传递模型和共享内存模型。消息传递模型是指进程间通过操作系统的专用程序进行彼此的信息交换，并通过一定的标识符进行识别。一般而言，消息传递模型更容易实现，适合传递少量的信息。共享内存模型通过指定一块公共的内存区域，使两个或多个程序能同时拥有该区域的访问权，这种方法通信速度快且能共享较多的数据，但是建立方式较为复杂。##参考文献[1]Abraham Silberschatz.操作系统概念.高等教育出版社,2010.1.","tags":["OS"],"categories":[]},{"title":"操作系统阅读报告：操作系统概述","url":"/s/p/9hrpc0/","content":"#操作系统概述##操作系统的功能-操作系统是介于计算机硬件与用户之间的中间程序，它的设计目的是为了让人们更加方便高效地使用计算机。但目前来说，并没有一个关于操作系统的十分完整的定义。-对于用户来说，操作系统的主要功能是为了让其更加方便地操作硬件，优化日常进行的工作，而并不那么关心资源使用率。当然，在某些情况下，比如工作站，操作系统的功能是个人使用性能和资源使用率的折中。-对于计算机来说，操作系统是一个资源分配器，它管理、调度、分配各种资源，使计算机更加有效而公平地运行。同时，操作系统也是控制程序，它管理用户程序执行，防止计算机被错误使用，对异常进行处理。##操作系统的结构-操作系统有一种称为“多道程序设计”的重要机制，它使得CPU总有一个作业可以执行，充分提高的CPU的利用率。操作系统将多个作业保存在内存中并选择一个开始执行，这个作业可能需要等待另一个任务完成（如I/O操作）。此时，操作系统将切换到另一个作业执行，在前一个作业等待完成后切换回去。如此一来，只要有作业可以执行，CPU就不会空闲。-多道程序设计并没有提供与计算机系统直接交互的能力，因此有了分时系统，它是多道程序设计的延伸。分时系统的每个命令或动作都比较短，因此在不同作业之间切换的频率较高，用户可以在程序运行期间与之交户并感觉到整个系统都为自己所用，尽管事实上可能为许多用户共享。##操作系统的操作-现代操作系统是由中断驱动的。如果没有进程执行和用户请求，操作系统将默默等待直至事件发生。对于每一种中断，操作系统定义不同代码并由中断处理器来处理。异常也是一种中断，它源于出错。由于不同程序共享了硬件，操作系统必须设计一些保护，以防止某个程序出错时影响其他程序。-许多操作系统采用双重模式操作，也就是区分操作系统代码和用户定义代码。用户程序正在运行时，系统处于用户模式。当用户通过系统调用请求操作系统的服务时，模式转换为系统模式。另外，出现中断和异常时，也会切换为系统模式，操作系统获得控制权。双重操作模式也提供了保护操作系统和用户程序不受错误影响的方法，即把能引起机器损坏的指令作为特权指令。如果在用户模式下试图执行特权指令，那么硬件将不予执行，并以异常的形式通知操作系统。显然，转换到用户模式是一个特权指令，I/O控制、中断管理也是特权指令。-为了使操作系统保持对CPU的控制，防止用户程序陷入死循环，可以设定定时器。操作系统在将控制权交给用户程序前，为定时器设置一个时间，在时间到达后自动产生中断，控制权将交回操作系统。##操作系统的主要模块-操作系统的主要模块有进程管理、内存管理、存储管理。-正在执行中的程序称为进程，它是系统工作的单元。值得注意的是，程序本身并不是进程，程序是存储在磁盘中的静态信息，而进程是活动的实体。进程包括系统进程和用户进程，并需要一些资源来完成任务。操作系统负责创建进程并分配资源给进程，提供进程同步机制、通信机制，提供死锁处理机制，并在删除进程时回收资源。-内存是现代操作系统操作的中心，是CPU所能直接访问的唯一大容量存储器。当一个程序将要运行时，它先被装入内存中，然后CPU才可以读取指令和数据。操作系统在内存管理上的作用是分配和释放内存空间，记录内存哪些部分正在被使用和被哪个程序使用，决定哪些进程可以装入内存。-文件是由创建者定义的一组信息的集合，可以存储在不同的物理介质中（如磁盘）。操作系统的文件管理活动主要有创建和删除文件，创建目录组织文件，同时对大容量存储器的空间进行调度和分配。另外，操作系统还管理高速缓存。高速缓存是为了使CPU更快地读取信息，它将内存中的信息复制到其中，以便下一次的快速重复使用。它的设计和置换策略十分重要，其中一个重要的问题是如何确保高速缓存一致性。##操作系统的保护与安全-计算机系统可能有多个用户并允许多个进程同时运行，那么只有进行系统地管理，才能确保每个用户每个进程只在属于自己的空间中进行，并按时转交CPU控制权。-保护是一种控制进程和用户对计算机系统资源的访问的机制。系统将通过授权的方式分配资源，只有获得了系统的授权，用户和进程才能访问相应的资源。-安全是防止系统受到外部或内部攻击的机制。这些攻击包括病毒、蠕虫、拒绝服务攻击等。近年来操作系统的安全问题成为许多研究关注的领域。-操作系统实现保护与安全的一个重要前提是操作系统能区分它的所有用户。在一般的系统中，使用用户ID和组ID就足够了。如果用户需要访问受限的设备，则需要通过升级特权的方式获得使用权。##分布式系统和专用系统-分布式系统是将一组物理上分开的，各种不同结构的计算机连接在一起，而网络则是它们之间的通讯路径。分布式系统将各种资源整合在一起，增加了计算速度和可靠性。-专用系统与通用系统的区别是它的功能有限，只在某些专门的领域内运行。专用系统包括实时嵌入式系统（如各种工业上的控制系统）、多媒体系统和手持系统（如PDA和手机）。##参考文献:[1]Abraham Silberschatz.操作系统概念.高等教育出版社,2010.1.","tags":["OS"],"categories":[]},{"title":"数据结构上机题4 最短路径","url":"/s/p/9d1c00/","content":"#最短路##题目-ddl：12月9日。-实验题目：-给定图的边和边权值（非负数），求给定两顶点间的最短路径。边和边权值（格式为边的兩顶点和权值，勿直接输入邻接矩阵）、两顶点由窗口（文件也可以）输入。输出路径和路径总权值。-基本要求（8分）：-无向图、顶点以自然数命名-扩展：-有向图；-路径除起终顶点外，过另外几个给定顶点；-顶点支持隨意命名；-图形界面；-等等....##说明 1.打开ShortestPaths.exe，选择有向图模式或无向图模式 2.点击帮助按钮查看如何操作 3.点击导入文件可导入事先建好的图，.udg为无向图文件，.dg为有向图文件，只能导入运行程序目录下的文件，只输入文件名（不用输入后缀名，会根据当前模式读取对应文件） 4.导入后，左键单击某个顶，呈选中状态（绿色），然后按住SHIFT，再左键单击另一个顶，将求出最短路径，路径高亮加粗显示（黄色）。 5.ShortestPaths文件夹内为工程源代码，在VS2010下创建，ShortestPaths.cpp绘制界面和处理键鼠操作，graph.h为图数据结构声明和基本操作 <!--more-->##截图 ![](lab4_ShortestPaths/1.png)![](lab4_ShortestPaths/1.png)#代码 注：需要easyx图形库 graph.h ```c#include <string.h>#define INF 99999999#define MAX_VERTEX_NUM 100#define MAX_NAME 10#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define Status int typedef enum{DG,DN,UDG,UDN}GraphType;typedef struct ArcCell{int w;//边的权值,0为不连通}GArc,ArcArray[MAX_VERTEX_NUM][MAX_VERTEX_NUM];typedef struct Vertex{TCHAR name[MAX_NAME];//顶的名称 int x,y;//用于绘制该顶时的位置 int l;//dijkstra算法需要 int state;//=0正常，=1选中}GVex,VexArray[MAX_VERTEX_NUM];typedef struct Graph{ArcArray arcs;VexArray vexs;int arcnum,vexnum;GraphType type;}MGraph;typedef struct DijkstraResult{int vexbegin;//表示这个结果是从该顶到其他顶的最短距离 int prev[MAX_VERTEX_NUM];//最短路径上每个顶的前一个顶 int dist[MAX_VERTEX_NUM];//每个顶到vexbegin的最短距离}DijRes;Status CreateGraph(MGraph*g){g->arcnum=0;g->vexnum=0;memset(g->vexs,0,sizeof(GVex)*MAX_VERTEX_NUM);memset(g->arcs,0,sizeof(GArc)*MAX_VERTEX_NUM*MAX_VERTEX_NUM);return OK;}Status DestoryGraph(MGraph*g){g->arcnum=0;g->vexnum=0;memset(g->vexs,0,sizeof(GVex)*MAX_VERTEX_NUM);memset(g->arcs,0,sizeof(GArc)*MAX_VERTEX_NUM*MAX_VERTEX_NUM);return OK;}int LocateVex(MGraph g,TCHAR vexname[]){//获取顶在图中的位置，即在顶数组中的下标,未找到返回-1 int i;for(i=0;i<g.vexnum;i++){if(!_tcscmp(g.vexs[i].name,vexname))return i;}return-1;}Status InsertVex(MGraph*g,TCHAR vexname[],int x,int y){//添加一个顶，不允许为空，不允许重名 _tcscpy_s(g->vexs[g->vexnum].name,vexname);g->vexs[g->vexnum].x=x;g->vexs[g->vexnum].y=y;g->vexs[g->vexnum].l=0;g->vexnum++;return OK;}Status DeleteVex(MGraph*g,TCHAR vexname[]){int i=LocateVex(*g,vexname),j;if(i==-1)return ERROR;_tcscpy_s(g->vexs[i].name,g->vexs[g->vexnum-1].name);//最后一个顶覆盖要删除的顶 _tcscpy_s(g->vexs[g->vexnum-1].name,_T(\"\"));for(j=0;j<MAX_VERTEX_NUM;j++){g->arcs[i][j].w=g->arcs[g->vexnum-1][j].w;g->arcs[g->vexnum-1][j].w=0;}return OK;}DijRes Dijkstra(MGraph g,int v){//求其他各顶到顶v的最短路径 DijRes r={};int flag[MAX_VERTEX_NUM]={0};//标志是否已找到最短路径 int i,j,mindist,minu;for(i=0;i<g.vexnum;i++){//初始化每个顶到v的距离 if(g.arcs[v][i].w){//连通则初始距离为边权 r.dist[i]=g.arcs[v][i].w;r.prev[i]=v;}else{//不连通为无穷 r.dist[i]=INF;r.prev[i]=-1;}}r.dist[v]=0;//v到v为0 flag[v]=1;//v标志为已找到 for(i=1;i<g.vexnum;i++){//遍历vexnum-1次,每次找出一个顶点的最短路径 mindist=INF+1;minu=-1;for(j=0;j<g.vexnum;j++){//求出未标记的顶中到v最短的 if(flag[j]==0&&r.dist[j]<mindist){mindist=r.dist[j];minu=j;}}flag[minu]=1;for(j=0;j<g.vexnum;j++){//根据新找到的顶u更新其他各顶最短距离 int sum=mindist+(g.arcs[minu][j].w==0?INF:g.arcs[minu][j].w);//边权为0不连通，以无穷计算 if(flag[j]==0&&(sum<r.dist[j])){r.dist[j]=sum;r.prev[j]=minu;}}}return r;}``` ShortestPaths.cpp ```c//MinRoad.cpp:定义控制台应用程序的入口点。#define SPACE 20//按钮间隔大小#define HEIGHT 480#define WIDTH 800#define BUTTONHEIGHT 40//按钮大小#define BUTTONWIDTH 150//按钮大小#define CONTROLWIDTH BUTTONWIDTH+2*SPACE//控制区大小#define VEXRADIUS 20//顶半径#define ARROWLEN 10//箭头斜边的长#define PI 3.1415926#define HPI 1.5707963#include <graphics.h>//easyx图形库头文件#include <windows.h>#include <stdio.h>#include <math.h>#include \"graph.h\"//图 TCHAR runpath[256];//运行路径 int MODE=0;//0为无向图，1为有向图 int vsel=-1;//当前选中顶 int vmov=-1;//当前移动顶 MGraph g;//定义一个图 void DrawButton(int left,int top,LPCTSTR text){setbkmode(TRANSPARENT);//设置字体背景透明 setfillcolor(RGB(136,247,104));//设置填充颜色 setlinestyle(PS_SOLID,4);//设置线型线宽 setlinecolor(RGB(249,102,102));//设置线颜色 settextstyle(25,0,_T(\"宋体\"),0,0,FW_BOLD,0,0,0);//设置字体，大小，粗细 settextcolor(RGB(0,0,255));//设置字体颜色 RECT r;r.left=left;r.top=top;r.right=left+BUTTONWIDTH;r.bottom=top+BUTTONHEIGHT;fillroundrect(left,top,left+BUTTONWIDTH,top+BUTTONHEIGHT,5,5);//带边框填充 drawtext(text,&r,DT_CENTER|DT_VCENTER|DT_SINGLELINE);//输出字}void InitUI(){initgraph(WIDTH,HEIGHT);//创建绘图窗口 int t=SPACE;DrawButton(SPACE,t,(LPCTSTR)L\"帮 助\");t+=SPACE+BUTTONHEIGHT;DrawButton(SPACE,t,(LPCTSTR)L\"导出文件\");t+=SPACE+BUTTONHEIGHT;DrawButton(SPACE,t,(LPCTSTR)L\"导入文件\");t+=SPACE+BUTTONHEIGHT;DrawButton(SPACE,t,(LPCTSTR)L\"关 于\");line(CONTROLWIDTH,0,CONTROLWIDTH,HEIGHT);HRGN rgn=CreateRectRgn(CONTROLWIDTH,0,WIDTH,HEIGHT);setcliprgn(rgn);//之后的绘图区域只在该矩形内有效 DeleteObject(rgn);}void DrawVex(int i){setbkmode(TRANSPARENT);//设置字体背景透明 setfillcolor(RGB(255,188,121));//设置填充颜色 setlinestyle(PS_SOLID,4);//设置线型线宽 if(g.vexs[i].state==0)setlinecolor(RGB(129,29,228));//设置线颜色 else setlinecolor(RGB(92,185,0));//设置线颜色(选中状态)settextstyle(30,0,_T(\"Arial\"),0,0,FW_BOLD+100,0,0,0);//设置字体，大小，粗细 settextcolor(RGB(255,0,0));//设置字体颜色 RECT r;r.left=g.vexs[i].x-VEXRADIUS;r.top=g.vexs[i].y-VEXRADIUS;r.right=g.vexs[i].x+VEXRADIUS;r.bottom=g.vexs[i].y+VEXRADIUS;fillcircle(g.vexs[i].x,g.vexs[i].y,VEXRADIUS);drawtext((LPCTSTR)(g.vexs[i].name),&r,DT_CENTER|DT_VCENTER|DT_SINGLELINE);}double GetAngle(int x1,int y1,int x2,int y2){//从(x1,y1)到(x2,y2)的向量的方位角，以x轴为0度，顺时针，弧度值 double a=atan(((double)(y2-y1))/(x2-x1));//得到-pi/2~pi/2的弧度值 if(x2>x1)return a;else if(x2==x1)return(y2>=y1)?HPI:-HPI;//pi/2和-pi/2,两点重合这里会返回pi/2 else return(y2>=y1)?a+PI:a-PI;}void DrawArc(int i,int j,int mode,int inroad){//画边;mode=0,无向;mode=1,有向,i到j;inroad=1则换一种颜色画边 if(!inroad){setlinestyle(PS_SOLID,3);//设置线型线宽 setlinecolor(RGB(0,196,166));//设置线颜色}else{setlinestyle(PS_SOLID,4);//设置线型线宽 setlinecolor(RGB(255,250,28));//设置线颜色}settextstyle(23,0,_T(\"Arial\"),0,0,FW_BOLD,0,0,0);//设置字体，大小，粗细 TCHAR tw[10]={};_stprintf_s(tw,_T(\"%d\"),g.arcs[i][j].w);//即使对于无向图也通用，因为arcs[i][j]和arcs[j][i]一样 if(!mode){//无向图，直接连线 line(g.vexs[i].x,g.vexs[i].y,g.vexs[j].x,g.vexs[j].y);outtextxy((g.vexs[i].x+g.vexs[j].x)/2,(g.vexs[i].y+g.vexs[j].y)/2,tw);}else{//有向图，画边时两个方向的线需要错开，不重叠，并且带箭头 double a=GetAngle(g.vexs[i].x,g.vexs[i].y,g.vexs[j].x,g.vexs[j].y);//从顶i到j的向量的方位角 double da=30.0/180.0*PI;//30度角对应的弧度,int x1=g.vexs[i].x+cos(a-da)*VEXRADIUS,y1=g.vexs[i].y+sin(a-da)*VEXRADIUS;int x2=g.vexs[j].x+cos(a+da-PI)*VEXRADIUS,y2=g.vexs[j].y+sin(a+da-PI)*VEXRADIUS;line(x1,y1,x2,y2);//画i到j的边的直线,下面画箭头 double len1_2=sqrt(pow((long double)(g.vexs[i].x-g.vexs[j].x),2)+pow((long double)(g.vexs[i].y-g.vexs[j].y),2))/2;//该边1/2长 int arrx=x1+len1_2*cos(a),arry=y1+len1_2*sin(a);//箭头端点所在坐标 double db=2.617994;//150度角对应的弧度 line(arrx,arry,arrx+cos(a-db)*ARROWLEN,arry+sin(a-db)*ARROWLEN);//箭头一侧边 line(arrx,arry,arrx+cos(a+db)*ARROWLEN,arry+sin(a+db)*ARROWLEN);//箭头一侧边 outtextxy((x1+x2)/2,(y1+y2)/2,tw);}}void DrawMGraph(){clearcliprgn();//清空绘图区 int i,j;for(i=0;i<g.vexnum;i++){//先画边，再画顶不然边会部分叠在顶上 for(j=0;j<g.vexnum;j++){if(g.arcs[i][j].w)DrawArc(i,j,MODE,0);}}for(i=0;i<g.vexnum;i++){DrawVex(i);}}void OnButtonClick(int i){FILE*fp;TCHAR filename[32]=_T(\"test\");TCHAR filepath[256];switch(i){case 1:MessageBox(GetHWnd(),_T(\\\"1.点击空白处添加新顶.\\n2.在某顶上按住右键可移动该顶.\\n3.左键单击某个顶可以选中.\\n4.选中某顶后,ctrl+左键单击另一顶可添加边.\\n5.选中某顶后,shift+左键单击另一顶可求最短路径.\"\\),_T(\"Help\"),MB_OK|MB_ICONINFORMATION);break;case 2:if(InputBox(filename,32,_T(\"文件将保存在当前运行目录下，无向图后缀名为.udg，有向图后缀名为.dg\\n请输入文件名(不带后缀名):\"),_T(\"保存文件\"),(LPCTSTR)filename,0,0,0)){_stprintf_s(filepath,_T(\"%s%s%s\"),runpath,filename,MODE?_T(\".dg\"):_T(\".udg\"));//生成保存路径 if(!_tfopen_s(&fp,filepath,_T(\"wb+\"))){fwrite(&g,sizeof(g),1,fp);fclose(fp);MessageBox(GetHWnd(),_T(\"导出成功！\"),_T(\"提示\"),MB_OK|MB_ICONINFORMATION);}else{MessageBox(GetHWnd(),_T(\"文件不存在！！\"),_T(\"错误\"),MB_OK|MB_ICONWARNING);}}break;case 3:if(InputBox(filename,32,_T(\"将打开当前运行目录下的文件，无向图后缀名为.udg，有向图后缀名为.dg\\n请输入文件名(不带后缀名):\"),_T(\"打开文件\"),(LPCTSTR)filename,0,0,0)){_stprintf_s(filepath,_T(\"%s%s%s\"),runpath,filename,MODE?_T(\".dg\"):_T(\".udg\"));//生成保存路径//MessageBox(GetHWnd(),filepath,_T(\"aaa\"),MB_OK|MB_ICONINFORMATION);if(!_tfopen_s(&fp,filepath,_T(\"rb+\"))){fread(&g,sizeof(g),1,fp);fclose(fp);DrawMGraph();}else{MessageBox(GetHWnd(),_T(\"文件不存在！！\"),_T(\"错误\"),MB_OK|MB_ICONWARNING);}}break;case 4:MessageBox(GetHWnd(),_T(\"ShortestPaths V1.0\\nCode by LinXiang(PB16020923)\"),_T(\"About\"),MB_OK|MB_ICONINFORMATION);break;}}int IsInRange(int a,int up,int down){return a<=up&&a>=down;}int GetPosInVex(int x,int y){//获取当前坐标下的顶下标，没有返回-1 int i,xu=x+VEXRADIUS,xd=x-VEXRADIUS,yu=y+VEXRADIUS,yd=y-VEXRADIUS;//反过来判断某个顶在不在x,y范围内，这样节省计算，不用算每个顶边界 for(i=0;i<g.vexnum;i++){if(IsInRange(g.vexs[i].x,xu,xd)&&IsInRange(g.vexs[i].y,yu,yd))return i;}return-1;}void SetVexSelected(int i){g.vexs[i].state=1;DrawVex(i);//更新为选中状态 vsel=i;//记下当前选中顶}void SetVexNoSelected(){g.vexs[vsel].state=0;DrawVex(vsel);//更新为正常选中状态 vsel=-1;//}void GetRunPath(TCHAR*text,TCHAR*path){//获取当前运行路径 int pos;//最后一个\\的位置 int i=0;while(*(text+i)){if(*(text+i)=='\\\\')pos=i;i++;}_tcscpy_s(path,256,text);path[pos+1]=0;}int _tmain(int argc,TCHAR*argv[]){GetRunPath(argv[0],runpath);if(IDYES==MessageBox(GetHWnd(),_T(\"选择‘是’为进入 有向图 模式，\\n选择‘否’为进入 无向图 模式。\"),_T(\"选择模式\"),MB_YESNO|MB_ICONQUESTION))MODE=1;else MODE=0;InitUI();CreateGraph(&g);while(true){MOUSEMSG m=GetMouseMsg();//获取一条鼠标消息 switch(m.uMsg){int vi;case WM_MOUSEMOVE://移动 if(vmov!=-1){g.vexs[vmov].x=m.x;g.vexs[vmov].y=m.y;DrawMGraph();//重绘全部}break;case WM_RBUTTONDOWN://右键按下，开始移动 vi=GetPosInVex(m.x,m.y);if(vi!=-1)vmov=vi;break;case WM_RBUTTONUP://右键弹起，结束移动 if(vmov!=-1)vmov=-1;break;case WM_LBUTTONDOWN://按下左键 if(m.mkCtrl){//同时按下CTRL vi=GetPosInVex(m.x,m.y);if(vi!=-1&&vsel!=-1&&vi!=vsel){//按下ctrl选择了一顶，并且之前已经选中一顶，而且两顶不同，则添新边 TCHAR tn[10]=_T(\"1\");if(InputBox(tn,128,_T(\"Input a arc weight\"),_T(\"Add a arc\"),(LPCTSTR)tn,0,0,0)){//输入了权 if(!MODE){//无向图 g.arcs[vi][vsel].w=g.arcs[vsel][vi].w=_ttoi(tn);DrawArc(vsel,vi,MODE,0);}else{//有向图 g.arcs[vsel][vi].w=_ttoi(tn);DrawArc(vsel,vi,MODE,0);}}}}else if(m.mkShift){//同时按下SHIFT vi=GetPosInVex(m.x,m.y);if(vi!=-1&&vsel!=-1&&vi!=vsel){//按下ctrl选择了一顶，并且之前已经选中一顶，而且两顶不同，则求最短路径 DrawMGraph();//重绘全部,避免图中有画过其他路径 DijRes r=Dijkstra(g,vsel);//求出vel到各顶最短路径 int tmp=vi;//倒推路径，先画边 while(r.prev[tmp]!=-1){DrawArc(r.prev[tmp],tmp,MODE,1);tmp=r.prev[tmp];}tmp=vi;//倒推路径，再画顶 while(tmp!=-1){DrawVex(tmp);tmp=r.prev[tmp];}}}else{//仅仅按下左键 if(m.x<CONTROLWIDTH){//控制区 if(m.y%(SPACE+BUTTONHEIGHT)>SPACE)OnButtonClick(m.y/(SPACE+BUTTONHEIGHT)+1);}else{//绘图区 int vi=GetPosInVex(m.x,m.y);if(vi!=-1){//按下了某个顶 if(vsel!=-1)//如果有选中的，先取消选中状态 SetVexNoSelected();SetVexSelected(vi);}else{//按下了空白区域 if(vsel!=-1){//如果有选中的，取消选中状态 SetVexNoSelected();break;}//以下添加新顶//TCHAR根据是否有UNICODE宏分别对应char和wchar_t//tn相当于TCHAR*也就是LPTSTR TCHAR tn[MAX_NAME]=_T(\"0\");tn[0]+=g.vexnum;if(InputBox(tn,128,_T(\"Input a name:\"),_T(\"Add a vex\"),(LPCTSTR)tn,0,0,0)){//_T将字符串常量转为unicode版本，(LPCTSTR)把字符串变量转为常量 InsertVex(&g,tn,m.x,m.y);DrawVex(g.vexnum-1);}}}}break;}}closegraph();//关闭绘图窗口 return 0;}```","tags":["DS"],"categories":[]},{"title":"数据结构上机题3 哈夫曼压缩","url":"/s/p/9blhc0/","content":"#哈夫曼压缩##题目 实验三:此次实验限定语言C/C++，允许使用stl。 ddl：下下周六（11月19日）。 实验要求：实现任意二进制文件压缩解压。将哈夫曼树或者词频率表保存到文件，压缩后解压所需信息全部从你自己压缩得到的文件中拿到。检查:对于一般txt文档实现效果明显的压缩结果并正确解压7分，大文件（几十兆以上）非文本文件正确压缩解压。（9分）报告1分。本周六实验一和二未检查完的来检查，下周六实验三写好的可以提前来检查。下下周六ddl##一、 需求分析 1.实现功能： （1） 利用Haffman编码压缩文件。打开文件后扫描文件读入数据，以二进制方式读取，每次处理8位（1个字节），八位二进制码有256种组合，对应ascii码中0-255的字符，读取结束后，统计出字符频率表并降序排序，根据字符频率表创建Haffman树，导出Haffman编码，之后再次扫描文件，将每个字符对应的Haffman编码依次写入目标文件，完成压缩。 （2） 解压本程序创建的压缩文件。打开文件后扫描文件读入数据，以二进制方式读取，首先读取创建压缩文件是存储在文件头的字符频率表或者Haffman树，然后读取压缩数据，设置一个缓存空间buf，每次处理1位的数据，查找Haffman编码对应的字符，输出至目标文件，完成解压。 （3） 通过修改Windows注册表设置右键菜单快捷方式来打开本程序，以便传入要处理的文件路径。 2.模块化设计，创建词频表和Haffman树两种数据结构。 3.采用main函数的参数传入要压缩或者解压的文件路径，然后处理文件并显示处理界面。如果没有传入任何文件路径，则显示设置界面。 4.处理界面上显示当前处理过程（解压/压缩）、处理的文件名、文件大小，实时输出处理的进度、已花时间和剩余时间。 5.测试数据：选取几种代表性的文件： （1） 文本文件，实现较明显的压缩。 （2） 可执行文件和较大的二进制文件，实现正确的解压缩，解压缩前后文件一致，能正确打开执行或访问。 <!--more-->##二、 概要设计 1.抽象数据类型词频表定义如下： ``` ADT FrequencyList{数据对象：Frequency={ch,f|0<=ch<=255,f>=0}FrequencyList={Frequency}数据关系：无 基本操作： CreateFrequencyListFromFile(&file,&fl);初始条件：文件file存在且被打开。 操作结果：从文件数据创建词频表fl。 SaveFrequencyListToFile(&file,fl);初始条件：词频表fl存在，文件file存在且被打开。 操作结果：保存词频表fl到文件file中。 LoadFrequencyListFromFile(&file,&fl);初始条件：文件file存在且被打开，文件file是按 CreateFrequencyListFromFile方法创建的文件。 操作结果：从文件数据载入存储的词频表fl。}ADT FrequencyList ``` 2.抽象数据类型哈夫曼树定义如下： ``` ADT HaffmanTree{数据对象：HaffmanTreeNode={lchild,rchild,parent,ch,f}HaffmanTree={HaffmanTreeNode}数据关系：每个节点指向左右两个孩子节点（如果有的话） 基本操作： CreateHaffmanTreeFromFrequencyList(fl,&ht);初始条件：词频表fl存在。 操作结果：从词频表fl创建哈夫曼树ht。 CreateHaffmanCode(ht,&haffmancode);初始条件：Haffman树ht存在。 操作结果：根据哈夫曼树ht生成哈夫曼编码haffmancode。}ADT HaffmanTree ``` 3.主函数，压缩函数，解压函数的实现框架 ```//以下代码是实现框架，不保证细节完备，详情请看后附源代码 int main(int argc,char*argv[]){界面初始化;if(argc>1){根据argv[1]的文件路径获取文件名FILENAME;获取文件大小FILESIZE;判断文件类型FILETYPE;​``` 绘制文件处理界面;计时开始，记录time_begin;if(FILETYPE==0){HaffmanCompress压缩;}else{HaffmanDecompress解压;}}else{绘制设置界面;for(;;){读取鼠标信息;if(鼠标点击){设置右键;}}}输出完成信息;​```}Status HaffmanCompress(当前文件,目标文件,哈夫曼编码表,当前文件总长度){//压缩 while(读取文件每次n字节&&文件没有结束){//for(i=0;i<n;i++){获取该字节对应的哈夫曼编码;while(哈夫曼编码指针){缓存左移一位;缓存最低位存哈夫曼编码的当前位;哈夫曼编码指针++;缓存长度++;if(缓存达到输出长度){缓存长度=0;把缓存写到文件;}}进度++;刷新显示进度;}}while(缓存长度不足指定长度){文件尾补足长度;}把缓存写到文件;return OK;}Status HaffmanDecompress(当前文件,目标文件,哈夫曼树){//解压 读取目标文件总长度bytenum;htn=哈夫曼树根结点;while(k<总长度){读取一定长度数据写入缓存inbuf;do{取缓存inbuf最高位b;缓存inbuf左移一位;if(b==0){htn=htn->lchild;}else{htn=htn->rchild;}if(htn左孩子和右孩子都是空){//到达叶结点 输出叶上的字符到缓存outbuf;if(outbuf到一定长度){写出缓存outbuf到目标文件;}计数k++;if(k==bytenum)break;回根结点;}}while(缓存inbuf还没处理完);刷新显示进度;}return OK;}``` 4.本程序含四个模块(1)主模块(2)词频表模块(3)哈夫曼树、编码和解压缩模块(4)图形界面模块 ![](lab3_Haffman/0.png)##三、 详细设计 1． 词频结点类型 ```c typedef struct Frequency{//一个字符(8位)及其出现频次 unsigned char ch;//0<=ch<=255 unsigned int f;}fre,*pfre;``` 2． 词频表类型 typedef struct FrequencyList{//频度表，所有出现的字符及频次 int num;//1<=num<=256 pfre list;//频度表数组，动态申请}frelist,*pfrelist;3． 哈夫曼树类型 ```c typedef struct HaffmanTreeNode{struct HaffmanTreeNode*lchild,*rchild,*parent;unsigned int f;unsigned char ch;}htreenode,*htree;``` 4． 词频表操作 ```c Status CreateFrequencyListFromFile(FILE*fp,pfrelist*fl);//从任意文件中创建频度表 Status SaveFrequencyListToFile(FILE*fp,pfrelist fl);//保存频度表到压缩文件中 Status LoadFrequencyListFromFile(FILE*fp,pfrelist*fl);//从压缩文件中读取频度表 ``` 5． 哈夫曼树操作及解压缩 ```c Status CreateHaffmanTreeFromFrequencyList(pfrelist fl,htree*ht){//从频度表创建哈夫曼数，频度表保证至少两种字符 Status PreOrderTraverse(htree ht,int child,int i,char code[],char haffmancode[256][256]){//先序遍历，child=0表示当前是左孩子，child=1表示当前是右孩子//i为当前层次,code为当前遍历路径已存编码，haffmancode是编码表 Status CreateHaffmanCode(htree ht,char haffmancode[256][256]){//创建编码表haffmancode[256][256],牺牲一些空间以便快速索引 Status HaffmanCompress(FILE*fp1,FILE*fp2,char haffmancode[256][256],unsigned int bytenum){//压缩,bytenum为总长度 Status HaffmanDecompress(FILE*fp1,FILE*fp2,htree ht){//解压,解压时直接用哈夫曼树搜索对应字符 ``` 6． 图形界面操作 SMALL_RECT UI_SetRect(int left,int top,int right,int bottom);//根据坐标取返回对应矩形区域数据 void UI_SetConsoleWindowSize(HANDLE hOut,int width,int height);//设置窗口大小 void UI_SetConsoleScreenBufferSize(HANDLE hOut,int width,int height);//设置缓冲区大小 void UI_InitSTDHandle(HANDLE*hOut,CONSOLE_SCREEN_BUFFER_INFO*bInfo,int width,int height);//初始化 void UI_DrawText(HANDLE hOut,WORD attr,char*text,int len,int row,int left,int right);//在指定行左右位置之间居中输出一行文本 void UI_CleanText(HANDLE hOut,int row,int left,int right);//在指定行左右位置之间清除一行文本 void UI_CleanTextRect(HANDLE hOut,int top,int bottom,int left,int right);//在指定区域之间清除文本 void UI_DrawBox(HANDLE hOut,int bSingle,SMALL_RECT rc,WORD attr);//画方框 void ClearScreen(HANDLE hOut,DWORD att){//清屏，且设置样式 7． 其他函数 void GetCompressedFilePath(char*FPath,char*CFPath);//从传入的路径求得对应压缩文件路径 void GetDecompressedFilePath(char*FPath,char*DFPath);//从传入的压缩文路径求得对应解压文件路径 void GetFileNameFromPath(char*FPath,char*FName);//从路径中提取文件名 long GetFileSizeFromPath(char*FPath);//获取文件大小 int GetFileTypeFromPath(char*FPath);//判断文件类型是解压(1)还是压缩(0)void UIInit();//UI初始化 void DrawAllBox();//绘制所有方框 void DrawInfoText(char*filename,int type,int size);//显示文件名，类型是解压(1)还是压缩(0)void UpdateTimeText(double progress);//根据进度(0-1)更新剩余时间 void DrawSelect(int select);//没有文件传入时显示配置界面,select=1表示已选中，即当前已创建右键菜单 int CheckKey();//检查右键菜单注册表是否已设置 void SetKey(char*exepath);//设置或取消右键菜单注册表 int Compress(char*fpath);//预处理及压缩 int Decompress(char*fpath);//预处理及解压 8． 具体的函数实现见附录，均有详细注释，此处不再赘述。##四、 调试分析 1． 本程序的难点在于哈夫曼树的创建、存储、读取、匹配。 2． 本程序选择存储词频表而不是哈夫曼树，在解压时读取词频表重新创建哈夫曼树，文件结构如下图。 ![](lab3_Haffman/1.png)FileTypeMark位于文件头，标记了“#HAFFMANCOMPRESSFILE#”，以供解压时识别为压缩文件。之后的一段数据FrequencyList 存放了字符频率表，表头记录出现了字符类型总数，之后为各个字符及其频度。最后的部分存放了经过哈夫曼编码后的原文件数据，头部记录了原文件的长度。 3． 在文件的读取和存储上，设置一个读写缓存，每次读入一定的字节数，然后进行处理，而不是每次读入一个字节，这样效率太低，写出时同理。 4． 解压时重建哈夫曼树后，不要再次导出哈夫曼编码，每次读取一位二进制数据，直接搜索哈夫曼树，是0则跳转左孩子，是1则跳转右孩子。 5． 空文件和只有一种字符时应该单独考虑，哈夫曼树不能处理。 6． 之前在压缩时每次存入4个字节（32位），若文件尾不是整字节，补足为整字节（8位的倍数），看似没有问题，但是在读取时仍按4字节读取存入unsigned int，末尾的数据若非刚好为4个字节（低位为空），则读入时有效数据会被存入unsigned int的低位（int存储时先存入了低8-1位，再存16-9位...以此类推），造成错误。 7． 关于fread，若不考虑返回值，fread(buf,size,count,fp)，size和count的值可互换，只要size*count是需要读取的字节数即可。但是如果想知道实际读取了多少字节，比如一次读入1024字节，应该写为fread(buf,1,1024,fp)，当剩余数据不足1024时，会返回实际读取的count数，在这里就是字节数。若写为fread(buf,1024,1,fp)，当剩余数据超过1024时，返回1024，当剩余数据不足1024时，将返回0(虽然buf中会存有实际读取的数据)。 8． 还是fread的问题，传统情况下为了避免最后一个字节使用了两次，采用while(fread(buf,1,1,fp)&&!feof(fp))因为fread读完最后一个字节后，feof仍然不变，再次fread才触发feof。这里一次读取一个字节，fread(buf,1,1,fp)的返回值只会是0和1，即使读取最后一个字节也为1，再次读取才0，因此while中用&&没有问题，两个条件只会同为0或同为1。如果一次读取多个字节（比如1024），在文件总长度为1024的倍数时，和上述情况没有区别，若非1024倍数，最后一次读取fread将返回实际读取数量(<1024)，但是此时已经触发feof（因为最后一次读取是没有满足fread的请求的，这里的逻辑很微妙）,故while中&&应该改用||。 9． 在界面更新问题上，编写了一个更新显示进度函数，直接在压缩/解压函数中调用。##五、 用户手册 ![](lab3_Haffman/2.png)![](lab3_Haffman/3.png)##六、 测试结果 1.一个文本文件“四大名著.txt”（原大小 6,321,865字节，压缩后4,827,905字节，压缩率75%），一个可执行文件（压缩率77%），实现明显的压缩。 2.和一份pdf文档实现正确解压缩，但压缩效果不明显（压缩率99%），解压缩前后md5值不变。 3.解压缩时间在可接受的范围内，约16MB/s.![](lab3_Haffman/4.png)![](lab3_Haffman/5.png)![](lab3_Haffman/6.png)![](lab3_Haffman/7.png)![](lab3_Haffman/8.png)##七、 附录 源程序文件清单： （1） FrequencyList.h （2） HaffmanTree.h （3） MyUI.h （4） Hzip.c FrequencyList.h/*Last Update time:2017-11-01 Version：1.0 Author：LinXiang(PB16020923)Description： FrequencyList.*/#ifndef FREQUENCYLIST_H#define FREQUENCYLIST_H#include <stdio.h>#include <stdlib.h>#include <string.h>#define OK 1#define ERROR 0 typedef int Status;typedef struct Frequency{//一个字符(8位)及其出现频次 unsigned char ch;//0<=ch<=255 unsigned int f;}fre,*pfre;typedef struct FrequencyList{//频度表，所有出现的字符及频次 int num;//1<=num<=256 pfre list;//频度表数组，动态申请}frelist,*pfrelist;int frecmp(const void*a,const void*b){pfre aa=(pfre)a;pfre bb=(pfre)b;return(int)(bb->f-aa->f);//b-a这样才能让qsort降序排列}void UpdateTimeText(double progress);//声明以便下面函数调用更新进度 Status CreateFrequencyListFromFile(FILE*fp,pfrelist*fl){//从任意文件中创建频度表 fre arr[256]={};//临时存放所有字符，直接按下标存入更方便，不用插入或遍历 unsigned char buf[1048576]={};//当前读入缓存 int i,n;//n表示实际读入的字符数，仅在文件尾时不是1024 while((n=fread(buf,1,1048576,fp))||!feof(fp)){//读取文件每次1024字节，//注意size=1,count=1024,才能知道实际成功读入字节数(fread返回值),不要反过来,反过来的话一旦不满1024，fread返回值将为0 for(i=0;i<n;i++){arr[buf[i]].ch=buf[i];arr[buf[i]].f++;}}qsort(arr,256,sizeof(fre),&frecmp);//排序，不出现的字符会被排至尾部*fl=(pfrelist)malloc(sizeof(frelist));//让fl存放指向frelist的指针 for(i=0;i<256;i++){//统计出现的字符数量 if(arr[i].f==0)break;}(*fl)->num=i;(*fl)->list=(pfre)malloc(sizeof(fre)*((*fl)->num));//申请频度表的数组空间 for(i=0;i<(*fl)->num;i++){(*fl)->list[i].ch=arr[i].ch;(*fl)->list[i].f=arr[i].f;}return OK;}Status SaveFrequencyListToFile(FILE*fp,pfrelist fl){//保存频度表到压缩文件中 fwrite(&(fl->num),4,1,fp);int i;for(i=0;i<fl->num;i++){fwrite(&(fl->list[i].ch),1,1,fp);fwrite(&(fl->list[i].f),4,1,fp);}return OK;}Status LoadFrequencyListFromFile(FILE*fp,pfrelist*fl){//从压缩文件中读取频度表*fl=(pfrelist)malloc(sizeof(frelist));//让fl存放指向frelist的指针 fread(&((*fl)->num),4,1,fp);(*fl)->list=(pfre)malloc(sizeof(fre)*((*fl)->num));//申请频度表的数组空间 int i;for(i=0;i<(*fl)->num;i++){fread(&((*fl)->list[i].ch),1,1,fp);fread(&((*fl)->list[i].f),4,1,fp);}return OK;}#endif HaffmanTree.h ```c/*Last Update time:2017-11-01 Version：1.0 Author：LinXiang(PB16020923)Description： HaffmanTree.*/#ifndef HAFFMANTREE_H#define HAFFMANTREE_H#define OK 1#define ERROR 0#include <stdlib.h>#include <string.h>#include \"FrequencyList.h\" typedef int Status;typedef struct HaffmanTreeNode{struct HaffmanTreeNode*lchild,*rchild,*parent;unsigned int f;unsigned char ch;}htreenode,*htree;void UpdateTimeText(double progress);//声明以便下面函数调用更新进度 Status CreateHaffmanTreeFromFrequencyList(pfrelist fl,htree*ht){//从频度表创建哈夫曼数，频度表保证至少两种字符 int hfn=fl->num*2-1;//haffmantreenode个数 htreenode*arr=(htreenode*)malloc(sizeof(htreenode)*hfn);int i,t;for(i=0;i<fl->num;i++){//前 fl->num 个放叶结点 t=fl->num-i-1;//使升序排列 arr[t].ch=fl->list[i].ch;arr[t].f=fl->list[i].f;arr[t].lchild=NULL;arr[t].rchild=NULL;arr[t].parent=NULL;}int j,k;for(j=i,k=0;i<hfn;i++){arr[i].f=0;//权值初始为0//先选择最小的一个做左孩子 if(i-j>=1&&fl->num-k>=1){//叶结点和非叶结点都至少有一个可选 if(arr[k].f<=arr[j].f){arr[i].lchild=&arr[k];arr[k].parent=&arr[i];arr[i].f+=arr[k].f;k++;}else{arr[i].lchild=&arr[j];arr[j].parent=&arr[i];arr[i].f+=arr[j].f;j++;}}else if(fl->num-k>=1){//只有叶结点可选 arr[i].lchild=&arr[k];arr[k].parent=&arr[i];arr[i].f+=arr[k].f;k++;}else{//只有非叶结点可选 arr[i].lchild=&arr[j];arr[j].parent=&arr[i];arr[i].f+=arr[j].f;j++;}//再选择最小的一个做右孩子 if(i-j>=1&&fl->num-k>=1){//叶结点和非叶结点都至少有一个可选 if(arr[k].f<=arr[j].f){arr[i].rchild=&arr[k];arr[k].parent=&arr[i];arr[i].f+=arr[k].f;k++;}else{arr[i].rchild=&arr[j];arr[j].parent=&arr[i];arr[i].f+=arr[j].f;j++;}}else if(fl->num-k>=1){//只有叶结点可选 arr[i].rchild=&arr[k];arr[k].parent=&arr[i];arr[i].f+=arr[k].f;k++;}else{//只有非叶结点可选 arr[i].rchild=&arr[j];arr[j].parent=&arr[i];arr[i].f+=arr[j].f;j++;}}*ht=&arr[hfn-1];//指向根 return OK;}Status PreOrderTraverse(htree ht,int child,int i,char code[],char haffmancode[256][256]){//先序遍历，child=0表示当前是左孩子，child=1表示当前是右孩子,i为当前层次,code为当前遍历路径已存编码，haffmancode是编码表 if(ht==NULL)return ERROR;code[i]=child+'0';if(ht->lchild==NULL&&ht->rchild==NULL){//这是个叶结点 strcpy(haffmancode[ht->ch],code);//把当前编码保存到编码表里}else{PreOrderTraverse(ht->lchild,0,i+1,code,haffmancode);PreOrderTraverse(ht->rchild,1,i+1,code,haffmancode);}code[i]=0;//恢复 return OK;}Status CreateHaffmanCode(htree ht,char haffmancode[256][256]){//编码表haffmancode[256][256]牺牲一些空间以便快速索引 char code[256]={};//临时存放编码 PreOrderTraverse(ht->lchild,0,0,code,haffmancode);PreOrderTraverse(ht->rchild,1,0,code,haffmancode);return OK;}Status HaffmanCompress(FILE*fp1,FILE*fp2,char haffmancode[256][256],unsigned int bytenum){//压缩,bytenum为总长度 unsigned char inbuf[262144]={};//当前读入 unsigned int outbuf=0;//操作的缓存，满32位(4字节)才写入outbuf2，这个缓存主要用于位操作 unsigned int outbuf2[262144]={};//输出的缓存1024*4字节 fwrite(&bytenum,4,1,fp2);//记下总长度 int up=bytenum/100;//设置界面更新间隔 if(up==0)up=1;//文件过小，界面更新间隔为0，置1 int cnt=0;//循环计数器，缓存输出用的 unsigned int k=0;//计数器，更新界面用的 int cnt2=0;//循环计数器，缓存输出用的 int i,n=0;while((n=fread(inbuf,1,262144,fp1))||!feof(fp1)){//读取文件每次262144字节 for(i=0;i<n;i++){char*p=haffmancode[inbuf[i]];while(*p){outbuf<<=1;//左移一位 outbuf|=(*p-'0');//最低位存p p++;cnt++;if(cnt%32==0){//满8位输出 cnt=0;outbuf2[cnt2++]=outbuf;outbuf=0;if(cnt2==262144){cnt2=0;fwrite(outbuf2,4,262144,fp2);memset(outbuf2,0,262144*4);}}}k++;if(k%up==0)UpdateTimeText((double)k/(double)bytenum);}}while(cnt%32!=0){//文件尾补足为32位的整数倍 outbuf<<=1;cnt++;}outbuf2[cnt2++]=outbuf;fwrite(outbuf2,4,cnt2,fp2);return OK;}Status HaffmanDecompress(FILE*fp1,FILE*fp2,htree ht){//解压,解压时直接用哈夫曼数搜索对应字符 unsigned int inbuf=0;//输入的缓存，每次读取32位(4字节)unsigned char outbuf=0;//输出缓存（1字节） unsigned char outbuf2[1048576]={};//输出缓存2（1048576字节） unsigned int bytenum;//总字节数 unsigned int k=0;int cnt=0;int b;htreenode*htn=ht;fread(&bytenum,4,1,fp1);//读取总长度 int up=bytenum/100;//设置界面更新间隔 if(up==0)up=1;//文件过小，界面更新间隔为0，置1 int cnt2=0;while(k<bytenum){fread(&inbuf,1,4,fp1);//size=1,count=4 do{b=inbuf&0x80000000;//取最高位 inbuf<<=1;//左移一位 cnt++;if(b==0){htn=htn->lchild;}else{htn=htn->rchild;}if(htn->lchild==NULL&&htn->rchild==NULL){//到达叶结点 outbuf=htn->ch;outbuf2[cnt2++]=outbuf;outbuf=0;if(cnt2==1048576){cnt2=0;fwrite(outbuf2,1,1048576,fp2);memset(outbuf2,0,1048576);}k++;//计数加一 if(k==bytenum)break;htn=ht;//回根结点}}while(cnt%32!=0);cnt=0;if(k%up==0)UpdateTimeText((double)k/(double)bytenum);}fwrite(outbuf2,1,cnt2,fp2);return OK;}#endif ``` Hzip.c ```c/*Last Update time:2017-11-11 Version：1.1 Author：LinXiang(PB16020923)Description： Hzip.c.*/#include <stdio.h>#include <string.h>#include <time.h>#include \"MyUI.h\"#include \"FrequencyList.h\"#include \"HaffmanTree.h\"#define WIDTH 50//窗口的宽和高#define HEIGHT 15 HANDLE hout;HANDLE hin;time_t time_begin;time_t time_now;long FILESIZE;//记录文件长度，用于读取文件时计算进度 int FILETYPE;//char FILENAME[30];void GetCompressedFilePath(char*FPath,char*CFPath){//从传入的路径求得对应压缩文件路径 strcpy(CFPath,FPath);strcat(CFPath,\".hzip\");}void GetDecompressedFilePath(char*FPath,char*DFPath){//从传入的压缩文路径求得对应解压文件路径 strcpy(DFPath,FPath);DFPath[strlen(DFPath)-5]=0;//去除尾部\".hzip\"}void GetFileNameFromPath(char*FPath,char*FName){//从路径中提取文件名 char*pos;//最后一个\\的位置 char*p=FPath;while(*p){if(*p=='\\\\')pos=p;p++;}while(*pos){*FName++=*(++pos);//此法即可跳过‘\\’本身，又可复制字符串结束符到FName中}}long GetFileSizeFromPath(char*FPath){//获取文件大小 FILE*fp=fopen(FPath,\"r\");if(!fp)return-1;fseek(fp,0L,SEEK_END);long size=ftell(fp);fclose(fp);return size;}int GetFileTypeFromPath(char*FPath){//判断是解压(1)还是压缩(0)FILE*fp=fopen(FPath,\"rb+\");char MARK[22];int type;if(!fread(MARK,21,1,fp)){type=0;}else{MARK[21]=0;//字符串结尾 if(strcmp(\"#HAFFMANCOMPRESSFILE#\",MARK))type=0;else type=1;}fclose(fp);return type;}void UIInit(){//UI初始化 UI_InitSTDHandle(&hout,&hin,WIDTH,HEIGHT);UI_SetConsoleScreenBufferSize(hout,WIDTH,HEIGHT);//设置缓冲区大小 UI_SetConsoleWindowSize(hout,WIDTH,HEIGHT);//设置窗口大小//system(\"color F0\");此句与鼠标操作冲突！！！！！不要用system()ClearScreen(hout,B_WHITE);//清屏并设置前景背景色，不要用上句 COORD curpos;curpos.X=5;curpos.Y=HEIGHT-2;SetConsoleCursorPosition(hout,curpos);//设置光标位置 CONSOLE_CURSOR_INFO cursor_info={1,0};SetConsoleCursorInfo(hout,&cursor_info);//隐藏光标}void DrawAllBox(){//绘制所有方框 SMALL_RECT rc;rc=UI_SetRect(0,0,WIDTH-1,3);UI_DrawBox(hout,1,rc,B_WHITE|F_RED);rc=UI_SetRect(0,4,WIDTH-1,7);UI_DrawBox(hout,1,rc,B_WHITE|F_BLUE);rc=UI_SetRect(0,8,WIDTH-1,11);UI_DrawBox(hout,1,rc,B_WHITE|F_BLUE);rc=UI_SetRect(0,12,WIDTH-1,14);UI_DrawBox(hout,1,rc,B_WHITE|F_CYAN);}void DrawInfoText(char*filename,int type,int size){//文件名，类型是解压(1)还是压缩(0)char t_title[30];sprintf(t_title,\"Hzip V1.1\");UI_DrawText(hout,B_WHITE|F_RED,t_title,strlen(t_title),1,0+2,WIDTH-1-2);sprintf(t_title,\"Code by PB16020923\");UI_DrawText(hout,B_WHITE|F_RED,t_title,strlen(t_title),2,0+2,WIDTH-1-2);//窗口标题显示当前操作 char t_info[38];sprintf(t_info,\"Hzip V1.1-%s\",type==0?\"Compressing...\":\"Decompressing...\");SetConsoleTitle(t_info);//文件名 char t_filename[38];sprintf(t_filename,\"FileName:%s\",filename);UI_DrawText(hout,B_WHITE|F_BLUE,t_filename,strlen(t_filename),5,0+2,WIDTH-1-2);//文件大小 char t_size[38];sprintf(t_size,\"Size:%0.2f KB\",(double)size/1024);UI_DrawText(hout,B_WHITE|F_BLUE,t_size,strlen(t_size),6,0+2,WIDTH-1-2);}void UpdateTimeText(double progress){//根据进度(0-1)更新剩余时间 time(&time_now);//已花时间 char t_spenttime[40];sprintf(t_spenttime,\"Spent Time:%d s\",time_now-time_begin);UI_CleanText(hout,9,0+2,WIDTH-1-2);UI_DrawText(hout,B_WHITE|F_BLUE,t_spenttime,strlen(t_spenttime),9,0+2,WIDTH-1-2);//剩余时间 char t_remainedtime[40];sprintf(t_remainedtime,\"Remained Time:%d s\",(int)((time_now-time_begin)*(1-progress)/progress));UI_CleanText(hout,10,0+2,WIDTH-1-2);UI_DrawText(hout,B_WHITE|F_BLUE,t_remainedtime,strlen(t_remainedtime),10,0+2,WIDTH-1-2);//画进度条 int k=47*progress,i;for(i=2;i<=k;i++){//UI_DrawText(hout,B_BLUE,\" \",1,12,i,i);UI_DrawText(hout,B_CYAN,\" \",1,13,i,i);}}void DrawSelect(int select){//没有文件传入时显示配置界面,select=1表示已选中，即当前已创建右键菜单 ClearScreen(hout,B_WHITE);SMALL_RECT rc;rc=UI_SetRect(0,0,WIDTH-1,4);UI_DrawBox(hout,1,rc,B_WHITE|F_RED);char t_title[38];sprintf(t_title,\"Hzip V1.1-Setting\");UI_DrawText(hout,B_WHITE|F_RED,t_title,strlen(t_title),2,0+2,WIDTH-1-2);int dx=10,dy=5;rc=UI_SetRect(0+dx,0+dy,5+dx,2+dy);UI_DrawBox(hout,1,rc,B_WHITE|F_BLUE);UI_DrawText(hout,B_WHITE|F_BLUE,select==1?\"√\":\" \",2,1+dy,2+dx,3+dx);char t_cj[30]=\"Create right-click menu\";UI_DrawText(hout,B_WHITE|F_BLUE,t_cj,strlen(t_cj),1+dy,7+dx,7+dx+strlen(t_cj));}int CheckKey(){//检查右键菜单注册表是否已设置 HKEY k1,k2,k3;if(RegOpenKeyEx(HKEY_CLASSES_ROOT,\"*\",0,KEY_ALL_ACCESS,&k1)!=ERROR_SUCCESS){return 0;}if(RegOpenKeyEx(k1,\"shell\",0,KEY_ALL_ACCESS,&k2)!=ERROR_SUCCESS){return 0;}if(RegOpenKeyEx(k2,\"Use Hzip to compress/decompress...\",0,KEY_ALL_ACCESS,&k3)!=ERROR_SUCCESS){return 0;}return 1;}void SetKey(char*exepath){//设置或取消右键菜单注册表 HKEY k1,k2,k3,k4;char readvalue[128]={};char setvalue[128]={};if(RegOpenKeyEx(HKEY_CLASSES_ROOT,\"*\",0,KEY_ALL_ACCESS,&k1)!=ERROR_SUCCESS){RegCreateKey(HKEY_CLASSES_ROOT,\"*\",&k1);}if(RegOpenKeyEx(k1,\"shell\",0,KEY_ALL_ACCESS,&k2)!=ERROR_SUCCESS){RegCreateKey(k1,\"shell\",&k2);}if(RegOpenKeyEx(k2,\"Use Hzip to compress/decompress...\",0,KEY_ALL_ACCESS,&k3)!=ERROR_SUCCESS){//没有右键 RegCreateKey(k2,\"Use Hzip to compress/decompress...\",&k3);RegCreateKey(k3,\"command\",&k4);strcpy(setvalue,exepath);strcat(setvalue,\"%1\");RegSetValueEx(k4,NULL,0,REG_SZ,setvalue,sizeof(setvalue));DrawSelect(1);MessageBox(NULL,\"Program has created a right-click menu to use Hzip.\",\"SET\",MB_OK|MB_ICONINFORMATION);}else{//有右键，删除 RegDeleteKey(k3,\"command\");RegDeleteKey(k2,\"Use Hzip to compress/decompress...\");DrawSelect(0);MessageBox(NULL,\"Program has deteled the right-click menu to use Hzip.\",\"DETELE\",MB_OK|MB_ICONINFORMATION);}RegCloseKey(k1);RegCloseKey(k2);RegCloseKey(k3);RegCloseKey(k4);}int Compress(char*fpath){//预处理及压缩 FILE*fp1=fopen(fpath,\"rb+\");char cfpath[512];GetCompressedFilePath(fpath,cfpath);//生成压缩文件存储路径 FILE*fp2=fopen(cfpath,\"wb+\");char MARK[21]=\"#HAFFMANCOMPRESSFILE#\";fwrite(MARK,21,1,fp2);//标记这是一个压缩文件 pfrelist fl;CreateFrequencyListFromFile(fp1,&fl);//读取源文件，创建频度表 SaveFrequencyListToFile(fp2,fl);//保存频度表到目标文件 if(fl->num!=0&&fl->num!=1){//0表示空文件，1表示只有一种字符，这两种情况都不用编码，保存频度表即可 htree ht;CreateHaffmanTreeFromFrequencyList(fl,&ht);//从频度表创建哈夫曼树 char haffmancode[256][256]={};CreateHaffmanCode(ht,haffmancode);fseek(fp1,0,SEEK_SET);//源文件移回文件头 HaffmanCompress(fp1,fp2,haffmancode,ht->f);//根结点的权值即为总字符数}fclose(fp1);fclose(fp2);}int Decompress(char*fpath){//预处理及解压 FILE*fp1=fopen(fpath,\"rb+\");char dfpath[512];GetDecompressedFilePath(fpath,dfpath);//生成解压文件存储路径 FILE*fp2=fopen(dfpath,\"wb+\");fseek(fp1,21,SEEK_SET);//跳过标记 pfrelist fl;LoadFrequencyListFromFile(fp1,&fl);if(fl->num==0);//空文件，不操作 else if(fl->num==1){//只有一种字符的文件 unsigned int i;for(i=0;i<fl->list[0].f;i++)fwrite(&(fl->list[0].ch),1,1,fp2);}else{htree ht;CreateHaffmanTreeFromFrequencyList(fl,&ht);//从频度表创建哈夫曼树，解压时不用再生成哈夫曼编码，搜索树即可 HaffmanDecompress(fp1,fp2,ht);}fclose(fp1);fclose(fp2);}int main(int argc,char*argv[]){UIInit();if(argc>1){//有传入路径 DrawAllBox();FILETYPE=GetFileTypeFromPath(argv[1]);FILESIZE=GetFileSizeFromPath(argv[1]);GetFileNameFromPath(argv[1],FILENAME);DrawInfoText(FILENAME,FILETYPE,FILESIZE);time(&time_begin);//计时开始 if(FILETYPE==0){Compress(argv[1]);}else{Decompress(argv[1]);}UpdateTimeText(1);}else{DrawSelect(CheckKey());INPUT_RECORD inrec;DWORD res;//返回已读取的记录数 COORD pos={0,0};int k;for(;;){k++;ReadConsoleInput(hin,&inrec,1,&res);//读取鼠标信息 if(inrec.EventType==MOUSE_EVENT){if(inrec.Event.MouseEvent.dwEventFlags==0&&\\inrec.Event.MouseEvent.dwButtonState==FROM_LEFT_1ST_BUTTON_PRESSED){SetKey(argv[0]);//设置右键}}}}char t_finish[30];sprintf(t_finish,\"Finished! Press any key to exit!\");UI_DrawText(hout,F_CYAN|B_BLACK,t_finish,strlen(t_finish),HEIGHT-2,0+2,WIDTH-1-2);getchar();}``` MyUI.h ​ ​ 界面部分，代码过长且与数据结构关系不大，此处不贴出","tags":["DS"],"categories":[]},{"title":"数据结构上机题2 模拟银行业务办理","url":"/s/p/9axeo0/","content":"##题目 1.检查日期： 10.28截止（下周六10.21做完的可以提前检查，人会比较少） 2.实验内容： 参考题集中P100的实验2.6银行模拟（做P102实验2.8电梯模拟也可以）输出界面要求按照时间顺序输出时间，事件，并计算平均等待时间。不出意外的话，要么rand设置会出现队伍越来越长要么会出现队伍变空没人。那么设置关门时间清空所有排队者或者中午吃饭关门等等，vip通道可自己设计。可自己添加辅助条件，要求合理，能说服助教。输出界面鼓励同学们用图形界面（动画的方式）来呈现。给分以完成程度评定（大家要仔细理解题集上面实验的题意哈） 3.要求：数据结构用链表与队列，还要有上述能表现出事件先后顺序的输出界面（希望大家的输出界面友好一点...），源代码当场检查完拷到实验室电脑上（命名：学号+姓名+实验x），每次上机要先签到，依签到顺序检查，本次实验要写实验报告（格式参考题集P105迷宫问题的实习报告）实验报告要求纸质版，记得写名字学号，实验检查结束后周一上课交。 以及：实验一还没有检查的同学下周六还可以接着去检查。（实验一不需要实验报告，只需提交源代码）##一、 需求分析 1.实现功能：模拟银行业务办理。银行只能同时运行一个窗口，但设有两个队列。客户到达时，先排第一个队列，客户可以办理两种业务：取款或存款。如果是第一种业务，但银行现有的资金不能满足客户，那么客户立刻排入第二个队列队尾进行等候，否则，花费一定时间办理业务后立刻离开。每当办理完一个第二种业务客户时，顺序检查（假设检查不需要时间）第二个队列的客户，对于能满足者进行业务办理，否则排入队尾继续等候。如果检查过程中，银行的资金已经小于刚才办理完第一种业务的客户时的资金或者第二个队列中的所有客户已经检查了一遍，则停止检查，继续接待第一个队列中的客户。在到达营业结束时间时，所有客户立刻离开银行。计算所有客户在银行内逗留的平均时间并输出。 2.初始时需要设置银行营业时间CloseTime(int,>0)、银行初始资金BankMoney(int,>0)、下一个客户到来时间间隔的上下限NextCutormerTime(int,>0)、客户办理业务所需时间的上下限DurTime(int,>0)、客户交易金额的上下限Amount(int,!=0)，由用户通过控制台窗口输入。 3.模拟业务办理过程采用事件驱动方式，用动态链表数据结构实现事件的加入与执行。 4.客户队列用顺序存储的循环队列存放。 5.模拟过程中在控制台中实时输出当前时间、银行资金、正在办理业务的客户、两个队列中的客户、发生的事件。 6.测试数据：任意，注意测定两种极端情况， （1） 两个客户到达间隔极短，而客户办理时间极长。 （2） 两个客户到达间隔极长，而客户办理时间极短。 <!--more-->##二、 概要设计 1.抽象数据类型客户队列定义如下： ADT UserQueue{数据对象：D={User|User.id=1,2,...,n;n>=0}数据关系：无 基本操作： InitQueue(&q);操作结果：创建客户队列q。 DestoryQueue(&q);初始条件：客户队列q存在。 操作结果：销毁客户队列q。 QueueLength(q);初始条件：客户队列q存在。 操作结果：返回客户队列q的长度。 EnQueue(&q,elem);初始条件：客户队列q存在。 操作结果：将客户elem加入客户队列q的队尾。 DeQueue(&q,&elem);初始条件：客户队列q存在。 操作结果：将客户从客户队列q的队头删除，存放在elem中。 PeekQueueByPos(&q,i,&elem);初始条件：客户队列q存在。 操作结果：返回客户队列q的第i个元素但不出队。}ADT UserQueue 2.抽象数据类型事件链表定义如下： ADT EventLinkList{数据对象：D={Event}数据关系：无 基本操作： MakeEventNode(occurtime,type);操作结果：根据参数创建事件节点。 DestoryEventList(&el);初始条件：事件链表el存在。 操作结果：销毁事件链表el。 InitEventList(&el);初始条件：事件链表el存在。 操作结果：创建事件链表el。 InsertEventToListInOrder(el,&ev);初始条件：事件链表el存在。 操作结果：将事件ev按时间顺序插入事件链表el。 DeleteEventFromListByPos(el,pos,&ev);初始条件：事件链表el存在。 操作结果：删除事件链表el的第pos个事件，放在ev中。}ADT EventLinkList 3.主程序 void main(){用户输入参数;初始化窗口及各数据类型;while(营业未结束){取下一个事件;switch(该事件){case 到来:加入用户队列； if(服务窗口空闲)服务队列1的下一个客户;break;case 离开:停留时间计算并加入统计时间;银行资金改变;if(该客户是存款)检查队列2;else(该客户是取款&&客户来自队列2)继续检查队列2;if(不是正在检查队列2)服务队列1的下一个客户;break;case 结束:队列中所有客户离开；}}输出平均时间;}4.本程序含四个模块(1)主模块(2)用户队列模块(3)事件链表模块(4)图形界面模块 ![](lab2_Bank/0.png)##三、 详细设计 1． 客户类型 typedef struct _User{int id;int arrtime;int durtime;int amount;}User;2． 客户队列类型 typedef struct _SqQueue{User*base;int front;int rear;}SqQueue;3． 事件及事件链表类型 typedef struct _Event{int occurtime;enum TYPE type;struct _Event*next;}Event,*EvList;4． 客户队列操作 Status InitQueue(SqQueue*q);//初始化队列 Status DestoryQueue(SqQueue*q);//销毁队列 int QueueLength(SqQueue q);//队列长度 Status EnQueue(SqQueue*q,User elem);//入队 Status DeQueue(SqQueue*q,User*elem);//出队 Status PeekQueueByPos(SqQueue*q,int i,User*elem);//查看第i个元素但不出队 5． 事件链表操作 Event*MakeEventNode(int occurtime,int type);//创建事件结点 Status DestoryEventList(EvList*l);//销毁事件链表 Status InitEventList(EvList*l);//初始化事件链表 Status InsertEventToListInOrder(EvList l,Event*ev);//按时间顺序插入事件，插入后该事件将成为事件列表的一部分 Status DeleteEventFromListByPos(EvList l,int pos,Event*ev);//删除指定位置的事件，pos=1...length,ev存放删除的事件 6． 图形界面操作 SMALL_RECT UI_SetRect(int left,int top,int right,int bottom);//根据坐标取返回对应矩形区域数据 void UI_SetConsoleWindowSize(HANDLE hOut,int width,int height);//设置窗口大小 void UI_SetConsoleScreenBufferSize(HANDLE hOut,int width,int height);//设置缓冲区大小 void UI_InitSTDHandle(HANDLE*hOut,CONSOLE_SCREEN_BUFFER_INFO*bInfo,int width,int height);//初始化 void UI_DrawText(HANDLE hOut,WORD attr,char*text,int len,int row,int left,int right);//在指定行左右位置之间居中输出一行文本 void UI_CleanText(HANDLE hOut,int row,int left,int right);//在指定行左右位置之间清除一行文本 void UI_CleanTextRect(HANDLE hOut,int top,int bottom,int left,int right);//在指定区域之间清除文本 void UI_DrawBox(HANDLE hOut,int bSingle,SMALL_RECT rc,WORD attr);//画方框 7． 其他函数 void ShowBox();//绘制所有方框 void ShowBankandTimeText();//绘制时间和银行资金的文本 void ShowMessageText1();//绘制信息文本1 void ShowMessageText2(int id,int type);//绘制信息文本2 void ShowQueueText();//绘制队列文本 int Random(int low,int high);//随机数 void RandNextCustomer();//生成下一个客户到来事件 void Init();//初始化 Status ServeNextCustomerInQueue1(SqQueue*q_point);//服务队列1的下一个客户，如果不满足，则继续寻找下一个 Status ServeNextCustomerInQueue2(SqQueue*q_point);//服务队列2的下一个客户 Status Check();//检查队列2 8． 具体的函数实现见附录，均有详细注释，此处不再赘述。##四、 调试分析 1． 本程序的难点在于在事件中对队列2的检查，以及对队列中下个办理业务的客户的选取。 ​ 2． 在对队列2的检查上，编写了Check函数，每当队列1的客户存款之后调用，在Check函数中顺序寻找下一个符合要求的客户，后调用ServeNextCustomerInQueue2进行业务办理，但该客户完成后，队列2中可能仍有满足需求的客户，故应设置全局变量Checking表示当前是在队列2检查状态，以便在该客户发生离开事件时，再次调用Check继续检查队列2，如果此时没有符合条件的客户，则置Checking状态为0，以便离开事件发生时，下一个办理业务的客户从队列1中选取。这种方法需要置全局变量，且思路不是很清晰，之前设想了将离开事件从main函数中剥离，而检查队列2时，进入Check函数，在其中满足了尽可能多的客户后才退回主函数，期间可调用离开事件函数处理队列2的客户离开，但考虑到本程序为事件驱动，事件按照时间顺序发生，在处理队列2的客户时，可能有新的客户到来事件发生，如果进入Check后一直执行至不能满足条件，可能导致时间线出现错乱，期间到来的客户事件将发生在之后唉。目前没有想到更好的方法。 3． 在对队列中下一个办理业务的客户的选取上，编写了ServeNextCustomerInQueue1和ServeNextCustomerInQueue2，这里出现了部分功能重叠，此乃败笔唉。主要是ServeNextCustomerInQueue1需要递归直至找到可以办理业务的下一个客户，但ServeNextCustomerInQueue2无需判断，在Check中已进行判断 4． ServeNextCustomerInQueue中使用了DeQueue,因此参数需要传入q1的地址，之前疏忽，直接以q1为参数，导致q1中的元素执行了DeQueue仍然存在。 5． 本程序模拟银行业务，本来打算用时间作为循环变量，结束营业时间为结束条件，但是为了体现离散事件模拟，故采用事件驱动模式，即以事件为单位，一次循环发生一个事件，但在界面输出上，为了保证时间的连续性和可观看性，在输出上把两个事件之间的时间流逝体现出来 6． 使用C语言且不使用第三方库进行图形界面编程实在困难，之前打算学习一下MFC，然而其繁琐得令人望而却步！##五、 用户手册 ![](lab2_Bank/01.png)![](lab2_Bank/02.png)##六、 测试结果 1.输入及输出如图，两个客户到达间隔极短，而客户办理时间极长。 ![](lab2_Bank/03.png)2.输入及输出如图，两个客户到达间隔极长，而客户办理时间极短。 ![](lab2_Bank/04.png)3.其他截图 ![](lab2_Bank/1.png)![](lab2_Bank/2.png)![](lab2_Bank/3.png)![](lab2_Bank/4.png)![](lab2_Bank/5.png)![](lab2_Bank/6.png)##七、 附录-源程序文件清单： （1） UserQueue.h ​ （2） EventLinkList.h ​ （3） MyUI.h ​ （4） Bank.c UserQueue.h ```c/*Last Update time:2017-10-17 Version：1.0 Author：LinXiang(PB16020923)Description： UserQueue.*/#include <stdlib.h>#define QMAXSIZE 100#define OK 1#define ERROR 0 typedef int Status;typedef struct _User{int id;int arrtime;int durtime;int amount;}User;typedef struct _SqQueue{User*base;int front;int rear;}SqQueue;Status InitQueue(SqQueue*q){//初始化队列 q->base=(User*)malloc(QMAXSIZE*sizeof(User));q->front=0;q->rear=0;return OK;}Status DestoryQueue(SqQueue*q){//销毁队列 if(!q->base)return ERROR;free(q->base);q->front=0;q->rear=0;return OK;}int QueueLength(SqQueue q){//求队列长度 return(q.rear-q.front+QMAXSIZE)%QMAXSIZE;}Status EnQueue(SqQueue*q,User elem){//入队 if((q->rear+1)%QMAXSIZE==q->front)return ERROR;q->base[q->rear]=elem;q->rear=(q->rear+1)%QMAXSIZE;return OK;}Status DeQueue(SqQueue*q,User*elem){//出队 if(q->rear==q->front)return ERROR;*elem=q->base[q->front];q->front=(q->front+1)%QMAXSIZE;return OK;}Status PeekQueue(SqQueue*q,User*elem){//查看队头但不出队 if(q->rear==q->front)return ERROR;*elem=q->base[q->front];return OK;}Status PeekQueueByPos(SqQueue*q,int i,User*elem){//查看第i个元素但不出队 if(i>QueueLength(*q))return ERROR;*elem=q->base[(q->front+i-1)%QMAXSIZE];return OK;}``` EventLinkList.h ```c/*Last Update time:2017-10-17 Version：1.0 Author：LinXiang(PB16020923)Description： EventLinkList.*/#include <stdlib.h>#include <string.h>#define OK 1#define ERROR 0 enum TYPE{HEADNODE,ARR,LEAVE,CLOSE};//枚举事件类型，其中HEADNODE为表示头节点 typedef int Status;typedef struct _Event{int occurtime;enum TYPE type;struct _Event*next;}Event,*EvList;Event*MakeEventNode(int occurtime,int type){//创建事件结点 Event*p=(Event*)malloc(sizeof(Event));p->type=(enum TYPE)type;p->occurtime=occurtime;p->next=NULL;return p;}Status DestoryEventList(EvList*l){//销毁事件链表 if(*l==NULL)return OK;Event*p=(*l)->next,*q;while(p!=NULL){q=p->next;free(p);p=q;}free(*l);*l=NULL;return OK;}Status InitEventList(EvList*l){//初始化事件链表 if(*l!=NULL)DestoryEventList(l);*l=MakeEventNode(-1,HEADNODE);return OK;}Status InsertEventToListInOrder(EvList l,Event*ev){//按时间顺序插入事件，插入后该事件将成为事件列表的一部分 Event*q=l,*p;while(q->next!=NULL&&q->next->occurtime<ev->occurtime){q=q->next;}ev->next=q->next;q->next=ev;return OK;}Status DeleteEventFromListByPos(EvList l,int pos,Event*ev){//删除指定位置的事件，pos=1...length,ev存放删除的事件 if(pos<1)return ERROR;Event*q=l;int i=1;while(q->next!=NULL&&i++<pos){q=q->next;}if(q->next==NULL)return ERROR;else{Event*r=q->next;memcpy(ev,r,sizeof(Event));q->next=q->next->next;free(r);}return OK;}``` MyUI.h ```c/*Last Update time:2017-10-22 Version：1.0 Author：LinXiang(PB16020923)Description： MyUI.c.*/#include <windows.h>#include <stdio.h>#define F_GRAY FOREGROUND_INTENSITY#define F_CYAN FOREGROUND_GREEN|FOREGROUND_BLUE|FOREGROUND_INTENSITY#define F_ORANGE FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_INTENSITY#define F_PURPLE FOREGROUND_RED|FOREGROUND_BLUE|FOREGROUND_INTENSITY#define F_RED FOREGROUND_RED|FOREGROUND_INTENSITY#define F_GREEN FOREGROUND_GREEN|FOREGROUND_INTENSITY#define F_BLUE FOREGROUND_BLUE|FOREGROUND_INTENSITY#define F_WHITE FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE|FOREGROUND_INTENSITY#define F_USUALWHITE FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE//不加亮的白色为正常颜色#define F_BLACK FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE|COMMON_LVB_REVERSE_VIDEO#define B_GRAY BACKGROUND_INTENSITY#define B_CYAN BACKGROUND_BLUE|BACKGROUND_GREEN|BACKGROUND_INTENSITY#define B_ORANGE BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_INTENSITY#define B_PURPLE BACKGROUND_RED|BACKGROUND_BLUE|BACKGROUND_INTENSITY#define B_BLUE BACKGROUND_BLUE|BACKGROUND_INTENSITY#define B_RED BACKGROUND_RED|BACKGROUND_INTENSITY#define B_GREEN BACKGROUND_GREEN|BACKGROUND_INTENSITY#define B_WHITE BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE|BACKGROUND_INTENSITY#define B_USUALWHITE BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE//不加亮的白色为正常颜色#define B_BLACK BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE|COMMON_LVB_REVERSE_VIDEO SMALL_RECT UI_SetRect(int left,int top,int right,int bottom){//根据坐标取返回对应矩形区域数据 SMALL_RECT rc={0,0,0,0};rc.Left=left;rc.Top=top;rc.Right=right;rc.Bottom=bottom;return rc;}void UI_SetConsoleWindowSize(HANDLE hOut,int width,int height){//设置窗口大小 SMALL_RECT rc;rc=UI_SetRect(0,0,width-1,height-1);SetConsoleWindowInfo(hOut,1,&rc);//重置窗口位置和大小}void UI_SetConsoleScreenBufferSize(HANDLE hOut,int width,int height){//设置缓冲区大小 COORD size;size.X=width;size.Y=height;SetConsoleScreenBufferSize(hOut,size);//重新设置缓冲区大小}void UI_InitSTDHandle(HANDLE*hOut,CONSOLE_SCREEN_BUFFER_INFO*bInfo,int width,int height){//初始化*hOut=GetStdHandle(STD_OUTPUT_HANDLE);GetConsoleScreenBufferInfo(*hOut,bInfo);SetConsoleOutputCP(437);//设置代码页 UI_SetConsoleScreenBufferSize(*hOut,width,height);//必须先设置大的缓冲区 UI_SetConsoleWindowSize(*hOut,width,height);//才能设置对应大小的窗口}void UI_DrawText(HANDLE hOut,WORD attr,char*text,int len,int row,int left,int right){//在指定行左右位置之间居中输出一行文本 DWORD buf[128];//COORD pos;pos.Y=row;pos.X=(right-left+1-len)/2+left;FillConsoleOutputAttribute(hOut,attr,len,pos,(LPDWORD)buf);//给该坐标的字符上色 WriteConsoleOutputCharacter(hOut,text,len,pos,(LPDWORD)buf);//在pos处输出长为len的text}void UI_CleanText(HANDLE hOut,int row,int left,int right){//在指定行左右位置之间清除一行文本 DWORD buf[128];//COORD pos;pos.Y=row;pos.X=left;WORD attr=F_BLACK;FillConsoleOutputAttribute(hOut,attr,right-left+1,pos,(LPDWORD)buf);//给该坐标的字符上色 FillConsoleOutputCharacter(hOut,' ',right-left+1,pos,(LPDWORD)buf);//在pos处重复输出多个某字符}void UI_CleanTextRect(HANDLE hOut,int top,int bottom,int left,int right){//在指定区域之间清除文本 DWORD buf[128];WORD attr=F_BLACK;int i;for(i=top;i<=bottom;i++){COORD pos;pos.Y=i;pos.X=left;FillConsoleOutputAttribute(hOut,attr,right-left+1,pos,(LPDWORD)buf);//给该坐标的字符上色 FillConsoleOutputCharacter(hOut,' ',right-left+1,pos,(LPDWORD)buf);//在pos处重复输出多个某字符}}void UI_DrawBox(HANDLE hOut,int bSingle,SMALL_RECT rc,WORD attr){//画方框 char chBox[6];DWORD buf[128];//存放最后一个参数：输出的字符数 COORD pos;if(bSingle){chBox[0]=(char)0xda;//左上角点 chBox[1]=(char)0xbf;//右上角点 chBox[2]=(char)0xc0;//左下角点 chBox[3]=(char)0xd9;//右下角点 chBox[4]=(char)0xc4;//水平 chBox[5]=(char)0xb3;//坚直}else{chBox[0]=(char)0xc9;//左上角点 chBox[1]=(char)0xbb;//右上角点 chBox[2]=(char)0xc8;//左下角点 chBox[3]=(char)0xbc;//右下角点 chBox[4]=(char)0xcd;//水平 chBox[5]=(char)0xba;//坚直}pos.Y=rc.Top;//画左上角 pos.X=rc.Left;FillConsoleOutputAttribute(hOut,attr,1,pos,(LPDWORD)buf);//给该坐标的字符上色 WriteConsoleOutputCharacter(hOut,&chBox[0],1,pos,(LPDWORD)buf);//画右上角 pos.X=rc.Right;FillConsoleOutputAttribute(hOut,attr,1,pos,(LPDWORD)buf);//给该坐标的字符上色 WriteConsoleOutputCharacter(hOut,&chBox[1],1,pos,(LPDWORD)buf);pos.Y=rc.Bottom;//画左下角 pos.X=rc.Left;FillConsoleOutputAttribute(hOut,attr,1,pos,(LPDWORD)buf);//给该坐标的字符上色 WriteConsoleOutputCharacter(hOut,&chBox[2],1,pos,(LPDWORD)buf);//画右下角 pos.X=rc.Right;FillConsoleOutputAttribute(hOut,attr,1,pos,(LPDWORD)buf);//给该坐标的字符上色 WriteConsoleOutputCharacter(hOut,&chBox[3],1,pos,(LPDWORD)buf);//画边框的上 下边界 for(pos.X=rc.Left+1;pos.X<rc.Right;pos.X++){pos.Y=rc.Top;FillConsoleOutputAttribute(hOut,attr,1,pos,(LPDWORD)buf);//给该坐标的字符上色 WriteConsoleOutputCharacter(hOut,&chBox[4],1,pos,(LPDWORD)buf);//画上边界 pos.Y=rc.Bottom;FillConsoleOutputAttribute(hOut,attr,1,pos,(LPDWORD)buf);//给该坐标的字符上色 WriteConsoleOutputCharacter(hOut,&chBox[4],1,pos,(LPDWORD)buf);//画下边界}//画边框的左右边界 for(pos.Y=rc.Top+1;pos.Y<rc.Bottom;pos.Y++){pos.X=rc.Left;FillConsoleOutputAttribute(hOut,attr,1,pos,(LPDWORD)buf);//给该坐标的字符上色 WriteConsoleOutputCharacter(hOut,&chBox[5],1,pos,(LPDWORD)buf);//画左边界 pos.X=rc.Right;FillConsoleOutputAttribute(hOut,attr,1,pos,(LPDWORD)buf);//给该坐标的字符上色 WriteConsoleOutputCharacter(hOut,&chBox[5],1,pos,(LPDWORD)buf);//画右边界}}``` Bank.c ```c/*Last Update time:2017-10-26 Version：1.0 Author：LinXiang(PB16020923)Description： Bank.c.*/#include \"UserQueue.h\"#include \"EventLinkList.h\"#include \"MyUI.h\"#define DEBUG#define TRUE 1#define FALSE 0#define WIDTH 120//窗口的宽和高#define HEIGHT 50 int ScreenHeight=HEIGHT;//屏幕缓冲区的时间高度，会随队列长度而变，初始等于窗口高度 int CustomNum=0,BankMoney=10000,CloseTime=600,TotalTime=0,Time=0;//客户数，银行资金，结束时间，客户停留累计时间，当前时间 int NextCustomTime_LowerBound=1,NextCustomTime_UpperBound=10;//下一个客户到来的时间间隔上下限 int CustomDurTime_LowerBound=1,CustomDurTime_UpperBound=20;//客户办理业务时间的上下想 int CustomAmount_LowerBound=1,CustomAmount_UpperBound=9000;//客户服务的金额 int moneybeforecheck=0;//在检查队列2之前的银行资金 int MORE=0,checking=0;//继续营业，正在检查第二个队列 EvList el=NULL;//事件链表 SqQueue q1,q2;//队列1，2 User servingusr={0,0,0,0};//正在服务的客户 HANDLE hout;//控制台句柄 CONSOLE_SCREEN_BUFFER_INFO binfo;void ShowBox(){//绘制所有方框 system(\"cls\");SMALL_RECT rc;rc=UI_SetRect(0,0,WIDTH-1,2);UI_DrawBox(hout,0,rc,F_CYAN);//画最上面的框 rc=UI_SetRect(0,3,WIDTH/2-1,5);UI_DrawBox(hout,0,rc,F_GREEN);//画第一个消息框 rc=UI_SetRect(WIDTH/2,3,WIDTH-1,5);UI_DrawBox(hout,0,rc,F_GREEN);//画第二个消息框 rc=UI_SetRect(0,6,WIDTH/2-1,8);UI_DrawBox(hout,0,rc,F_ORANGE);//画队列1的框 rc=UI_SetRect(WIDTH/2,6,WIDTH-1,8);UI_DrawBox(hout,0,rc,F_BLUE);//画队列2的框 rc=UI_SetRect(0,6,WIDTH/2-1,ScreenHeight-1);UI_DrawBox(hout,0,rc,F_ORANGE);//画队列1的框 rc=UI_SetRect(WIDTH/2,6,WIDTH-1,ScreenHeight-1);UI_DrawBox(hout,0,rc,F_BLUE);//画队列2的框}void ShowBankandTimeText(){//绘制时间和银行资金的文本 char t_bankmony[30];sprintf(t_bankmony,\"BankMoney:%d YUAN\",BankMoney);UI_CleanText(hout,1,WIDTH/2+1,WIDTH-1-1);//清除原先的文本 UI_DrawText(hout,F_CYAN,t_bankmony,strlen(t_bankmony),1,WIDTH/2+1,WIDTH-1-1);char t_time[30];sprintf(t_time,\"Time:%d minute\",Time);UI_CleanText(hout,1,0+1,WIDTH/2-1-1);UI_DrawText(hout,F_CYAN,t_time,strlen(t_time),1,0+1,WIDTH/2-1-1);char t_q1[30];sprintf(t_q1,\"Queue 1:[%d]customers\",QueueLength(q1));UI_CleanText(hout,7,0+1,WIDTH/2-1-1);UI_DrawText(hout,F_ORANGE,t_q1,strlen(t_q1),7,0+1,WIDTH/2-1-1);char t_q2[30];sprintf(t_q2,\"Queue 2:[%d]customers\",QueueLength(q2));UI_CleanText(hout,7,WIDTH/2+1,WIDTH-1-1);UI_DrawText(hout,F_BLUE,t_q2,strlen(t_q2),7,WIDTH/2+1,WIDTH-1-1);}void ShowMessageText1(){//绘制信息文本1 char t_message[100];if(servingusr.id!=0)sprintf(t_message,\"Serving for ID:%-3d(AMOUNT:%-6d ARRTIME:%-4d DURTIME:%-3d)\"\\,servingusr.id,servingusr.amount,servingusr.arrtime,servingusr.durtime);else sprintf(t_message,\"Bank Info:Free.\");UI_CleanText(hout,4,0+1,WIDTH/2-1-1);UI_DrawText(hout,F_GREEN,t_message,strlen(t_message),4,0+1,WIDTH/2-1-1);}void ShowMessageText2(int id,int type){//绘制信息文本2 char t_message[100];switch(type){case 1:sprintf(t_message,\"Bank Info:ID:%d arrive at the%d minute.\",id,Time);break;case 2:sprintf(t_message,\"Bank Info:ID:%d leave at the%d minute.\",id,Time);break;}UI_CleanText(hout,4,WIDTH/2+1,WIDTH-1-1);UI_DrawText(hout,F_GREEN,t_message,strlen(t_message),4,WIDTH/2+1,WIDTH-1-1);}void ShowQueueText(){//绘制队列文本 User usr;UI_CleanTextRect(hout,9,ScreenHeight-1-1,0+1,WIDTH/2-1-1);UI_CleanTextRect(hout,9,ScreenHeight-1-1,WIDTH/2+1,WIDTH-1-1);int l=QueueLength(q1),i;if(l>ScreenHeight-10){//超出缓冲区高度，重绘 UI_SetConsoleScreenBufferSize(hout,WIDTH,++ScreenHeight);ShowBox();ShowBankandTimeText();}for(i=1;i<=l;i++){//输出队列1 PeekQueueByPos(&q1,i,&usr);char t_q1c[80];sprintf(t_q1c,\"ID:%-3d(AMOUNT:%-6d ARRTIME:%-4d DURTIME:%-3d)\",usr.id,usr.amount,usr.arrtime,usr.durtime);UI_DrawText(hout,F_ORANGE,t_q1c,strlen(t_q1c),9+i-1,0+1,WIDTH/2-1-1);}l=QueueLength(q2);if(l>ScreenHeight-10){//超出缓冲区高度，重绘 UI_SetConsoleScreenBufferSize(hout,WIDTH,++ScreenHeight);ShowBox();ShowBankandTimeText();}for(i=1;i<=l;i++){//输出队列2 PeekQueueByPos(&q2,i,&usr);char t_q2c[80];sprintf(t_q2c,\"ID:%-3d(AMOUNT:%-6d ARRTIME:%-4d DURTIME:%-3d)\",usr.id,usr.amount,usr.arrtime,usr.durtime);UI_DrawText(hout,F_BLUE,t_q2c,strlen(t_q2c),9+i-1,WIDTH/2+1,WIDTH-1-1);}}int Random(int low,int high){//随机数 return(low+rand()%(high-low+1));}void RandNextCustomer(){//生成下一个客户到来事件 int nexttime=Time+Random(NextCustomTime_LowerBound,NextCustomTime_UpperBound);if(nexttime<CloseTime){Event*ev_arr=MakeEventNode(nexttime,ARR);InsertEventToListInOrder(el,ev_arr);//加入下一个客户到来事件}}void Init(){//初始化 UI_InitSTDHandle(&hout,&binfo,WIDTH,HEIGHT);srand((unsigned int)time(NULL));//置随机数种子 InitEventList(&el);InitQueue(&q1);InitQueue(&q2);Event*ev_cl=MakeEventNode(CloseTime,CLOSE);InsertEventToListInOrder(el,ev_cl);//加入营业结束事件 RandNextCustomer();//第一个客户}Status ServeNextCustomerInQueue1(SqQueue*q_point){//服务队列1的下一个客户，如果不满足，则继续寻找下一个//!!!此处传入q的地址是为了该函数内部使用了DeQueue，需要改变q if(QueueLength(*q_point)){//队列不为空 DeQueue(q_point,&servingusr);//取队头 if(servingusr.amount<0&&-servingusr.amount>BankMoney){//是取款但银行满足不了，加入队2 EnQueue(&q2,servingusr);return ServeNextCustomerInQueue1(q_point);//往后寻找}Event*ev_leave=MakeEventNode(Time+servingusr.durtime,LEAVE);InsertEventToListInOrder(el,ev_leave);//加入该客户离开事件}else{servingusr.id=0;//表示当前没有客户正在服务}return OK;}Status ServeNextCustomerInQueue2(SqQueue*q_point){//服务队列2的下一个客户 if(QueueLength(*q_point)){DeQueue(q_point,&servingusr);Event*ev_leave=MakeEventNode(Time+servingusr.durtime,LEAVE);InsertEventToListInOrder(el,ev_leave);//加入该客户离开事件}else{servingusr.id=0;//表示当前没有客户正在服务}return OK;}Status Check(){//检查队列2 if(BankMoney<=moneybeforecheck){checking=0;return FALSE;}int l=QueueLength(q2),k=0;while(k<l){//尚未将队列2中的所有客户检查一遍 User usr;PeekQueue(&q2,&usr);if(-usr.amount>BankMoney){//银行的钱不能满足该客户 k++;DeQueue(&q2,&usr);EnQueue(&q2,usr);//加入队尾}else{checking=1;ServeNextCustomerInQueue2(&q2);return FALSE;}}//此时队列2已遍历一遍，无满足要求者 checking=0;return FALSE;}int main(){system(\"color 0B\");printf(\"Input the\\n<BankMoney> <CloseTime>\\n<NextCustomTime_LowerBound> <NextCustomTime_UpperBound>\\n\");printf(\"<CustomDurTime_LowerBound> <CustomDurTime_UpperBound>\\n<CustomAmount_LowerBound> <CustomAmount_UpperBound>:\\n\");//让用户输入起始参数 scanf(\"%d%d%d%d%d%d%d%d\",&BankMoney,&CloseTime,&NextCustomTime_LowerBound,&NextCustomTime_UpperBound,\\&CustomDurTime_LowerBound,&CustomDurTime_UpperBound,&CustomAmount_LowerBound,&CustomAmount_UpperBound);Init();MORE=1;ShowBox();while(MORE){Event ev;DeleteEventFromListByPos(el,1,&ev);while(Time<ev.occurtime){//当前时间未到该时间发生的时间，则时间递增，体现时间连续性 Time++;ShowBankandTimeText();ShowMessageText1();ShowQueueText();//更新各个文本 Sleep(200);//延迟200ms}User usr;switch(ev.type){case ARR://到来事件 usr.id=++CustomNum;usr.arrtime=ev.occurtime;usr.durtime=Random(CustomDurTime_LowerBound,CustomDurTime_UpperBound);usr.amount=(Random(0,1)==0?1:-1)*Random(CustomAmount_LowerBound,CustomAmount_UpperBound);EnQueue(&q1,usr);ShowMessageText2(usr.id,1);RandNextCustomer();//随机生成下一个客户到来事件 if(servingusr.id==0)//当前没有客户正在办理，则办理下一个//该情况出现在第一个客户或者之前队列以空但下一个客户未到来 ServeNextCustomerInQueue1(&q1);break;case LEAVE://离开事件 ShowMessageText2(servingusr.id,2);TotalTime+=ev.occurtime-servingusr.arrtime+1;BankMoney+=servingusr.amount;if(servingusr.amount>0){//该客户是第二种业务（存款） moneybeforecheck=BankMoney-servingusr.amount;Check();//检查队列2}else if(servingusr.amount<0||checking){//该客户是第一种业务（取款）但来自队列2 Check();//继续检查}if(!checking)ServeNextCustomerInQueue1(&q1);//不是正在检查队列2，则处理队列1下一个客户的办理 break;case CLOSE://结束事件 MORE=0;while(QueueLength(q1)){//所有客户离开 DeQueue(&q1,&usr);TotalTime+=Time-usr.arrtime;}while(QueueLength(q2)){DeQueue(&q2,&usr);TotalTime+=Time-usr.arrtime;}continue;}Sleep(1000);//每个是事件延迟1s以便观看}ScreenHeight+=3;UI_SetConsoleScreenBufferSize(hout,WIDTH,ScreenHeight);UI_DrawBox(hout,1,UI_SetRect(0,ScreenHeight-1-2,WIDTH-1,ScreenHeight-1),F_RED);char t_awt[50];if(CustomNum)sprintf(t_awt,\"Average stay time:%d\",TotalTime/CustomNum);else sprintf(t_awt,\"No Customer\");UI_DrawText(hout,F_RED,t_awt,strlen(t_awt),ScreenHeight-1-1,1,WIDTH-1);MessageBox(NULL,t_awt,\"Close\",MB_OK|MB_ICONINFORMATION);//输出平均停留时间 ScreenHeight+=1;UI_SetConsoleScreenBufferSize(hout,WIDTH,ScreenHeight);COORD curpos;curpos.X=0;curpos.Y=ScreenHeight-1;SetConsoleCursorPosition(hout,curpos);return 0;}```","tags":["DS"],"categories":[]},{"title":"数据结构上机题1 一元稀疏多项式计算","url":"/s/p/9amao0/","content":"#一元稀疏多项式计算##题目 参考习题集81页1.5题一元稀疏多项式计算-要求:-禁止使用STL库。自己练习链表操作并实现。必须用链表。打钩区分成绩。最多三个√，以半个√为一档表明该项完成程度。检查结束后需要提交源代码。源代码发送到qiweizhen1997@163.com。标注清楚姓名和学号。需不需要写实验报告看今年教务处要求。先别写。-基础要求：-最简单的输入输出:(一个√)1.输入并创建多项式(升序or降序，系数浮点型，指数整型)2.输出多项式，项数+每项系数指数(升序or降序)3.多项式相加(结果要输出)4.多项式相减(结果要输出)-拓展： 1.多项式乘法(一个√)2.计算多项式在x处的值 3.多项式整理，支持乱序输入(2，3项共一个√)-其他可选:4.除法 5.友好的gui仿真界面 6.句法分析-其余扩展自选-由助教根据复杂度和完成度判断是否一个√-注意事项： 1.系数不允许出现0 2.基本要求可以用最简单的输入方法 3.检查过程中或者核对源代码时发现相似度非常高的代码，2人雷同分数除以2，3人除3 <!--more-->##测试截图 ![](lab1_Polynome/1.png)![](lab1_Polynome/2.png)![](lab1_Polynome/3.png)##代码 ```C/*Last Update time:2017-10-08 Version：1.2 Author：LinXiang(PB16020923)Description： Polynome.*/#include <stdio.h>#include <stdlib.h>#include <math.h>#include <string.h>#define OK 1#define ERROR 0 typedef int Status;typedef struct TermOfPolynome{double c;//Coefficient int e;//Exponent struct TermOfPolynome*next;}term;typedef term*poly;typedef struct PolynomeNode{poly thepoly;struct PolynomeNode*next;}polynode;int Menu_Selected=0,NumOfPoly=0;polynode*list;//存放多个多项式的链表 char opt[5]={'\\0','+','-','*','/'};//==================system===================void ShowMenu(){system(\"cls\");//printf(\"0-退出\\n1-添加多项式\\n2-管理多项式\\n3-计算\\n4-求值\\n\");system(\"color 0B\");printf(\"┏━━━━━━━━━━━━━━━━━━━━━━━┓\\n\");printf(\"┃ 多项式运算器V1.1 ┃\\n\");printf(\"┣━━━━━━━┳━━━━━━━┳━━━━━━━┫\\n\");printf(\"┃ 0----退出 ┃ 1-添加多项式 ┃ 2-管理多项式 ┃\\n\");printf(\"┣━━━━━━━╋━━━━━━━╋━━━━━━━┫\\n\");printf(\"┃ 3----计算 ┃ 4----求值 ┃ 5----求导 ┃\\n\");printf(\"┣━━━━━━━┻━━━━━━━┻━━━━━━━┫\\n\");printf(\"┃ 6-关于 ┃\\n\");printf(\"┗━━━━━━━━━━━━━━━━━━━━━━━┛\\n\");}void SendMessage(char*p){system(\"cls\");int l=strlen(p),i;if(l/2*2!=l)l++;//使l能被2整除 printf(\"┏━\");for(i=0;i<l/2;i++){if(i==l/4-1)printf(\"信\");else if(i==l/4)printf(\"息\");else printf(\"━\");}printf(\"━┓\\n┃ \");printf(p);if(strlen(p)!=l)printf(\" \");//不是2的倍数长度则补空格 printf(\" ┃\\n┗━\");for(i=0;i<l/2;i++)printf(\"━\");printf(\"━┛\\n\");system(\"pause\");}void PrintTitle(char*s){printf(\"┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\\n\");printf(\"┃%s ┃\\n\",s);printf(\"┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\\n\");}void BackSpace(int n){//删除n个字符 int i;for(i=0;i<n;i++)printf(\"\\b\");for(i=0;i<n;i++)printf(\" \");for(i=0;i<n;i++)printf(\"\\b\");}int GetZeroNum(char*p){//计算浮点数末尾有几个0 char*q=p;int count=0;while(*q++!='.');while(*q){if(*q++=='0')count++;else count=0;}return count;}void ShowPoly(poly pl){if(pl->next==NULL)printf(\"0\\n\");else{term*q=pl->next;while(q!=NULL){char s[100];sprintf(s,\"%6lf\",q->c);//临时打印出系数 int zn=GetZeroNum(s);char text[10]=\"%s%.6lf\";//格式文本 text[4]=6-zn+'0';//修改该显示的小数位数，删尾0 printf(text,q->c<0?\"\\b\":\"\",q->c);//系数小于0,删'+' if(q->e){//指数不为0 printf(\"%sX^%s%d%s\",fabs(fabs(q->c)-1)<1e-6?\"\\b\\b\":\"\"\\,q->e<0?\"(\":\"\",q->e,q->e<0?\")\":\"\");}if(q->e==1)BackSpace(2);//删除\"^1\" printf(\"+\");q=q->next;}printf(\"\\b\\n\");}}void ShowAllPoly(polynode*list){int i;polynode*p=list->next;printf(\"==================================多项式列表==================================\\n\");for(i=0;i<NumOfPoly;i++,p=p->next){printf(\"(%d)\",i+1);ShowPoly(p->thepoly);}printf(\"====================================共%2d个====================================\\n\",NumOfPoly);}//======================term=====================term*MakeTerm(double c,int e){//创建一个项 term*p=(term*)malloc(sizeof(term));p->c=c;p->e=e;p->next=NULL;return p;}Status DeleteTermFromPolyByExponent(poly pl,int e){term*q=pl;while(q->next!=NULL&&q->next->e!=e){q=q->next;}if(q->next==NULL)return ERROR;else{term*r=q->next;q->next=q->next->next;free(r);}return OK;}Status InsertTermToPolyInOrder(poly pl,term*t){//插入后该项将成为多项式的一部分或被销毁 term*q=pl;while(q->next!=NULL&&q->next->e>t->e){q=q->next;}if(q->next==NULL){q->next=t;t->next=NULL;}else if(q->next->e==t->e){q->next->c+=t->c;free(t);if(fabs(q->next->c)<1e-6)DeleteTermFromPolyByExponent(pl,q->next->e);}else{t->next=q->next;q->next=t;}return OK;}//======================poly=====================Status InitPoly(poly*pl){//这里传进指针的指针，是为了修改pl的值*pl=MakeTerm(0,0);return OK;}Status DestoryPoly(poly*pl){term*q=*pl,*s;while(q!=NULL){s=q->next;free(q);q=s;}*pl=NULL;return OK;}Status AddPolyToList(polynode*list,poly pl){//把一个多项式加入到全局的列表里 polynode*p=list;while(p->next!=NULL)p=p->next;p->next=(polynode*)malloc(sizeof(polynode));p=p->next;p->thepoly=pl;p->next=NULL;NumOfPoly++;}Status DeletePolyFromListById(polynode*list,int id){polynode*p=list;int i=1;while(p->next!=NULL&&i++<id)p=p->next;//找到要删除的前一个 if(p->next==NULL)return ERROR;polynode*q=p->next;p->next=p->next->next;DestoryPoly(&(q->thepoly));free(q);NumOfPoly--;return OK;}poly LocatePolyById(polynode*list,int id){polynode*p=list->next;int i=1;while(p!=NULL&&i++<id)p=p->next;return p->thepoly;}//======================calculate=====================poly Add(poly pl1,poly pl2){poly pl;InitPoly(&pl);term*q1=pl1->next,*q2=pl2->next,*q=pl;while(q1!=NULL&&q2!=NULL){if(q1->e>q2->e){q->next=MakeTerm(q1->c,q1->e);q1=q1->next;}else if(q1->e<q2->e){q->next=MakeTerm(q2->c,q2->e);q2=q2->next;}else{if(fabs(q1->c+q2->c)>1e-6)q->next=MakeTerm(q1->c+q2->c,q1->e);//不被抵消才加入 q1=q1->next;q2=q2->next;}if(q->next!=NULL)q=q->next;//如果已经创建了下一项才后移}while(q1!=NULL){q->next=MakeTerm(q1->c,q1->e);q1=q1->next;q=q->next;}while(q2!=NULL){q->next=MakeTerm(q2->c,q2->e);q2=q2->next;q=q->next;}return pl;}poly Subtract(poly pl1,poly pl2){poly pl;InitPoly(&pl);term*q1=pl1->next,*q2=pl2->next,*q=pl;while(q1!=NULL){term*tq1=MakeTerm(q1->c,q1->e);InsertTermToPolyInOrder(pl,tq1);q1=q1->next;}while(q2!=NULL){term*tq2=MakeTerm(-q2->c,q2->e);InsertTermToPolyInOrder(pl,tq2);q2=q2->next;}return pl;}poly Multiply(poly pl1,poly pl2){poly pl;InitPoly(&pl);term*q1=pl1->next,*q2=pl2->next,*q=pl;while(q1!=NULL){while(q2!=NULL){term*tq=MakeTerm(q1->c*q2->c,q1->e+q2->e);InsertTermToPolyInOrder(pl,tq);q2=q2->next;}q1=q1->next;q2=pl2->next;}return pl;}Status GetHighestE(poly pl,double*c,int*e){//取最高次的次数和系数 term*q=pl;if(q->next==NULL){*c=0;*e=0;return OK;}q=q->next;*c=q->c;*e=q->e;return OK;}Status CopyPoly(poly*pl1,poly*pl2){//2to1 InitPoly(pl1);term*q2=(*pl2)->next,*q1=*pl1;while(q2!=NULL){q1->next=MakeTerm(q2->c,q2->e);q2=q2->next;q1=q1->next;}return OK;}Status Divide(poly pl1,poly pl2,poly*res,poly*left){//res,left传递指向poly类型的指针 CopyPoly(left,&pl1);poly xnpl;InitPoly(&xnpl);InitPoly(res);int de,e1,e2;double c1,c2;GetHighestE(pl2,&c2,&e2);GetHighestE(*left,&c1,&e1);de=e1-e2;while(de>=0&&(*left)->next!=NULL){//余数与除数最高次之差大于0 且余式不为0 term*xn=MakeTerm(c1/c2,de);xnpl->next=xn;poly tmp=Multiply(pl2,xnpl);poly tmpleft=Subtract(*left,tmp);DestoryPoly(left);CopyPoly(left,&tmpleft);DestoryPoly(&tmpleft);InsertTermToPolyInOrder(*res,xn);GetHighestE(*left,&c1,&e1);de=e1-e2;}return OK;}poly Calculate(poly pl1,poly pl2,int op){switch(op){case 1:return Add(pl1,pl2);case 2:return Subtract(pl1,pl2);case 3:return Multiply(pl1,pl2);}}double Value(poly pl,double x){//求值 term*q=pl->next;double sum=0;while(q!=NULL){sum+=q->c*pow(x,q->e);q=q->next;}return sum;}poly Dfx(poly pl1){//求导 poly pl;InitPoly(&pl);term*q1=pl1->next,*q=pl;while(q1!=NULL){if(q1->e){//非常数项 q->next=MakeTerm(q1->c*q1->e,q1->e-1);q=q->next;}q1=q1->next;}return pl;}//======================menu=====================int Menu_Add(){double c;int e;system(\"cls\");PrintTitle(\"添加\");printf(\"依次输入每项的系数和指数，空格隔开，ctrl+z结束:\\n\");poly pl;InitPoly(&pl);while(scanf(\"%lf\",&c)!=EOF){if(scanf(\"%d\",&e)==EOF){DestoryPoly(&pl);return 1;}if(fabs(c)<1e-6)continue;term*t=MakeTerm(c,e);InsertTermToPolyInOrder(pl,t);}AddPolyToList(list,pl);return 0;}int Menu_Delete(){int s;system(\"cls\");PrintTitle(\"管理\");if(NumOfPoly==0)return 1;else ShowAllPoly(list);printf(\"\\n选择一个多项式删除。输入序号数字(输入0返回):\");scanf(\"%d\",&s);if(s>0){if(DeletePolyFromListById(list,s)==ERROR)return 2;else return 0;}return-1;}int Menu_Calculate(){int s1,s2,op;system(\"cls\");PrintTitle(\"计算\");if(NumOfPoly==0)return 1;else ShowAllPoly(list);printf(\"\\n选择两个多项式和一种运算符[(1)+(2)-(3)*(4)/]。\\n依次输入多项式和运算符序号(空格隔开,回车结束,输入0返回):\");scanf(\"%d\",&s1);if(s1==0)return 0;scanf(\"%d\",&s2);if(s1<0||s2<0||s1>NumOfPoly||s2>NumOfPoly)return 2;scanf(\"%d\",&op);if(op<=0||op>4)return 2;printf(\"\\n===================================运算结果===================================\\n\");poly pl1=LocatePolyById(list,s1);poly pl2=LocatePolyById(list,s2);poly pl;poly left;if(op==4){if(pl2->next==NULL)return 3;Divide(pl1,pl2,&pl,&left);}else{pl=Calculate(pl1,pl2,op);}ShowPoly(pl1);printf(\"%c\\n\",opt[op]);ShowPoly(pl2);printf(\"=\\n\");ShowPoly(pl);if(op==4){printf(\"...\\n\");ShowPoly(left);}DestoryPoly(&pl);if(op==4)DestoryPoly(&left);printf(\"==============================================================================\\n\");system(\"pause\");return-1;}int Menu_Value(){int s;double x;system(\"cls\");PrintTitle(\"求值\");if(NumOfPoly==0)return 1;else ShowAllPoly(list);printf(\"\\n选择一个多项式求值。\\n依次输入多项式序号和X值(空格隔开,回车结束,输入0返回):\");scanf(\"%d\",&s);if(s==0)return 0;if(s<0||s>NumOfPoly)return 2;scanf(\"%lf\",&x);printf(\"\\n===================================运算结果===================================\\n\");poly pl=LocatePolyById(list,s);ShowPoly(pl);printf(\"在 X=%lf 处的值为:\\n%lf\\n\",x,Value(pl,x));printf(\"==============================================================================\\n\");system(\"pause\");return-1;}int Menu_Dfx(){int s,n;system(\"cls\");PrintTitle(\"求导\");if(NumOfPoly==0)return 1;else ShowAllPoly(list);printf(\"\\n选择一个多项式求导。\\n输入多项式序号和求导次数n(空格隔开,回车结束,输入0返回):\");scanf(\"%d\",&s);if(s==0)return 0;scanf(\"%d\",&n);if(n<1||s<0||s>NumOfPoly)return 2;printf(\"\\n===================================运算结果===================================\\n\");poly pl=LocatePolyById(list,s);printf(\"F(X)=\");ShowPoly(pl);int i;poly tmp1,tmp2;CopyPoly(&tmp2,&pl);for(i=1;i<=n;i++){printf(\"F(X)^(%d)=\",i);tmp1=Dfx(tmp2);DestoryPoly(&tmp2);CopyPoly(&tmp2,&tmp1);DestoryPoly(&tmp1);ShowPoly(tmp2);}DestoryPoly(&tmp2);printf(\"==============================================================================\\n\");system(\"pause\");return-1;}int About(){system(\"cls\");printf(\"┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\\n\");printf(\"┃ About ┃\\n\");printf(\"┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫\\n\");printf(\"┃ PolynomeCalculator V1.1 ┃\\n\");printf(\"┃ Made by LX 2017.10.06 ┃\\n\");printf(\"┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\\n\");system(\"pause\");return 0;}int main(){list=(polynode*)malloc(sizeof(polynode));list->next=NULL;ShowMenu();printf(\"请选择：\");//printf(\"abcdefg\\b\\b\\b12\");scanf(\"%d\",&Menu_Selected);while(Menu_Selected){int status;switch(Menu_Selected){case 1:if(Menu_Add()==1)SendMessage(\"输入有误!系数个数与指数个数不匹配！\");else{SendMessage(\"添加成功！\");}break;case 2:status=Menu_Delete();if(status==1)SendMessage(\"这里空空如也...\");else if(status==2){SendMessage(\"输入的序号有误！\");}else if(status==0){SendMessage(\"删除成功\");}break;case 3:status=Menu_Calculate();if(status==1){SendMessage(\"你需要先添加多项式~\");}else if(status==2){SendMessage(\"输入的序号有误！\");}else if(status==3){SendMessage(\"0不能为除数！\");}break;case 4:status=Menu_Value();if(status==1){SendMessage(\"你需要先添加多项式~\");}else if(status==2){SendMessage(\"输入的序号和X值有误！\");}break;case 5:status=Menu_Dfx();if(status==1){SendMessage(\"你需要先添加多项式~\");}else if(status==2){SendMessage(\"输入的序号和n值有误！\");}break;case 6:About();break;}ShowMenu();printf(\"请选择：\");scanf(\"%d\",&Menu_Selected);}return 0;}```","tags":["DS"],"categories":[]},{"title":"程序设计II上机实验10B：\"完美阴阳矩阵\"","url":"/s/p/95f9c0/","content":"#\"完美阴阳矩阵\"####Time limit:1000 ms####Memory limit:256 MB####Standard I/O##Content $定义元素全为0或1的矩阵为“阴阳矩阵”，即一个n行m列的矩阵A为“阴阳矩阵”当且仅当：$ $\\forall i\\forall j(A_{ij}\\in{0,1})(1≤i≤n,1≤j≤m)$ $对于一个n行m列的矩阵A和一个n'行m'列(1≤n'≤n,1≤m'≤m)的矩阵A'，称A'为A的子矩阵当且仅当：$ $\\exists i_0\\exists j_0\\forall i\\forall j(A_{i_0+i,j_0+j}=A'_{ij}(1≤i≤n',1≤j≤m',0≤i_0≤n−n',0≤j_0≤m−m'))$ $自然地，“阴阳矩阵”的子矩阵也是“阴阳矩阵”。$ $对一个n行m列的“阴阳矩阵”矩阵A，称它为“完美阴阳矩阵”当且仅当以下两个条件都成立：$ $1.\\forall i\\forall j(A_{i,j}≠A_{i,j+1})(1≤i≤n,1≤j≤m−1)$ $2.\\forall i\\forall j(A_{i,j}≠A_{i+1,j})(1≤i≤n−1,1≤j≤m)$ $显然，一个n行m列的矩阵的元素个数为n×m.现给定一个n行m列的“阴阳矩阵”A，$ $1.求“阴阳矩阵”A的子方阵（行与列数目相同的子矩阵）中元素最多的“完美阴阳方阵”，输出该子方阵的元素数目。$ $2.求“阴阳矩阵”A的子矩阵中元素最多的“完美阴阳矩阵”，输出该子矩阵的元素数目。$##Input Description 输入的第一行是两个空格隔开的整数n和m，分别表示矩阵的长和宽。接下来的n行，每行m个数，空格隔开，表示一个n×m的阴阳矩阵。##Output Description 两行，每行一个数，表示所求答案。 <!--more-->##Sample###INPUT 3 3 1 0 1 0 1 0 1 0 0###OUTPUT 4 6##Hint >对于20%20%的数据，n,m≤80n,m≤80 > >对于40%40%的数据，n,m≤400n,m≤400 > >对于100%100%的数据，n,m≤2000n,m≤2000（各种暴力方法都会超时哦）##Code ```C#include <stdio.h>#include <stdlib.h> typedef struct intervaldata{int begin;int end;struct intervaldata*next;}Interval;//区间 Interval**allhead;int m,n;int MaxSquareLen,MaxRectArea;//最大方阵的边长，最大矩阵的面积()int max(int a,int b){return a>b?a:b;}int min(int a,int b){return a<b?a:b;}Interval*MakeNode(int begin,int end){Interval*p=(Interval*)malloc(sizeof(Interval));p->begin=begin;p->end=end;p->next=NULL;return p;}void UpdateMaxRectArea(int weith,int depth){//更新矩阵最大值,注意到阴阳矩阵应该比普通矩阵长宽各+1 MaxRectArea=max(MaxRectArea,(weith+1)*(depth+1));MaxSquareLen=max(MaxSquareLen,min(weith,depth)+1);}int Search(int row,int left,int right,int depth){//row是当前行//depth表示当前矩形纵深高度(占的行数，不包括当前行)//left,right是上一行传递下来的区间范围 if(row>=m-1){//超出地图了，地图最后一行是m-2（全地图化为普通矩阵后共m-1行）;UpdateMaxRectArea(right-left+1,depth);return 1;}Interval*p=allhead[row]->next;int tmpleft,tmpright;while(p!=NULL){if(p->end<left){p=p->next;continue;}if(p->begin>right)break;tmpleft=max(left,p->begin);tmpright=min(right,p->end);Search(row+1,tmpleft,tmpright,depth+1);p=p->next;}//结算 UpdateMaxRectArea(right-left+1,depth);return 1;}int main(){int i,j;scanf(\"%d%d\",&m,&n);int**map=(int**)malloc(sizeof(int*)*m);for(i=0;i<m;i++){map[i]=(int*)malloc(sizeof(int)*n);for(j=0;j<n;j++){scanf(\"%d\",&map[i][j]);}}allhead=(Interval**)malloc(sizeof(Interval*)*(m-1));//每一行的头结点指针 for(i=0;i<m-1;i++){//化为普通0/1矩阵，同时求出每行的值为1区间存在链表里,问题化为求解最大1矩阵面积 int start=-1;allhead[i]=MakeNode(0,0);//头结点不用 Interval*now=allhead[i];for(j=0;j<n-1;j++){if(map[i][j+1]==!map[i][j]&&map[i+1][j]==!map[i][j]&&map[i+1][j+1]==map[i][j]){map[i][j]=1;if(start==-1)start=j;}else{map[i][j]=0;if(start!=-1){Interval*p=MakeNode(start,j-1);now->next=p;now=p;start=-1;}}}if(start!=-1){Interval*p=MakeNode(start,j-1);now->next=p;}}for(i=0;i<m-1;i++){//遍历每一行的区间 Interval*p=allhead[i]->next;while(p!=NULL){Search(i+1,p->begin,p->end,1);p=p->next;}}printf(\"%d\\n%d\",MaxSquareLen*MaxSquareLen,MaxRectArea);for(i=0;i<m;i++){free(map[i]);}free(map);for(i=0;i<m-1;i++){Interval*p=allhead[i];while(p!=NULL){allhead[i]=p->next;free(p);p=allhead[i];}}return 0;}```","tags":["C"],"categories":[]},{"title":"程序设计II上机实验10A：杀蚂蚁","url":"/s/p/95deo0/","content":"##杀蚂蚁####Time limit:3000 ms####Memory limit:256 MB####Standard I/O##Content 最近，佳佳迷上了一款好玩的小游戏：antbuster。 游戏规则非常简单：在一张地图上，左上角是蚂蚁窝，右下角是蛋糕，蚂蚁会源源不断地从窝里爬出来，试图把蛋糕搬回蚂蚁窝。而你的任务，就是用原始资金以及杀蚂蚁获得的奖金造防御塔，杀掉这些试图跟你抢蛋糕的蚂蚁~ 下附一张游戏截图： ![](lab10a/contest_17_B.jpg)-为了拿到尽可能高的分数，佳佳设计了很多种造塔的方案，但在尝试了其中的一小部分后，佳佳发现，这个游戏实在是太费时间了。为了节省时间，佳佳决定写个程序，对于每一种方案，模拟游戏进程，根据效果来判断方案的优劣。-根据自己在游戏中积累的一些经验，以及上网搜到的一些参数，佳佳猜了蚂蚁爬行的算法，并且假设游戏中的蚂蚁也是按这个规则选择路线： 1.每一秒钟开始的时候，蚂蚁都在平面中的某个整点上。如果蚂蚁没有扛着蛋糕，它会在该点留下2单位的信息素，否则它会留下5单位的信息素。然后蚂蚁会在正北、正南、正东、正西四个方向中选择一个爬过去。 2.选择方向的规则是：首先，爬完一个单位长度后到达的那个点上，不能有其他蚂蚁或是防御塔，并且那个点不能是蚂蚁上一秒所在的点（除非上一个时刻蚂蚁就被卡住，且这个时刻它仍无法动），当然，蚂蚁也不会爬出地图的边界（我们定义这些点为不可达点）。如果此时有多个选择，蚂蚁会选择信息素最多的那个点爬过去。 3.如果此时仍有多种选择，蚂蚁先面向正东，如果正东不是可选择的某个方向，它会顺时针转90°，再次判断，如果还不是，再转90°...直到找到可以去的方向。 4.如果将每只蚂蚁在洞口出现的时间作为它的活动时间的第1秒，那么每当这只蚂蚁的活动时间秒数为5的倍数的时候，它先按规则1~3确定一个方向，面对该方向后逆时针转90°，若它沿当前方向会走到一个不可达点，它会不停地每次逆时针转90°，直到它面对着一个可达的点，这样定下的方向才是蚂蚁最终要爬去的方向。 5.如果蚂蚁的四周都是不可达点，那么蚂蚁在这一秒内会选择停留在当前点。下一秒判断移动方向时，它上一秒所在点为其当前停留的点。 6.你可以认为蚂蚁在选定方向后，瞬间移动到它的目标点，这一秒钟剩下的时间里，它就停留在目标点。 7.蚂蚁按出生的顺序移动，出生得比较早的蚂蚁先移动。-然后，是一些有关地图的信息： 1.每一秒，地图所有点上的信息素会损失1单位，如果那个点上有信息素的话。 2.地图上某些地方是炮台。炮台的坐标在输入中给出。 3.地图的长、宽在输入中给出，对于n*m的地图，它的左上角坐标为（0，0），右下角坐标为（n，m）。蚂蚁洞的位置为（0，0），蛋糕的位置为（n，m）。 4.你可以把蚂蚁看做一个直径为1单位的圆，圆心位于蚂蚁所在的整点。 5.游戏开始时，地图上没有蚂蚁，每个点上的信息素含量均为0。-一些有关炮塔的信息： 1.炮塔被放置在地图上的整点处。 2.为了简单一些，我们认为这些炮塔都是激光塔。激光塔的射速是1秒/次，它的攻击伤害为d/次，攻击范围为r。你可以认为每秒蚂蚁移动完毕后，塔才开始攻击。并且，只有当代表蚂蚁的圆的圆心与塔的直线距离不超过r时，塔才算打得到那只蚂蚁。 3.如果一只蚂蚁扛着蛋糕，那么它会成为target，也就是说，任何打得到它的塔的炮口都会对准它。如果蛋糕好好地呆在原位，那么每个塔都会挑离它最近的蚂蚁进行攻击，如果有多只蚂蚁，它会选出生较早的一只。 4.激光塔有个比较奇怪的特性：它在选定了打击目标后，只要目标在其射程内，塔到目标蚂蚁圆心的连线上的所有蚂蚁（这里“被打到”的判定变成了表示激光的线段与表示蚂蚁的圆有公共点）都会被打到并损d格血，但激光不会穿透它的打击目标打到后面的蚂蚁。 5.尽管在真实游戏中，塔是可以升级的，但在这里我们认为塔的布局和等级就此定了下来，不再变动。 <!--more-->-再介绍一下蚂蚁窝： 1.如果地图上的蚂蚁不足6只，并且洞口没有蚂蚁，那么窝中每秒会爬出一只蚂蚁，直到地图上的蚂蚁数为6只。 2.刚出生的蚂蚁站在洞口。 3.每只蚂蚁有一个级别，级别决定了蚂蚁的血量，级别为k的蚂蚁的血量为int(4*1.1^k)（int(x)表示对x取下整）。每被塔打一次，蚂蚁的血减少d。注意，血量为0的蚂蚁仍能精力充沛地四处乱爬，只有一只蚂蚁的血被打成负数时，它才算挂了。 4.蚂蚁的级别是这样算的：前6只出生的蚂蚁是1级，第7~12只是2级，依此类推。-最后给出关于蛋糕的介绍： 1.简单起见，你可以认为此时只剩最后一块蛋糕了。如果有蚂蚁走到蛋糕的位置，并且此时蛋糕没有被扛走，那么这只蚂蚁就扛上了蛋糕。蚂蚁被打死后蛋糕归位。 2.如果一只扛着蛋糕的蚂蚁走到蚂蚁窝的位置，我们就认为蚂蚁成功抢到了蛋糕，游戏结束。 3.蚂蚁扛上蛋糕时，血量会增加int（该蚂蚁出生时血量/2），但不会超过上限。-整理一下1秒钟内发生的事件：-1秒的最初，如果地图上蚂蚁数不足6，一只蚂蚁就会在洞口出生。-接着，蚂蚁们在自己所在点留下一些信息素后，考虑移动。先出生的蚂蚁先移动。-移动完毕后，如果有蚂蚁在蛋糕的位置上并且蛋糕没被拿走，它把蛋糕扛上，血量增加，并在这时被所有塔设成target。-然后所有塔同时开始攻击。如果攻击结束后那只扛着蛋糕的蚂蚁挂了，蛋糕瞬间归位。-攻击结束后，如果发现扛蛋糕的蚂蚁没死并在窝的位置，就认为蚂蚁抢到了蛋糕。游戏也在此时结束。-最后，地图上所有点的信息素损失1单位。所有蚂蚁的年龄加1。-漫长的1秒到此结束。##Input Description 输入的第一行是2个用空格隔开的整数，n、m，分别表示了地图的长和宽。 第二行是3个用空格隔开的整数，s、d、r，依次表示炮塔的个数、单次攻击伤害以及攻击范围。 接下来s行，每行是2个用空格隔开的整数x、y，描述了一个炮塔的位置。当然，蚂蚁窝的洞口以及蛋糕所在的位置上一定没有炮塔。 最后一行是一个正整数t，表示我们模拟游戏的前t秒钟。##Output Description 如果在第t秒或之前蚂蚁抢到了蛋糕，输出一行“Game over after x seconds”，其中x为游戏结束的时间，否则输出“The game is going on”。 如果游戏在t秒或之前结束，输出游戏结束时所有蚂蚁的信息，否则输出t秒后所有蚂蚁的信息。格式如下： 第一行是1个整数s，表示此时活着的蚂蚁的总数。 接下来s行，每行5个整数，依次表示一只蚂蚁的年龄（单位为秒）、等级、当前血量，以及在地图上的位置（a，b）。输出按蚂蚁的年龄递减排序。##Sample###INPUT 3 5 1 1 2 2 2 5###OUTPUT The game is going on 5 5 1 3 1 4 4 1 3 0 4 3 1 3 0 3 2 1 3 0 2 1 1 4 0 1##Hint###样例说明： >3*5的地图，有1个单次伤害为1、攻击范围为2的激光炮塔，它的位置为（2，2），模拟游戏的前5秒。5秒内有5只蚂蚁出生，都是向东爬行，其中第1~4只在路过（0，2）点时被激光塔伤了1格血。在第5秒的时候，最早出生的蚂蚁按移动规则1~3本来该向东移动，但由于规则4的作用，它在发现向北和向西移动都会到达不可达点后，最终选择了向南移动。###数据说明： >100%的数据满足1 ≤ n,m ≤ 8，s ≤ 20，t ≤ 200,000##Code ```c#include <stdio.h>#include <stdlib.h>#include <string.h>#include <math.h>#define CANNON 1#define ANT 2//#define DEBUG 0 struct antdata{int age;int id;//蚂蚁的id，从1开始不重复，往上递增，为0表示不存在 int rank;//等级 int health;//血量 int x,y;int lastx,lasty;int cake;//0或1，是否有蛋糕}ant[6]={};struct cannondata{int x,y;};int time=0;int cake=-1;//记录蛋糕在哪只蚂蚁身上0-5 int antid=0;//记录蚂蚁出生的顺序 int antnum=0;//记录当前场上的蚂蚁数量 int**map,**info;//记录地图上的蚂蚁/炮台，信息素 int n,m;int cnum,churt,cdistance;//炮台cannon数,炮台伤害，炮台攻击范围 struct cannondata*cannon;int direction[4][2]={{0,1},{1,0},{0,-1},{-1,0}};//右下左上(东南西北，顺时针)int directionavailable[4]={};//记录可前进的方向 void initialize(){int i,j;for(i=0;i<=n;i++)for(j=0;j<=m;j++){info[i][j]=0;map[i][j]=0;}}void MakeAnt(){//不满6只则生成蚂蚁 int i;if(antnum<6&&map[0][0]==0){//for(i=0;i<6;i++)i=antnum;//if(ant[i].id==0){antid++;ant[i].id=antid;ant[i].x=0;ant[i].y=0;ant[i].lastx=0;ant[i].lasty=0;ant[i].age=0;ant[i].rank=(antid-1)/6+1;ant[i].health=floor(4*pow(1.1,ant[i].rank));ant[i].cake=0;//}antnum++;map[0][0]=ANT+ant[i].id;}}void DeleteAnt(int i){//i为0-5 int j;for(j=i+1;j<antnum;j++){//后面的前移 ant[j-1]=ant[j];}antnum--;for(j=antnum;j<6;j++){//置零表示不存在 ant[j].id=0;}}void GiveInfo(){//增加信息素 int i;for(i=0;i<6;i++)if(ant[i].id!=0)if(ant[i].cake)info[ant[i].x][ant[i].y]+=5;else info[ant[i].x][ant[i].y]+=2;}void LostInfo(){//失去信息素 int i,j;for(i=0;i<=n;i++)for(j=0;j<=m;j++)if(info[i][j])info[i][j]--;}void PutAnt(int i,int x,int y){//放置蚂蚁并在地图上标记 ant[i].lastx=ant[i].x;ant[i].lasty=ant[i].y;map[ant[i].x][ant[i].y]=0;#ifdef DEBUG printf(\"AntID:%d from(%d,%d)to(%d,%d),it's time/Rank/Health is%d/%d/%d\\n\",ant[i].id,ant[i].x,ant[i].y,x,y,ant[i].age+1,ant[i].rank,ant[i].health);#endif ant[i].x=x;ant[i].y=y;map[x][y]=ANT+ant[i].id;}int SelectDirection(int i){//返回一个方向的序号，不能移动返回-1 int j,tx,ty,anum=0,a,amaxnum=0;memset(directionavailable,0,sizeof(directionavailable));for(j=0;j<4;j++){tx=ant[i].x+direction[j][0];ty=ant[i].y+direction[j][1];if(tx==ant[i].lastx&&ty==ant[i].lasty)continue;if(tx<0||ty<0||tx>n||ty>m)continue;if(map[tx][ty])continue;directionavailable[j]=1;//置为可达 a=j;anum++;//可达的数量加1}if(anum==0)return-1;if(anum==1)return a;//此时有多个可达点 int max=-1;for(j=0;j<4;j++){if(directionavailable[j]){tx=ant[i].x+direction[j][0];ty=ant[i].y+direction[j][1];directionavailable[j]=info[tx][ty]+1;//将可达标志改为该方向前进一格的信息素+1,+1为了将信息素为0的与不可达点区分 if(directionavailable[j]>max)max=directionavailable[j];//更新最大值}}for(j=0;j<4;j++){//该循环将信息素不是最大值的置零 （后来发现题意不是如此，不是最大值的仍是可达点,不该置零，这里做特殊标记-1） if(directionavailable[j]){//是可达点 if(directionavailable[j]<max){//但不是信息素最大的 directionavailable[j]=-1;//anum--;}else{//是最大值 a=j;//记下最大值的下标,如果有多个，a将是最后一个最大值 amaxnum++;//最大值方向的数量}}}if(amaxnum!=1){//有多个最大值 a=0;//东 while(directionavailable[a]<=0){//该方向不是最大值的方向(-1)，或不可达(0)a++;//顺时针转90度}}//在多个可达点时才考虑年龄为5的倍数的情况，因为只有1个方向可达时，逆时针多次后最终仍是该方向 if((ant[i].age+1)%5==0){do{a--;//逆时针转90度 if(a<0)a+=4;}while(directionavailable[a]==0);//该方向不可达}return a;}void Move(){int i,tx,ty,d;for(i=0;i<antnum;i++){//if(ant[i].id==0)break;//后面都是空的 d=SelectDirection(i);if(d==-1)PutAnt(i,ant[i].x,ant[i].y);else{tx=ant[i].x+direction[d][0];ty=ant[i].y+direction[d][1];PutAnt(i,tx,ty);}if(ant[i].x==n&&ant[i].y==m&&cake==-1){//到达蛋糕位置 ant[i].cake=1;cake=i;ant[i].health+=floor(floor(4*pow(1.1,ant[i].rank))/2);if(ant[i].health>(int)floor(4*pow(1.1,ant[i].rank)))ant[i].health=(int)floor(4*pow(1.1,ant[i].rank));}}}int GetDistance2(int x1,int y1,int x2,int y2){//为了避免浮点数运算，这里计算距离的平方 return(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);}int VectorProduct2(int x1,int y1,int x2,int y2){//两向量矢积的平方 return(x1*y2-x2*y1)*(x1*y2-x2*y1);}int Mult(int x1,int y1,int x2,int y2){//两向量数量积 return x1*x2+y1*y2;}int IsInAttackArea(int x1,int y1,int x2,int y2,int x3,int y3){//判断以3点为圆心，半径为0.5的圆和1,2点连成的线段有无公共点（后来才注意蚂蚁的直径是1，不是半径...） int tmp,tmp2;tmp2=(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);tmp=Mult(x3-x1,y3-y1,x2-x1,y2-y1);if(tmp<0||tmp>tmp2){//printf(\"----------s1---------\\n\");return 0;}tmp=VectorProduct2(x3-x1,y3-y1,x2-x1,y2-y1);if(4*tmp>tmp2){//printf(\"----------s2---------\\n\");return 0;}return 1;}void Attack(){//所有炮塔是一起攻击的，攻击结束后才判断蚂蚁生死 int i,j;for(j=0;j<cnum;j++){int imin=-1,target=-1;int d2min=9999999,d2;if(cake!=-1&&GetDistance2(ant[cake].x,ant[cake].y,cannon[j].x,cannon[j].y)<=cdistance*cdistance){target=cake;}else{for(i=0;i<antnum;i++){//if(ant[i].id==0)break;//后面都是空的 d2=GetDistance2(ant[i].x,ant[i].y,cannon[j].x,cannon[j].y);if(d2<d2min){d2min=d2;imin=i;}}target=imin;if(GetDistance2(ant[target].x,ant[target].y,cannon[j].x,cannon[j].y)>cdistance*cdistance)continue;//最近的都打不到}ant[target].health-=churt;#ifdef DEBUG printf(\"Targer:%d,TargetAntId:%d\\n\",target,ant[target].id);#endif for(i=0;i<antnum;i++){if(i==target)continue;if(IsInAttackArea(ant[target].x,ant[target].y,cannon[j].x,cannon[j].y,ant[i].x,ant[i].y)){ant[i].health-=churt;#ifdef DEBUG printf(\"!!!!!!!!!!!!!!!!!ExtraTargetAntId:%d!!!!!!!!!!!!!!!!!!!\\n\",ant[i].id);//system(\"pause\");#endif}}}}void Judge1(){int i;for(i=0;i<antnum;i++){if(ant[i].health<0){#ifdef DEBUG printf(\"AntID:%d died.\\n\",ant[i].id);#endif map[ant[i].x][ant[i].y]=0;if(ant[i].cake)cake=-1;//蛋糕归位 else if(cake!=-1)if(cake>i)cake--;DeleteAnt(i);i--;}}}int Judge2(){if(cake!=-1)if(ant[cake].x==0&&ant[cake].y==0)return 1;return 0;}void AgeAdd(){int i;for(i=0;i<antnum;i++)ant[i].age++;}//-------------调试-----------int GetHealthById(int id){int i;for(i=0;i<antnum;i++)if(ant[i].id==id)return ant[i].health;return-1;}void PFSTATE(){int i,j;for(i=0;i<=n;i++){for(j=0;j<=m;j++){printf(\"[%3d]\",info[i][j]);if(map[i][j]==CANNON)printf(\" CANNON \");else if(map[i][j]>ANT)printf(\"%4d(%2d)\",map[i][j]-ANT,GetHealthById(map[i][j]-ANT));else printf(\"|------|\");}printf(\"\\n\");}printf(\"Cake:%d,CakeAntId:%d,ant[cake].cake:%d\\n\",cake,ant[cake].id,ant[cake].cake);printf(\"=====================time:%d=====================\\n\",time);}//---------------------------int Clock(){//返回1表示结束 time++;MakeAnt();GiveInfo();Move();Attack();Judge1();if(Judge2())return 1;AgeAdd();LostInfo();#ifdef DEBUG PFSTATE();#endif return 0;}int main(){int i,tx,ty,runtime,isend=0;scanf(\"%d%d\",&n,&m);map=(int**)malloc(sizeof(int*)*(n+1));info=(int**)malloc(sizeof(int*)*(n+1));for(i=0;i<=n;i++){map[i]=(int*)malloc(sizeof(int)*(m+1));info[i]=(int*)malloc(sizeof(int*)*(m+1));}initialize();scanf(\"%d%d%d\",&cnum,&churt,&cdistance);cannon=(struct cannondata*)malloc(cnum*sizeof(struct cannondata));for(i=0;i<cnum;i++){scanf(\"%d%d\",&tx,&ty);map[tx][ty]=CANNON;cannon[i].x=tx;cannon[i].y=ty;}scanf(\"%d\",&runtime);for(i=0;i<runtime;i++){if(Clock()){printf(\"Game over after%d seconds\\n\",time);isend=1;break;}}if(!isend)printf(\"The game is going on\\n\");printf(\"%d\\n\",antnum);for(i=0;i<antnum;i++){printf(\"%d%d%d%d%d\\n\",ant[i].age,ant[i].rank,ant[i].health,ant[i].x,ant[i].y);}return 0;}```","tags":["C"],"categories":[]},{"title":"程序设计II上机实验9B：八数码问题","url":"/s/p/95bk00/","content":"##八数码问题####Time limit:1000 ms####Memory limit:1 GB####Standard I/O##Content 3×3九宫棋盘，放置数码为1-8的8个棋牌，剩下一个空格，只能通过棋牌向空格的移动来改变棋盘的布局。要求：根据给定初始布局，问：至少移动几次才能从初始布局到达目标布局。 目标布局如下图： ![](lab9b/contest_6_A_1.bmp)##Input Description 3行，每行3个0-8的不重复整数，其中0表示空格所在的位置，数字间用空格隔开，表示初始布局，数据保证该初始布局一定能移到目标布局。##Output Description 一个整数，表示最少移动到目标布局的次数。 <!--more-->##Sample###INPUT 0 7 6 8 4 3 5 2 1###OUTPUT 4##Code ```c#include <stdio.h>#include <stdlib.h>#include <string.h> char state[362880]={};//记录是否已拓展过,用char节省空间 char end[9]={8,7,6,5,4,3,2,1,0};//目标序列 从左到右，从上到下 int endsub;//目标序列在数组中的下标 int factor[4]={-3,3,-1,1};//方向 上下左右 int fac[8]={40320,5040,720,120,24,6,2,1};//阶乘 struct node{char list[9];int step;struct node*next;};struct node*head,*rear;struct node*MakeNode(char*list,int step){struct node*p=(struct node*)malloc(sizeof(struct node));memcpy(p->list,list,9);p->step=step;p->next=NULL;return p;}int ToSub(char*list){//换算为数组下标，康托展开 int i,j,rank,sub=0;for(i=0;i < 8;i++){rank=0;for(j=i+1;j < 9;j++)if(list[j]< list[i])rank++;sub+=rank*fac[i];}return sub;}int GetSpacePos(char*list){//获取空格位置 int i;for(i=0;i<9;i++)if(list[i]==0)return i;}int Move(char*list,int f){//空格向某方向移动,返回0表示不可移动 int i=GetSpacePos(list);if(f==0&&i-3<0)return 0;//上 if(f==1&&i+3>8)return 0;//下 if(f==2&&(i+1)%3==1)return 0;//左 if(f==3&&(i+1)%3==0)return 0;//右 list[i]=list[i+factor[f]];list[i+factor[f]]=0;return 1;}int Search(){char tmp[9];struct node*p;int sub,i;while(head!=NULL){for(i=0;i<4;i++){memcpy(tmp,head->list,9);if(Move(tmp,i)){sub=ToSub(tmp);if(sub==endsub)return head->step+1;if(state[sub])continue;state[sub]=1;p=MakeNode(tmp,head->step+1);rear->next=p;rear=p;}}p=head;head=head->next;free(p);}return 0;}int main(){int i;char start[9]={};for(i=0;i<9;i++){scanf(\"%c\",&start[i]);start[i]-='0';getchar();}endsub=ToSub(end);rear=head=MakeNode(start,0);printf(\"%d\",Search());}```","tags":["C"],"categories":[]},{"title":"程序设计II上机实验9A：算24","url":"/s/p/959pc0/","content":"#算24####Time limit:1000 ms####Memory limit:256 MB####Standard I/O##Content 给出4个小于10的正整数，你可以使用加减乘除4种运算以及括号把这4个数连接起来得到一个表达式。现在的问题是，是否存在一种方式使得得到的表达式的结果等于24。 这里加减乘除以及括号的运算结果和运算的优先级跟我们平常的定义一致（这里的除法定义是实数除法）。 比如，对于5，5，5，1，我们知道5*(5 – 1/5)=24，因此可以得到24。又比如，对于1，1，4，2，我们怎么都不能得到24。##Input Description 输入数据包括多行，每行给出一组测试数据，包括4个小于10的正整数（用空格分开）。最后一组测试数据中包括4个0，表示输入的结束，这组数据不用处理。##Output Description 对于每一组测试数据，输出一行，如果可以得到24，输出“YES”；否则，输出“NO”。 <!--more-->##Sample###INPUT 5 5 5 1 1 1 4 2 0 0 0 0###OUTPUT YES NO##Code ```c#include <stdio.h>#include <math.h>#define P 10e-4#define INF 99999 int IsEqual(double a,double b){if(fabs(a-b)<=P)return 1;else return 0;}double Cal(double a,char op,double b){switch(op){case '+':return a+b;case '-':return a-b;case '*':return a*b;case '/':if(b==0)return INF;else return a/b;}}int Game24(double n[]){char op[]={'+','-','*','/'};double res[5];int i1,i2,i3,i4,j1,j2,j3,k,count=0;for(i1=0;i1<4;i1++){for(i2=0;i2<4;i2++){if(i2!=i1){for(i3=0;i3<4;i3++){if(i3!=i2&&i3!=i1){for(i4=0;i4<4;i4++){if(i4!=i3&&i4!=i2&&i4!=i1){for(j1=0;j1<4;j1++){for(j2=0;j2<4;j2++){for(j3=0;j3<4;j3++){res[0]=Cal(Cal(Cal(n[i1],op[j1],n[i2]),op[j2],n[i3]),op[j3],n[i4]);res[1]=Cal(Cal(n[i1],op[j1],n[i2]),op[j2],Cal(n[i3],op[j3],n[i4]));res[2]=Cal(Cal(n[i1],op[j1],Cal(n[i2],op[j2],n[i3])),op[j3],n[i4]);res[3]=Cal(n[i1],op[j1],Cal(Cal(n[i2],op[j2],n[i3]),op[j3],n[i4]));res[4]=Cal(n[i1],op[j1],Cal(n[i2],op[j2],Cal(n[i3],op[j3],n[i4])));for(k=0;k<5;k++){if(IsEqual(24,res[k])){return 1;}}}}}}}}}}}}return 0;}int main(){double n[4];while(1){scanf(\"%lf%lf%lf%lf\",&n[0],&n[1],&n[2],&n[3]);if(!n[0]&&!n[1]&&!n[2]&&!n[3])break;if(Game24(n))printf(\"YES\\n\");else printf(\"NO\\n\");}return 0;}```","tags":["C"],"categories":[]}]