<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="Lyncien">


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="Lyncien&#39;s homepage">
<meta property="og:url" content="https://l-x.me/page/3/index.html">
<meta property="og:site_name" content="Lyncien&#39;s homepage">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lyncien&#39;s homepage">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Lyncien&#39;s homepage" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Lyncien&#39;s homepage</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<script src="/js/head-pic.js" ></script> <!-- head-pic-flash by Lyncien -->
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic" id="head-pic"> <!-- head-pic-flash by Lyncien -->
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Lyncien</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:Lyncien@126.com" title="Email"></a>
                            
                                <a class="fa Leetcode" href="https://leetcode-cn.com/lyncien/" title="Leetcode"></a>
                            
                                <a class="fa Github" href="https://github.com/Lyncien" title="Github"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/COD/">COD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Compiler/">Compiler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DS/">DS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hackergame2018/">Hackergame2018</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MCPS/">MCPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PC/">PC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Verilog/">Verilog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/感想/">感想</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Lyncien</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic" id="head-pic-mobile"> <!-- head-pic-flash by Lyncien -->
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Lyncien</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:Lyncien@126.com" title="Email"></a>
                            
                                <a class="fa Leetcode" target="_blank" href="https://leetcode-cn.com/lyncien/" title="Leetcode"></a>
                            
                                <a class="fa Github" target="_blank" href="https://github.com/Lyncien" title="Github"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我">
</nav>
      <div class="body-wrap">
  
    <article id="post-cod/lab5_SingleCycleCPU" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/04/cod/lab5_SingleCycleCPU/" class="article-date">
      <time datetime="2018-05-03T16:00:00.000Z" itemprop="datePublished">2018-05-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/04/cod/lab5_SingleCycleCPU/">计算机组成原理上机实验5 单周期CPU</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul>
<li>综合前几次实验的结果，实现一个单周期MIPS指令集的CPU，  然后运行一个计算斐波那契数列的程序。</li>
</ul>
<h2 id="实验平台"><a href="#实验平台" class="headerlink" title="实验平台"></a>实验平台</h2><ul>
<li>ISE 14.7</li>
</ul>
<h2 id="实验过程（分析）"><a href="#实验过程（分析）" class="headerlink" title="实验过程（分析）"></a>实验过程（分析）</h2><ol>
<li><p>模块化设计，主要有以下几个模块</p>
<p> a) alu模块——算术逻辑单元</p>
<p> b) regfile模块——寄存器文件</p>
<p> c) mux模块——选择器</p>
<p> d) IP核生成的IMem模块和DMem模块——存放数据段和代码段</p>
<p> e) nextpclogic模块——计算下一个PC</p>
<p> f) control模块——控制regfile、IMem、DMem、nextpclogic和alu</p>
<p> g) top模块——实例化前几个模块，连接各个信号</p>
</li>
<li><p>alu模块使用case语句判断8种操作类型。</p>
</li>
<li><p>regfile模块用组合逻辑读，时序逻辑写。</p>
</li>
<li><p>IMem和DMem是异步读，同步写，且由指定coe文件初始化，coe文件的内容是16进制文本，由Mars编译一个汇编代码生成。</p>
</li>
<li><p>nextpclogic模块通过组合逻辑计算出nextPC的值。</p>
</li>
<li><p>control模块根据输入的操作符Op对各控制变量进行赋值，根据ALUOp对ALUControl进行赋值。</p>
</li>
<li><p>top模块实例化前几个模块，连接各个信号。</p>
</li>
<li><p>bgtz的实现：bgtz是伪指令（类似地有la和li），不是MIPS指令集的指令，编译时会进行处理，转换为几条指令实现。</p>
<p>这里我用以下三条指令</p>
<pre><code class="assembly">slt $t6,$zero,$t1 # if $t1 &gt; 0, that $t6 = 1, else $t6 = 0

addi $t7,$zero,1 # set $t7 = 1

beq $t6,$t7,loop # jump if $t6 = 1, that is to say, $t1 &gt; 0
</code></pre>
<p>实现</p>
<pre><code class="assembly">bgtz $t1, loop # repeat if not finished yet.
</code></pre>
</li>
</ol>
<ol start="9">
<li><p>完整的数据通路</p>
<p> <img src="//l-x.me/2018/05/04/cod/lab5_SingleCycleCPU/20180527111736051-1.png" alt=""></p>
</li>
</ol>
<p>10、分析结果</p>
<pre><code class="assembly">.data

fibs: .word 0 : 20 # &quot;array&quot; of 20 words to contain fib values

size: .word 20 # size of &quot;array&quot;

temp: .word 3  3

.text

   la $t0, fibs # load address of array

   la $t5, size # load address of size variable

   lw $t5, 0($t5) # load array size

   la $t3, temp # load

   lw $t3, 0($t3)

   la $t4, temp

   lw $t4, 4($t4)

   sw $t3, 0($t0) # F[0] = $t3

   sw $t4, 4($t0) # F[1] = $t4

   addi $t1, $t5,  -2 # Counter for loop, will execute (size-2) times

loop: lw $t3, 0($t0) # Get value from array F[n]

   lw $t4, 4($t0) # Get value from array F[n+1]

   add $t2, $t3, $t4 # $t2 = F[n] + F[n+1]

   sw $t2, 8($t0) # Store F[n+2] = F[n] + F[n+1] in array

   addi $t0, $t0,  4 # increment address of Fib. number source

   addi $t1, $t1,  -1 # decrement loop counter

   slt $t6,$zero,$t1 # if $t1 &gt; 0, that $t6 = 1, else $t6 = 0

   addi $t7,$zero,1 # set $t7 = 1

   beq $t6,$t7,loop # jump if $t6 = 1, that is to say, $t1 &gt; 0

out: 

   j out
</code></pre>
<ul>
<li><p>完整汇编代码如上，可知程序先向内存数据段读取数组首地址和大小（循环次数），读取并写入f[0]=3, f[1]=3，然后循环18次，执行f[i]=f[i-1]+f[i-2]计算斐波那契数列。</p>
</li>
<li><p>如果CPU编写正确，DMem  [0-19]内容  将是3、3、6、9、15、24、39、63、102、165、267、432、699、1131、1830、2961、4791、7752、12543、20295</p>
</li>
</ul>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><ul>
<li><p>仿真结果</p>
<p>  IP核ram设置界面中Load In设置初始化coe文件的路径，</p>
<p>  其中IMem内容为</p>
</li>
</ul>
<pre><code>    MEMORY_INITIALIZATION_RADIX=16;

    MEMORY_INITIALIZATION_VECTOR=

    20080000,

    200d0050,

    8dad0000,

    200b0054,

    8d6b0000,

    200c0054,

    8d8c0004,

    ad0b0000,

    ad0c0004,

    21a9fffe,

    8d0b0000,

    8d0c0004,

    016c5020,

    ad0a0008,

    21080004,

    2129ffff,

    1d20fff9,

    08000011,
</code></pre><p>DMem内容为</p>
<pre><code>    MEMORY_INITIALIZATION_RADIX=16;

    MEMORY_INITIALIZATION_VECTOR=

    00000000

    00000000

    00000000

    00000000

    00000000

    00000000

    00000000

    00000000

    00000000

    00000000

    00000000

    00000000

    00000000

    00000000

    00000000

    00000000

    00000000

    00000000

    00000000

    00000000

    00000014

    00000003

    00000003
</code></pre><p>仿真得DMem和reg数据为</p>
<p><img src="//l-x.me/2018/05/04/cod/lab5_SingleCycleCPU/20180527111736051-2.png" alt=""> </p>
<p>DMem</p>
<p><img src="//l-x.me/2018/05/04/cod/lab5_SingleCycleCPU/20180527111736051-3.png" alt=""> </p>
<p>Regfile</p>
<p>可见运行结果符合分析。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h2><ul>
<li><p>编写过程中遇到问题和一些发现</p>
<ol>
<li><p>位拼接作为左值，单个变量也要花括号，如</p>
<pre><code> `{{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9&#39;b100100100;`
</code></pre></li>
<li><p>“==”会严格匹配每一位，比如module内5位数字比较（一个常量，一个input），但外部传入的是3位的，高位自动拓展好像是x，就导致“==”不成立，这是一个不好发现的问题。</p>
</li>
<li><p>仿真遇到高阻态，多半是这个信号不存在，经常是拼写错了，有时候ise检查不出来。</p>
</li>
<li><p>发现如果Mars的memory configuration设置为默认，则编译后导出代码里面的所有la（给某个寄存器赋值一个32位地址）被翻译为连续两句lui和ori；若memory configuration设置为text at address 0则编译后导出代码里面的所有la被翻译为一句addi。我觉得原因是text地址从0 开始的话，如果text部分较短，地址非0部分未超过16位，那么la只需要给低16位赋值就行了，就可以直接用addi实现（addi指令末16位为立即数）。如果地址是实打实的32位那addi就无能为力了，这时候需要lui给高16位赋值，低16位用ori（ori的rs取$0，作用就和addi一样）。</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>模块源代码</p>
<ul>
<li><p>top.v</p>
<pre><code class="verilog">  module top(
      input clk,
      input rst_n,    
      );

      wire ALUSrc;
      wire [31:0] ALUSrcA;
      wire [31:0] ALUSrcB;
      wire [2:0] ALUControl;
      wire [31:0] ALUResult;
      wire Zero;

      wire [31:0] SignExtented;

      wire [5:0] RegRdaddr1;
      wire [31:0] RegRdout1;
      wire [5:0] RegRdaddr2;
      wire [31:0] RegRdout2;
      wire [5:0] RegWdaddr;   
      wire [31:0] RegWdin;
      wire RegWrite;
      wire RegDst;

      wire [31:0] DMemaddr;
      wire [31:0] DMemout;
      wire [31:0] DMemin;
      wire DMemWrite;
      wire [31:0] IMemRdaddr;
      wire [31:0] IMemRdout;
      wire MemtoReg;

      wire [31:0] Instr;

      reg [31:0] PC=0;
      wire [31:0] nextPC;

      wire [5:0] Funct;
      wire [15:0] IMM16;
      wire [4:0] Rd;
      wire [4:0] Rt;
      wire [4:0] Rs;
      wire [5:0] Op;

      wire [25:0] JumpIMM;
      wire Jump;

      wire Branch;
      integer first;

      //=======================PC========================
      always @(posedge clk or negedge rst_n)
          if(~rst_n) begin first &lt;= 1; PC &lt;= 0; end 
          else if(first == 1) begin first &lt;= 0; PC &lt;= PC; end
          else 
              PC &lt;= nextPC;       

      nextpclogic nextpclogic(PC,Jump,JumpIMM,Branch,Zero,SignExtented,nextPC);   

      //=====================Instruction Memory======================
      assign IMemRdaddr = PC &gt;&gt; 2;//&gt;&gt;2是因为这里IMem是每个地址存储4字节，和实际上的（一地址一字节）不一样
      IMem IMem(0,0,IMemRdaddr,0,0,IMemRdout);
      assign Instr = IMemRdout;

      assign JumpIMM = Instr[25:0];
      assign Funct = Instr[5:0];
      assign IMM16 = Instr[15:0];
      assign Rd = Instr[15:11];
      assign Rt = Instr[20:16];
      assign Rs = Instr[25:21];
      assign Op = Instr[31:26];

      //=======================Regfile========================
      assign RegRdaddr1 = Rs;
      assign RegRdaddr2 = Rt;
      mux #(6) MUXRegWdaddr(RegDst,{1&#39;b0,Rt},{1&#39;b0,Rd},RegWdaddr);
      regfile regfile(~clk,rst_n,RegRdaddr1,RegRdout1,RegRdaddr2,RegRdout2,RegWdaddr,RegWdin,RegWrite);

      //=========================ALU==========================
      assign SignExtented = {{16{IMM16[15]}},IMM16};
      assign ALUSrcA = RegRdout1;
      mux MUXALUSrc(ALUSrc,RegRdout2,SignExtented,ALUSrcB);
      alu alu(ALUSrcA,ALUSrcB,{2&#39;b00,{ALUControl}},ALUResult,Zero);

      //=======================Control========================
      control control(clk,Op,Funct,RegDst,ALUSrc,MemtoReg,RegWrite,DMemWrite,Branch,ALUControl,Jump); 

      //=======================Data Memory========================
      assign DMemaddr = ALUResult &gt;&gt; 2;//&gt;&gt;2理由同上
      assign DMemin = RegRdout2;
      DMem DMem(DMemaddr,DMemin,~clk,DMemWrite,DMemout);  
      mux MUXtoReg(MemtoReg,ALUResult,DMemout,RegWdin);

  endmodule
</code></pre>
</li>
<li><p>alu.v</p>
<pre><code class="verilog">  parameter A_NOP =5&#39;h00; //nop
  parameter A_ADD =5&#39;h01; //sign_add
  parameter A_SUB =5&#39;h02; //sign_sub
  parameter A_AND =5&#39;h03; //and
  parameter A_OR  =5&#39;h04; //or
  parameter A_XOR =5&#39;h05; //xor
  parameter A_NOR =5&#39;h06; //nor
  parameter A_SLT =5&#39;h07; //slt

  module alu(
      input [31:0] alu_a,
      input [31:0] alu_b,
      input [4:0] alu_op,
      output reg [31:0] alu_out,
       output zero
      );
      assign zero = (alu_out == 32&#39;b0)?1:0;
      always@(*)
          case (alu_op)
              A_NOP: alu_out = 0;
              A_ADD: alu_out = alu_a + alu_b;
              A_SUB: alu_out = alu_a - alu_b;
              A_AND: alu_out = alu_a &amp; alu_b;
              A_OR : alu_out = alu_a | alu_b;
              A_XOR: alu_out = alu_a ^ alu_b;
              A_NOR: alu_out = ~(alu_a | alu_b);
              A_SLT: //a&lt;b(signed) return 1 else return 0;
                  begin
                      if(alu_a[31] == alu_b[31]) alu_out = (alu_a &lt; alu_b) ? 32&#39;b1 : 32&#39;b0;
                      //同号情况，后面的小于是视为无符号的比较
                      else alu_out = (alu_a[31] &lt; alu_b[31]) ? 32&#39;b0 : 32&#39;b1;
  //有符号比较符号
                  end         
              default: ;
          endcase
  endmodule
</code></pre>
</li>
<li><p>regfile.v</p>
<pre><code class="verilog">  module regfile(
      input   clk,
      input rst_n,
      input [5:0] rAddr1,//读地址1
      output [31:0] rDout1,//读数据1
      input [5:0] rAddr2,//读地址2
      output [31:0] rDout2,//读数据2
      input [5:0] wAddr,//写地址
      input [31:0] wDin,//写数据
      input wEna//写使能

  );
      reg [31:0] data [0:63];
      integer i;
      assign rDout1=data[rAddr1];//读1
      assign rDout2=data[rAddr2];//读2
      always@(posedge clk or negedge rst_n)//写和复位
          if(~rst_n)
          begin
              for(i=0; i&lt;64; i=i+1) data[i]&lt;=0;
          end
          else
          begin
              if(wEna)
                  data[wAddr]&lt;=wDin;
          end
  endmodule
</code></pre>
</li>
<li><p>nextpclogic.v</p>
<pre><code class="verilog">  module nextpclogic(
     input [31:0] PC,
      input Jump,
      input [25:0] JumpIMM,
     input Branch,
     input Zero,
      input [31:0] SignExtented,
      output [31:0] nextPC
     );

      wire [31:0] ShiftLeft2;
      wire PCSrc;
      wire [31:0] PCPlus4;
      wire [31:0] PCBeq;
      wire [31:0] tmpPC;
      wire tmpzero1,tmpzero2;//no used

      assign ShiftLeft2 = SignExtented &lt;&lt; 2;
      alu ALUPCPlus4(PC,4,A_ADD,PCPlus4,tmpzero1);
      alu ALUPCOffset(ShiftLeft2,PCPlus4,A_ADD,PCBeq,tmpzero2);
      and(PCSrc,Branch,Zero);
      mux MUXPC(PCSrc,PCPlus4,PCBeq,tmpPC);
      mux MUXPC2(Jump,tmpPC,{{PCPlus4[31:28]},{{2'b00,JumpIMM}<<2}},nextpc); endmodule="" <="" code=""></2}},nextpc);></code></pre>
</li>
<li><p>control.v</p>
<pre><code class="verilog">  module control(
      input clk,
      input [5:0] Op, //instr[31:26]
      input [5:0] Funct,//instr[5:0]
      output reg RegDst,
      output reg ALUSrc,
      output reg MemtoReg,
      output reg RegWrite,
      output reg MemWrite,
      output reg Branch,
      output reg [2:0] ALUContol,
      output reg Jump
      );
      reg [1:0] ALUOp;

      always @(*)
      begin
          case(Op)
              6&#39;b000000://R type
                  {{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9&#39;b100100100;
              6&#39;b100011://lw
                  {{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9&#39;b011100000;
              6&#39;b101011://sw  
                  {{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9&#39;bx1x010000;
              6&#39;b000100://beq
                  {{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9&#39;bx0x001010;
              6&#39;b000010://jump
                  {{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9&#39;bxxxxxxxx1;
              6&#39;b001000://addi
                  {{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9&#39;b010100000; 
              default: ;
          endcase             
      end

      always @(*)
      begin
          case(ALUOp)
              2&#39;b00://lw,sw,addi
                  ALUContol = 5&#39;h01;//add
              2&#39;b01://beq
                  ALUContol = 5&#39;h02;//sub
              2&#39;b10://R type
                  case(Funct)
                      6&#39;b100000: ALUContol = 5&#39;h01;//add
                      6&#39;b100010: ALUContol = 5&#39;h02;//sub
                      6&#39;b100100: ALUContol = 5&#39;h03;//and
                      6&#39;b100101: ALUContol = 5&#39;h04;//or
                      6&#39;b100110: ALUContol = 5&#39;h05;//xor
                      6&#39;b100111: ALUContol = 5&#39;h06;//nor      
                      6&#39;b101010: ALUContol = 5&#39;h07;//slt
                      default: ;
                  endcase
              2&#39;b11:
                  ALUContol = 5&#39;h00;//nop
              default: ;
          endcase
      end

  endmodule
</code></pre>
</li>
<li>mux.v<pre><code class="verilog">  module mux #(parameter WIDTH = 32)(
      input sel,
      input [WIDTH-1:0] d0,
      input [WIDTH-1:0] d1,
      output [WIDTH-1:0] out
      );
      assign out = (sel == 1&#39;b1 ? d1 : d0);
  endmodule
</code></pre>
</li>
<li><p>test.v</p>
<pre><code class="verilog">  module test;

      // Inputs
      reg clk;
      reg rst_n;

      // Instantiate the Unit Under Test (UUT)
      top uut (
          .clk(clk), 
          .rst_n(rst_n),
      );
      always #10 clk=~clk;
      initial begin
          // Initialize Inputs
          clk = 0;
          rst_n = 0;

          // Wait 100 ns for global reset to finish
          #100;
          rst_n = 1;

          // Add stimulus here

      end

  endmodule
</code></pre>
</li>
</ul>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/COD/">COD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Verilog/">Verilog</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-os/Process_Communication&amp;Synchronization&amp;Scheduling/Process Communication&amp;Synchronization&amp;Scheduling" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/04/25/os/Process_Communication&Synchronization&Scheduling/Process Communication&Synchronization&Scheduling/" class="article-date">
      <time datetime="2018-04-24T16:00:00.000Z" itemprop="datePublished">2018-04-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/25/os/Process_Communication&Synchronization&Scheduling/Process Communication&Synchronization&Scheduling/">操作系统阅读报告：进程通信与同步、进程调度</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="进程通信与同步、进程调度"><a href="#进程通信与同步、进程调度" class="headerlink" title="进程通信与同步、进程调度"></a>进程通信与同步、进程调度</h1><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ul>
<li><p>进程在执行过程中，如果不被其他进程影响或影响其他进程，则称该进程是独立的，否则称为协作的。进程协作可能是出于以下几个目的：信息共享、提高计算速度、模块化设计…进程间要实现协作就需要一套<strong>通信机制（IPC）</strong>，目前主要有两种模式：共享内存和消息传递。</p>
<ul>
<li><p><strong>消息传递模型。</strong>通过在进程间交换消息来实现通信，它易于实现，不需要避免冲突，但是需要内核介入，时间消耗大，且只能传递少量信息。消息传递可以分为直接通信和间接通信，直接通信明确指定了接收者和发送者，而间接通信在多个进程间共享了一个虚拟邮箱，消息经过邮箱中转。另外，消息传递的实现可以是阻塞（同步）或非阻塞（异步）的，阻塞指发送者（接收者）一直等待直至消息被接收（有消息可用），非阻塞则不等待，如果二者皆阻塞，则它们之间就有一个“集合点”。</p>
</li>
<li><p><strong>共享内存模型。</strong>通过建立一块允许多个进程读写的内存区域实现通信，它能以较快的速度通信，可以传递较多信息，但实现较为复杂。共享内存有一个典型的生产者-消费者问题，生产者产生信息以供消费者使用，为了使它们能并发执行，在共享内存中设置一个缓冲队列，生产者可以加入一项信息，消费者可以取走一项信息。如果缓冲为空，则消费者必须等待，如果缓冲有限且已满，则生产者必须等待。</p>
</li>
</ul>
</li>
<li><p>进程间通信还可以通过<strong>套接字（Socket）</strong>和<strong>管道（Pipe）</strong>实现。套接字由一个IP地址和端口组成，它必须独一无二，确保服务器和客户端的连接，这种方法通常用在不同计算机之间。管道可以实现父子进程之间的通信，可以是匿名或者命名的，但是只能单向传递信息。</p>
</li>
<li><p>进程间协作的一个关键问题是出现<strong>竞争（Race）</strong>，即同时操作一个变量，这将导致执行结果与访问的特定顺序有关。</p>
</li>
</ul>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><ul>
<li><p>为了解决进程的竞争问题，<strong>进程同步</strong>是十分必要的。同步的一个基本要求是<strong>互斥</strong>，即两个进程不能同时操作一个共享的资源，为此，需要定义一个<strong>临界区</strong>，多个进程不能同时处在临界区中，并且等待进入临界区的时间应该是有限的，即临界区应该尽可能地短。此外，还要实现进入临界区和退出临界区的操作，并且能够选择一个合适的进程进入临界区。</p>
</li>
<li><p>目前有几种实现方式，一方面是从硬件来考虑。当进程要进入临界区时，关闭中断，退出临界区时，开启中断，这种方式使得其他进程不能运行，并且在多处理器环境中开销巨大。</p>
</li>
<li><p>另一方面是在软件层面来解决。</p>
<ul>
<li>一个简单的方法是<strong>严格的轮换法</strong>，通过设置一个变量turn标识，仅取值0/1，代表允许哪个进程进入临界区，进程要进入临界区时检查turn，如果不是自己则等待，退出临界区时，将turn置为对方标识，这种方法会导致CPU资源的浪费，并且一个进程不能连续两次进入临界区。</li>
<li><strong>Peterson**</strong>方法**则对此进行了改进，增加了一个布尔型数组表示每个进程是否希望进入临界区，每个进程要进入临界区时检查该数组，如果其他进程也想进入则该进程做出让步。这种方法不会形成严格的轮换，相反地，有可能一个进程一直占着临界区导致一个更高优先级的进程无法进入。</li>
<li>还有一种实现方法是<strong>互斥锁</strong>，通过共享一个新的变量lock，进程要进入临界区时请求锁并等待至锁被释放，退出临界区时释放锁。这种方法要求请求和释放锁的操作是一种<strong>原子操作</strong>（不可中断地），但这种硬件层面的实现并不简单。以上几种方法都存在的问题是等待进入临界区时CPU资源的浪费。</li>
</ul>
</li>
<li><p>实际上，一个较好的方法是通过<strong>信号量（Semaphore）</strong>实现，这类似一个交通指挥者。它定义一个共享的变量Semaphore，可以是二值的（0/1，类似于互斥锁）或者是多值/计数的（表示资源数量），还实现了两个对信号量的操作up()和down()，进程请求资源时down()，释放资源时up()。当down()操作不能被满足时，该进程不是wait而是通过特殊的sleep使自己进入等待队列，这样就不会浪费CPU资源，并且其他进程up()时会唤醒队列中等待的进程（只能是一个），该进程的down()继续执行，并进入临界区。</p>
</li>
<li><p>使用信号量能较好地解决几个经典问题：<strong>生产者**</strong>-<strong>**消费者问题、哲学家进餐问题</strong>（哲学家围绕而坐，相邻两人共享一根筷子）、<strong>读者**</strong>-<strong>**写者问题</strong>（读者与写者以及两个写者之间不能同时操作）。如对于生产者-消费者问题，设置一个二值信号量mutex（确保互斥）和两个计数信号量empty/full（监视缓存的情况），生产者生产一个资源之前要先down(empty)，再down(mutex)，完成后先up(mutex)再up(full)，消费者的过程类似。</p>
</li>
<li><p>进程同步经常遇到的一个问题是<strong>死锁（Deadlock）</strong>。死锁的出现的原因是一个资源只能同时被一个进程使用，而进程占用一个资源时又在等待其他资源，并且不能抢占，这就形成了一个循环等待的情况。比如生产者-消费者问题中将两个down()的顺序弄反了，生产者获得mutex等待empty，而消费者等待mutex，这就形成了死锁。</p>
</li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><ul>
<li><p>多道程序设计允许同时运行多个进程，通过在进程间切换以达到该效果。一般进程执行过程中包括了多个CPU区间和I/O等待区间，在I/O区间时，CPU空闲，为了不浪费CPU这个宝贵的资源，因此需要进程调度，当一个进程等待时（如I/O等待），操作系统将CPU使用权交给其他进程，确保CPU不会空闲。</p>
</li>
<li><p>进程调度包括<strong>抢占</strong>的和<strong>非抢占</strong>的。如果调度只发生在进程必须等待或者结束时，则为非抢占调度，否则称为抢占调度。非抢占调度允许进程更连续地执行，但可能发生CPU占用时间过长，抢占调度则使得每个进程能更快得到CPU的响应。现代操作系统几乎都是抢占调度。</p>
</li>
<li><p>进程调度的<strong>准则</strong>主要有CPU使用率、吞吐量、周转时间、等待时间和响应时间等。CPU使用率应该尽可能高，实际情况在40%~90%较好。吞吐量指单位时间完成进程的数量，也是越高越好。周转时间指从进程提交到完成的所有时间段之和（包括等待进入内存、在就绪队列等待、执行和I/O），等待时间即在就绪队列花费的时间，响应时间即进程提交到开始响应的时间，这三者都是越低越好。但是，这些准则之间是有冲突的，在不同环境下各有所侧重。</p>
</li>
<li><p>进程调度的<strong>算法</strong>主要包括先到先服务（FCFS）、最短作业优先（SJF）、轮转法（RR）、优先级调度和多级队列调度。</p>
<ul>
<li><strong>先到先服务</strong>顾名思义，由一个FIFO队列实现，并且是非抢占的，进程执行直到等待或结束，如果一个长进程先到达，这将导致平均等待时间过长。</li>
<li><strong>最短作业调度</strong>每次选择一个CPU区间最短的进程执行，并且可以分为抢占式和非抢占式的，这种调度方法最大的困难在于不知道下一个CPU区间的长度，一种解决方法是通过公式<img src="//l-x.me/2018/04/25/os/Process_Communication&Synchronization&Scheduling/Process Communication&Synchronization&Scheduling/20180526054518142-1.png" alt="">来预测。</li>
<li><strong>轮转法</strong>是定义了一个较小的时间单元（时间片），就绪队列作为循环队列，被调度执行的进程在达到一个时间片的时间后被重新加入队尾，显然，这是抢占的（除非进程长度小于时间片）。时间片的大小很大程度上决定了RR调度的性能，过长将变成FCFS，过短将导致进程切换开销过大，根据经验，80%的CPU区间应该小于时间片。</li>
<li><strong>优先级调度</strong>为每个进程设置了优先级，优先级高（数值不一定是高）的进程先执行，同样也可以分为抢占和非抢占的，这种调度的主要问题是无穷阻塞（饥饿），即低优先级的进程可能很久都不能得到执行。</li>
<li><strong>多级队列调度</strong>则是优先级调度的一种拓展，进程被划分为多个队列，每个队列有不同的优先级，队列内部则可以根据不同属性采取以上几种不同的调度方法。进一步地，如果允许进程在不同队列之间转移，这就形成了多级反馈队列调度。</li>
<li><strong>多级反馈队列调度</strong>，根据进程的执行和等待时间动态调整优先级，可以防止饥饿发生，当然这种调度算法也最为复杂。</li>
</ul>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h2><p>[1]  Abraham Silberschatz. 操作系统概念. 高等教育出版社, 2010.1.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/">OS</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-cod/lab4_FiniteStateMachine" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/04/19/cod/lab4_FiniteStateMachine/" class="article-date">
      <time datetime="2018-04-18T16:00:00.000Z" itemprop="datePublished">2018-04-19</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/19/cod/lab4_FiniteStateMachine/">计算机组成原理上机实验4 有限状态机</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul>
<li><p>综合利用三次实验的结果，完成以下功能：</p>
<ul>
<li><p>通过例化，向ram中0地址到13地址存入14个数，比如10-23；向ram中100地址到106地址存入7个数，比如0~6，分别代表运算符（与ALU的操作符对应），最后向ram 107地址写入-1</p>
</li>
<li><p>运算控制：</p>
<pre><code>- 从ram 0地址开始的地方取两个数，分别放在reg0和reg1，然后从ram 100地址开始的地方取一个运算符，放到reg2，计算之后，把结果存入ram地址200

- 从ram 2地址开始的地方取两个数，分别放在reg0和reg1，从ram 101地址开始的地方取一个运算符，放到reg2，计算之后，把结果存入ram地址201

- ……

- 如果取出操作符为-1，则结束。
</code></pre></li>
</ul>
</li>
</ul>
<h2 id="实验平台"><a href="#实验平台" class="headerlink" title="实验平台"></a>实验平台</h2><p>ISE 14.7</p>
<h2 id="实验过程（分析）"><a href="#实验过程（分析）" class="headerlink" title="实验过程（分析）"></a>实验过程（分析）</h2><ol>
<li><p>模块化设计，一个alu模块，一个regfile模块，一个IP核生成的ram模块，一个control模块，控制reg、ram和alu，顶层一个top模块实例化前几个模块，ram初始化有coe文件读入。</p>
</li>
<li><p>alu模块使用case语句判断7种操作类型。</p>
</li>
<li><p>regfile模块用组合逻辑读，时序逻辑写。</p>
</li>
<li><p>control模块思路（4周期）由于reg在这里没有实质作用（仅是复制了一份存储），故不考虑相关控制<br> <img src="//l-x.me/2018/04/19/cod/lab4_FiniteStateMachine/pic1.png" alt=""><br> 其中ram_ra为ram读地址，ram_rd为ram读数据，ram_we为ram写使能，tda、tdb为临时寄存上一周期的结果。</p>
</li>
<li><p>分析结果</p>
<p> | Op | Data1 | Data2 | Result |<br> | — | :—: | :—: | :—: |<br> | 0(nop) | 11 | 10 | 0 |<br> | 1(add) | 13 | 12 | 25 |<br> | 2(sub) | 15 | 14 | 1 |<br> | 3(and) | 17(32’b0…10001) | 16(32’b0…10000) | 16(32’b0…10000) |<br> | 4(or) | 19(32’b0…10011) | 18(32’b0…10010) | 19(32’b0…10011) |<br> | 5(xor) | 21(32’b0…10101) | 20(32’b0…10100) | 1(32’b0…00001) |<br> | 6(nor) | 23(32’b0…10111) | 22(32’b0…10110) | -24(32’b1…101000) |</p>
</li>
</ol>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><ul>
<li><p>仿真结果</p>
<p>  IP核ram设置界面中Load In设置ram初始化coe文件的路径，其中文件内容为</p>
<pre><code>  MEMORY_INITIALIZATION_RADIX=10;

  MEMORY_INITIALIZATION_VECTOR=

  10,11,12,13,14,15,16,17,18,19,20,21,22,23,0,0,

  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

  0,0,0,0,0,1,2,3,4,5,6,-1,0,0,0,0,

  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
</code></pre><p>  仿真得ram和reg数据为</p>
<p>  <img src="//l-x.me/2018/04/19/cod/lab4_FiniteStateMachine/pic2.png" alt=""></p>
<p>  ……</p>
<p>  <img src="//l-x.me/2018/04/19/cod/lab4_FiniteStateMachine/pic3.png" alt=""></p>
<p>  ……</p>
<p>  <img src="//l-x.me/2018/04/19/cod/lab4_FiniteStateMachine/pic4.png" alt=""></p>
<p>  可见计算结果符合分析。</p>
</li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h2><ul>
<li><p>模块源代码</p>
<p>top.v</p>
<pre><code class="verilog">module top(
    input clk,
    input rst_n
);

    wire [5:0] ra;
    wire [5:0] wa;
    wire [31:0] rd;
    wire [31:0] wd;
    wire [31:0] aluout;

    reg we=1&#39;b1;
    wire [31:0] tda;
    wire [31:0] tdb;    

    wire clkb;
    wire ram_we;
    wire [7:0] ram_ra;
    wire [7:0] ram_wa;
    wire [31:0] ram_rd;
    wire [31:0] ram_wd;

    alu alu1(ram_rd,tdb,tda,aluout);
    regfile regfile1(clk,rst_n,ra,wa,wd,we,rd);
    control control1(clk,rst_n,aluout,ra,rd,wa,wd,tda,tdb,ram_we,ram_ra,ram_rd,ram_wa,ram_wd);
    ram ram1(clk,ram_we,ram_wa,ram_wd,clk,ram_ra,ram_rd);

endmodule
</code></pre>
<p>alu.v</p>
<pre><code class="verilog">parameter A_NOP =5&#39;h00; //nop
parameter A_ADD =5&#39;h01; //sign_add
parameter A_SUB =5&#39;h02; //sign_sub
parameter A_AND =5&#39;h03; //and
parameter A_OR  =5&#39;h04; //or
parameter A_XOR =5&#39;h05; //xor
parameter A_NOR =5&#39;h06; //nor

module alu(
    input [31:0] alu_a,
    input [31:0] alu_b,
    input [4:0] alu_op,
    output reg [31:0] alu_out
    );
    always@(*)
        case (alu_op)
            A_NOP: alu_out = 0;
            A_ADD: alu_out = alu_a + alu_b;
            A_SUB: alu_out = alu_a - alu_b;
            A_AND: alu_out = alu_a &amp; alu_b;
            A_OR : alu_out = alu_a | alu_b;
            A_XOR: alu_out = alu_a ^ alu_b;
            A_NOR: alu_out = ~(alu_a | alu_b);
            default: alu_out = 0;
        endcase
endmodule
</code></pre>
<p>regfile.v</p>
<pre><code class="verilog">module regfile(
    input   clk,
    input rst_n,
    input [5:0] rAddr1,//读地址
    input [5:0] wAddr,//写地址
    input [31:0] wDin,//写数据
    input wEna,//写使能
    output [31:0] rDout1//读数据1
);
    reg [31:0] data [0:63];
    integer i;
    assign rDout1=data[rAddr1];//读

    always@(posedge clk or rst_n)//写和复位
        if(~rst_n)
        begin 
            for(i=0; i&lt;64; i=i+1) data[i]&lt;=0;
        end
        else
        begin
            if(wEna)
                data[wAddr]&lt;=wDin;
        end
endmodule
</code></pre>
<p>control.v</p>
<pre><code class="verilog">module control(
    input clk,rst_n,
    input [31:0] aluout,

    output reg [5:0] ra=6&#39;d0,//reg read addr
    input [31:0] rd,//reg read data
    output reg [5:0] wa=6&#39;d0,//reg write addr
    output reg [31:0] wd,//reg write data

    output reg [31:0] tda,//tmp data a
    output reg [31:0] tdb,//tmp data b

    output reg ram_we,//ram write enable
    output reg [7:0] ram_ra,//ram read addr
    input [31:0] ram_rd,//ram read data
    output reg [7:0] ram_wa,//ram write addr
    output reg [31:0] ram_wd//ram write data
    );
    reg [2:0] cstate;//current state
    reg [2:0] nstate;//next state
    reg endflag=0;
    integer i=0;

    always @(posedge clk or negedge rst_n)
        if(~rst_n) 
            cstate&lt;=3&#39;d0;
        else 
            cstate&lt;=nstate;

    always @(*)
        if(cstate==3&#39;d0) nstate=3&#39;d1;
        else if(cstate==3&#39;d1 &amp; endflag==1&#39;d0) nstate=3&#39;d2;
        else if(cstate==3&#39;d1 &amp; endflag==1&#39;d1) nstate=3&#39;d5;
        else if(cstate==3&#39;d2) nstate=3&#39;d3;
        else if(cstate==3&#39;d3) nstate=3&#39;d4;
        else if(cstate==3&#39;d4) nstate=3&#39;d1;
        else if(cstate==3&#39;d5) nstate=3&#39;d5;
    always @(negedge clk or negedge rst_n)
    begin
        if(~rst_n)
            begin
                ram_ra&lt;=0;
                ram_wa&lt;=0;
                i&lt;=0;
            end
        else if(cstate==3&#39;d1)
            begin
                ram_ra&lt;=100+i;  
            end
        else if(cstate==3&#39;d2)
            begin
                ram_ra&lt;=2*i;
                tda&lt;=ram_rd;
                if(ram_rd==-1) endflag&lt;=1;
            end
        else if(cstate==3&#39;d3)
            begin
                ram_ra&lt;=2*i+1;
                tdb&lt;=ram_rd;
            end
        else if(cstate==3&#39;d4)
            begin
                ram_wa&lt;=200+i;
                ram_we&lt;=1;
                ram_wd&lt;=aluout;
                i&lt;=i+1;
            end         
    end

endmodule
</code></pre>
<p>test.v</p>
<pre><code class="verilog">module test(
    );
    reg clk,rst_n;
    top test(
        .clk(clk),
        .rst_n(rst_n),
    );
    always #10 clk=~clk;
    initial begin
        clk=0;
        rst_n=0;
        #20;
        rst_n=1;
    end
endmodule
</code></pre>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/COD/">COD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Verilog/">Verilog</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-os/Process_Concepts&amp;Operations,Thread/Process Concepts&amp;Operations,Thread" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/31/os/Process_Concepts&Operations,Thread/Process Concepts&Operations,Thread/" class="article-date">
      <time datetime="2018-03-30T16:00:00.000Z" itemprop="datePublished">2018-03-31</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/31/os/Process_Concepts&Operations,Thread/Process Concepts&Operations,Thread/">操作系统阅读报告：进程与线程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><ul>
<li>我们知道，人们通过操作系统来更方便地操作硬件，提高使用计算机的效率。早期的计算机只允许一次执行一个程序，这样的程序完全控制了系统，能访问所有的资源。但随着操作系统的功能愈加复杂，计算机的应用更加广泛，人们往往需要同时进行多个作业，因此就有了进程的概念，不同的进程同时运行，互相独立，进行不同的工作。</li>
</ul>
<ul>
<li>进程（Process），可以认为是执行中的程序。值得注意的是，程序本身不是进程。程序是被动实体，是存储在磁盘上的包含一系列指令的文件，而进程是活动实体，当一个程序被载入内存后并进行了相关资源分配后，才可以说进程开始运行了。</li>
</ul>
<h2 id="进程的信息"><a href="#进程的信息" class="headerlink" title="进程的信息"></a>进程的信息</h2><ul>
<li>一个进程开始运行后，用户内存中将有一段空间被分配给这个进程，具体结构见右图1。其中，文本段（Text）存放程序代码，数据段（Data）存放全局变量，栈（Stack）存放函数参数、局部变量等，堆（Heap）用于动态分配空间。栈和堆朝着相反的方向增长，这是为了提高内存空间利用率。</li>
</ul>
<p><img src="//l-x.me/2018/03/31/os/Process_Concepts&Operations,Thread/Process Concepts&Operations,Thread/20180526050442907-1.png" alt=""> </p>
<ul>
<li>同时，操作系统会为每个进程在内核空间中设置一个进程控制块（Process Control Block，PCB），其结构如图2。进程状态由当前进行的活动定义，包括new（正在被创建）、Running（正在执行指令）、Waiting（等待某事件发生，如I/O完成）、Ready（等待处理器分配）、Terminated（终止），它们之间的相互转化见图3。进程编号是操作系统为每个进程分配的唯一的身份标识。进程计数器表示将要执行的下一个指令的地址。寄存器则存放进程执行时的中间信息。</li>
<li>PCB的一个重要作用就是多道程序设计中操作系统在切换执行的进程时，可以将当前进程状态保存在PCB中，并从PCB读取新的进程的信息。</li>
</ul>
<p><img src="//l-x.me/2018/03/31/os/Process_Concepts&Operations,Thread/Process Concepts&Operations,Thread/20180526050442907-2.png" alt=""><br><img src="//l-x.me/2018/03/31/os/Process_Concepts&Operations,Thread/Process Concepts&Operations,Thread/20180526050442907-3.jpg" alt=""></p>
<h2 id="进程的操作"><a href="#进程的操作" class="headerlink" title="进程的操作"></a>进程的操作</h2><ul>
<li><p>进程的操作主要包括获取进程ID、创建进程、终止进程和进程间的通信，这些操作都可以通过系统调用来实现，下面介绍前三者的实现。</p>
<p>  <strong>1. 获取进程的ID。</strong></p>
<ul>
<li><p>进程独一无二的身份标识（PID）可以通过getpid()直接获取。</p>
<p><strong>2. 创建进程。</strong></p>
</li>
<li><p>一个进程可以通过系统调用来创建新的进程，则它本身称为父进程，新进程称为子进程。子进程还能再创建它的子进程，因此于是便形成了进程树。通常操作系统以一个初始进程（如init）为根形成进程树。</p>
</li>
<li><p>进程创建的一些细节实现可能并不唯一。如进程创建时需要一定的资源（如内存，I/O），它可能从操作系统那里直接获取，也可能从父进程获取。另一方面，子进程创建时，父进程可能与其并发执行，也可能等待子进程执行完后才继续执行。下面以UNIX系统为例，说明进程创建的基本过程。</p>
</li>
<li><p>在UNIX中，通过系统调用fork()来创建子进程，它将是父进程的一份完全拷贝，包括用户内存空间和PCB中的信息，同时进程PCB被加入到任务链表中。接下来，子进程的PID将被修改为一个与父进程不同的值，进程时间被置为0，同时它与父进程将相互记录为父子关系。由于PCB程序计数器也被完全复制，则子进程将与父进程继续执行相同的代码。另外，一个明显的差别是父进程的fork()将返回子进程的PID，而子进程的fork()将返回0，在代码中可以据此区分它们。</p>
</li>
<li><p>对于子进程，在创建完成后，可以不执行其他代码，与父进程保持相同。然而更有意义的做法是通过系统调用exec()来载入指定路径下的程序，这样进程将执行一个全新的程序，除了保留PID、程序运行时间和父子关系，包括内存和寄存器中的信息几乎都被丢弃，代码段被重置为载入程序的代码。</p>
</li>
<li><p>对于父进程，在调用fork()后，如果没有什么事情可做，可以调用wait()来将自身挂起，等待子进程执行直到结束。</p>
<p><strong>3. 终止进程。</strong></p>
</li>
<li><p>当进程完成执行后，通过调用exit()请求系统删除自身，所有的内存信息都将被释放。然而，进程将保留一个空的PCB在系统进程链表中，成为“僵尸”进程，同时向父进程发送一个SIGCHLD信号。这样做的一个原因是，子进程结束时，父进程可能由于有其他任务而还没有调用wait()或及时响应。直到wait()调用后，僵尸子进程才真正从任务链表中被删除。</p>
</li>
<li><p>另外，进程也可能通过系统调用来终止其他进程，通常只能对子进程实施这种操作。当一个进程被终止时，在一些系统中，子进程也被一并结束，另一些系统中，子进程将以init为父进程。</p>
</li>
</ul>
</li>
</ul>
<h2 id="线程的概念和优点"><a href="#线程的概念和优点" class="headerlink" title="线程的概念和优点"></a>线程的概念和优点</h2><ul>
<li><p>进程帮助人们将不同的工作分离开来，各自运行。更具体地看，一项工作往往需要同时处理多个任务（如服务器同时响应多个客户，浏览器同时获取数据和渲染页面），但我们并不因此创建多个进程，而是在一个进程下创建多个线程（Thread）来实现。这样做的主要原因或者说线程相对于进程的优点有以下几点：进程的创建和切换很耗费时间和资源，而线程之间可以共享进程的代码、数据和文件，大大减小了创建和切换的开销，同时更易于相互之间的通信。另一方面，线程能充分利用处理器的多个核心，真正实现并行，当一个线程出现阻塞时，其他线程并不因此受到影响。</p>
</li>
<li><p>当然，线程也存在一些问题，如怎样分配任务，使每个线程的工作相对平衡？如何保证数据的同步和一致性？</p>
</li>
</ul>
<h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><ul>
<li><p>线程可以分为用户线程和内核线程（由系统直接管理），它们之间有三种关系</p>
<ol>
<li><p>多对一模型：既多个用户线程对应一个内核线程，这种做法效率较高，但如果有一个线程执行了阻塞系统调用，那么整个进程都会被阻塞。</p>
</li>
<li><p>一对一模型：既一个用户线程对应一个内核线程，这种做法允许多个线程并行运行在多处理器上，缺点是大多数系统的内核线程数量是有限的。</p>
</li>
<li><p>多对多模型：这种做法多路复用了内核线程，允许任意多的用户线程，当一个线程执行了阻塞调用时，内核可以调度另一个线程来执行。</p>
</li>
</ol>
</li>
</ul>
<h2 id="多线程相关问题"><a href="#多线程相关问题" class="headerlink" title="多线程相关问题"></a>多线程相关问题</h2><ul>
<li><p>线程库（Thread library）是为开发人员提供的创建和管理线程的API，目前主要有三种线程库：POSIX Pthread、Win32和Java。</p>
</li>
<li><p>多线程中fork()调用有两种，一种复制所有线程，一种只复制调用了fork()的线程，而exec()与进程中的相同。</p>
</li>
<li><p>线程池（Thread pool）是一种在进程开始时创建一定数量的线程放入池中的机制，当有任务请求时，它唤醒一个线程来处理，完成任务后，线程返回池中再等待工作。线程池解决了服务器中接受大量请求时各自频繁地创建和删除线程带来的巨大耗费。</p>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]  Abraham Silberschatz. 操作系统概念. 高等教育出版社, 2010.1.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/">OS</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-os/System_Call/System Call" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/18/os/System_Call/System Call/" class="article-date">
      <time datetime="2018-03-17T16:00:00.000Z" itemprop="datePublished">2018-03-18</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/18/os/System_Call/System Call/">操作系统阅读报告：系统调用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>通过上一章，我们知道操作系统的设计目的是为了让人们更加方便、高效地使用计算机。因此，人们编写程序的时候，往往不会直接操纵硬件和关注十分细枝末节的方面，而是通过对操作系统提供的所谓的“<strong>系统调用（System Call）</strong>”进行组织来实现相应的操作。实际上，系统调用是多层次的，每一层次只关心如何组织低层次的系统调用来实现本层次的功能，而不关心低层次的系统调用具体是如何实现的。具体到使用高级语言编写程序的开发人员来说，他们也不直接使用实际的系统调用，而是使用操作系统提供的<strong>应用程序接口（**</strong>Application Programming Interface<strong><strong>，简称API</strong></strong>）**。API是一系列适应于具体程序开发的函数，开发人员通过向函数传递参数，来得到相应的返回值或实现某种操作。包括API在内的系统调用为开发人员带来的巨大的便利，它向开发人员隐藏了大部分的细节，开发人员只需要知道如何使用它们，这样一来，开发人员可以站在更高、更抽象的层次上来思考问题和编写程序。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>系统调用大致可以分为五类：<strong>进程控制、文件管理、设备管理、信息维护和通信</strong>。</p>
<ul>
<li><p>进程控制相关的系统调用包括创建和终止进程、获取进程信息、跟踪进程等等。创建进程的系统调用能决定进程的属性，如优先级和最大允许执行时间。一旦一个进程不再需要或者发生了异常，可以使用系统调用来终止它，同时可以获得内存转储信息来分析和调试程序。通过系统调用还可获得程序的时间表，它具有跟踪功能和定时时间中断，如果中断足够频繁，可以得到程序各部分所用的时间。</p>
</li>
<li><p>文件管理相关的系统调用主要包括创建、读写、删除文件，查看、修改文件属性等操作，更高级的系统调用还可以定位、移动、复制文件。另外，可以通过系统调用创建目录来组织和管理文件。</p>
</li>
<li><p>设备管理相关的系统调用包括对物理设备的识别、访问等。用户程序通过请求操作系统来获得对设备进行访问的权限，一旦获得使用权限，就可通过系统调用进行读写等操作，正如对待文件一样。用户使用完成后，通过系统调用释放它。</p>
</li>
<li><p>信息维护相关的系统调用包括获取当前的时间和日期、获取当前空闲内存/磁盘大小、获取当前用户数以及一些操作系统的其他信息等等，通过系统调用实现用户与系统之间的信息交换。</p>
</li>
<li><p>通信模型包括消息传递模型和共享内存模型。消息传递模型是指进程间通过操作系统的专用程序进行彼此的信息交换，并通过一定的标识符进行识别。一般而言，消息传递模型更容易实现，适合传递少量的信息。共享内存模型通过指定一块公共的内存区域，使两个或多个程序能同时拥有该区域的访问权，这种方法通信速度快且能共享较多的数据，但是建立方式较为复杂。</p>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]  Abraham Silberschatz. 操作系统概念. 高等教育出版社, 2010.1.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/">OS</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-os/OS_Summary/OS Summary" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/11/os/OS_Summary/OS Summary/" class="article-date">
      <time datetime="2018-03-10T16:00:00.000Z" itemprop="datePublished">2018-03-11</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/11/os/OS_Summary/OS Summary/">操作系统阅读报告：操作系统概述</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><ul>
<li>操作系统是介于计算机硬件与用户之间的中间程序，它的设计目的是为了让人们更加方便高效地使用计算机。但目前来说，并没有一个关于操作系统的十分完整的定义。<ul>
<li>对于用户来说，操作系统的主要功能是为了让其更加方便地操作硬件，优化日常进行的工作，而并不那么关心资源使用率。当然，在某些情况下，比如工作站，操作系统的功能是个人使用性能和资源使用率的折中。</li>
<li>对于计算机来说，操作系统是一个资源分配器，它管理、调度、分配各种资源，使计算机更加有效而公平地运行。同时，操作系统也是控制程序，它管理用户程序执行，防止计算机被错误使用，对异常进行处理。</li>
</ul>
</li>
</ul>
<h2 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h2><ul>
<li>操作系统有一种称为“多道程序设计”的重要机制，它使得CPU总有一个作业可以执行，充分提高的CPU的利用率。操作系统将多个作业保存在内存中并选择一个开始执行，这个作业可能需要等待另一个任务完成（如I/O操作）。此时，操作系统将切换到另一个作业执行，在前一个作业等待完成后切换回去。如此一来，只要有作业可以执行，CPU就不会空闲。</li>
<li>多道程序设计并没有提供与计算机系统直接交互的能力，因此有了分时系统，它是多道程序设计的延伸。分时系统的每个命令或动作都比较短，因此在不同作业之间切换的频率较高，用户可以在程序运行期间与之交户并感觉到整个系统都为自己所用，尽管事实上可能为许多用户共享。</li>
</ul>
<h2 id="操作系统的操作"><a href="#操作系统的操作" class="headerlink" title="操作系统的操作"></a>操作系统的操作</h2><ul>
<li>现代操作系统是由中断驱动的。如果没有进程执行和用户请求，操作系统将默默等待直至事件发生。对于每一种中断，操作系统定义不同代码并由中断处理器来处理。异常也是一种中断，它源于出错。由于不同程序共享了硬件，操作系统必须设计一些保护，以防止某个程序出错时影响其他程序。</li>
<li>许多操作系统采用双重模式操作，也就是区分操作系统代码和用户定义代码。用户程序正在运行时，系统处于用户模式。当用户通过系统调用请求操作系统的服务时，模式转换为系统模式。另外，出现中断和异常时，也会切换为系统模式，操作系统获得控制权。双重操作模式也提供了保护操作系统和用户程序不受错误影响的方法，即把能引起机器损坏的指令作为特权指令。如果在用户模式下试图执行特权指令，那么硬件将不予执行，并以异常的形式通知操作系统。显然，转换到用户模式是一个特权指令，I/O控制、中断管理也是特权指令。</li>
<li>为了使操作系统保持对CPU的控制，防止用户程序陷入死循环，可以设定定时器。操作系统在将控制权交给用户程序前，为定时器设置一个时间，在时间到达后自动产生中断，控制权将交回操作系统。</li>
</ul>
<h2 id="操作系统的主要模块"><a href="#操作系统的主要模块" class="headerlink" title="操作系统的主要模块"></a>操作系统的主要模块</h2><ul>
<li>操作系统的主要模块有进程管理、内存管理、存储管理。<ul>
<li>正在执行中的程序称为进程，它是系统工作的单元。值得注意的是，程序本身并不是进程，程序是存储在磁盘中的静态信息，而进程是活动的实体。进程包括系统进程和用户进程，并需要一些资源来完成任务。操作系统负责创建进程并分配资源给进程，提供进程同步机制、通信机制，提供死锁处理机制，并在删除进程时回收资源。</li>
<li>内存是现代操作系统操作的中心，是CPU所能直接访问的唯一大容量存储器。当一个程序将要运行时，它先被装入内存中，然后CPU才可以读取指令和数据。操作系统在内存管理上的作用是分配和释放内存空间，记录内存哪些部分正在被使用和被哪个程序使用，决定哪些进程可以装入内存。</li>
<li>文件是由创建者定义的一组信息的集合，可以存储在不同的物理介质中（如磁盘）。操作系统的文件管理活动主要有创建和删除文件，创建目录组织文件，同时对大容量存储器的空间进行调度和分配。另外，操作系统还管理高速缓存。高速缓存是为了使CPU更快地读取信息，它将内存中的信息复制到其中，以便下一次的快速重复使用。它的设计和置换策略十分重要，其中一个重要的问题是如何确保高速缓存一致性。</li>
</ul>
</li>
</ul>
<h2 id="操作系统的保护与安全"><a href="#操作系统的保护与安全" class="headerlink" title="操作系统的保护与安全"></a>操作系统的保护与安全</h2><ul>
<li>计算机系统可能有多个用户并允许多个进程同时运行，那么只有进行系统地管理，才能确保每个用户每个进程只在属于自己的空间中进行，并按时转交CPU控制权。</li>
<li>保护是一种控制进程和用户对计算机系统资源的访问的机制。系统将通过授权的方式分配资源，只有获得了系统的授权，用户和进程才能访问相应的资源。</li>
<li>安全是防止系统受到外部或内部攻击的机制。这些攻击包括病毒、蠕虫、拒绝服务攻击等。近年来操作系统的安全问题成为许多研究关注的领域。</li>
<li>操作系统实现保护与安全的一个重要前提是操作系统能区分它的所有用户。在一般的系统中，使用用户ID和组ID就足够了。如果用户需要访问受限的设备，则需要通过升级特权的方式获得使用权。</li>
</ul>
<h2 id="分布式系统和专用系统"><a href="#分布式系统和专用系统" class="headerlink" title="分布式系统和专用系统"></a>分布式系统和专用系统</h2><ul>
<li>分布式系统是将一组物理上分开的，各种不同结构的计算机连接在一起，而网络则是它们之间的通讯路径。分布式系统将各种资源整合在一起，增加了计算速度和可靠性。</li>
<li>专用系统与通用系统的区别是它的功能有限，只在某些专门的领域内运行。专用系统包括实时嵌入式系统（如各种工业上的控制系统）、多媒体系统和手持系统（如PDA和手机）。</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h2><p>[1]    Abraham Silberschatz. 操作系统概念. 高等教育出版社, 2010.1.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/">OS</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ds/lab4_ShortestPaths" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/09/ds/lab4_ShortestPaths/" class="article-date">
      <time datetime="2017-12-08T16:00:00.000Z" itemprop="datePublished">2017-12-09</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/09/ds/lab4_ShortestPaths/">数据结构上机题4 最短路径</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul>
<li><p>ddl：12月9日。</p>
</li>
<li><p>实验题目：</p>
<ul>
<li>给定图的边和边权值（非负数），求给定两顶点间的最短路径。边和边权值（格式为边的兩顶点和权值，勿直接输入邻接矩阵）、两顶点由窗口（文件也可以）输入。输出路径和路径总权值。</li>
</ul>
</li>
<li><p>基本要求（8分）：</p>
<ul>
<li>无向图、顶点以自然数命名</li>
</ul>
</li>
<li><p>扩展：</p>
<ul>
<li>有向图；</li>
<li>路径除起终顶点外，过另外几个给定顶点；</li>
<li>顶点支持隨意命名；</li>
<li>图形界面；</li>
<li>等等….</li>
</ul>
</li>
</ul>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>1.打开ShortestPaths.exe，选择有向图模式或无向图模式</p>
<p>2.点击帮助按钮查看如何操作</p>
<p>3.点击导入文件可导入事先建好的图，.udg为无向图文件，.dg为有向图文件，只能导入运行程序目录下的文件，只输入文件名（不用输入后缀名，会根据当前模式读取对应文件）</p>
<p>4.导入后，左键单击某个顶，呈选中状态（绿色），然后按住SHIFT，再左键单击另一个顶，将求出最短路径，路径高亮加粗显示（黄色）。</p>
<p>5.ShortestPaths文件夹内为工程源代码，在VS2010下创建，ShortestPaths.cpp绘制界面和处理键鼠操作，graph.h为图数据结构声明和基本操作</p>
<h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p><img src="//l-x.me/2017/12/09/ds/lab4_ShortestPaths/1.png" alt=""></p>
<p><img src="//l-x.me/2017/12/09/ds/lab4_ShortestPaths/1.png" alt=""></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>注：需要easyx图形库</p>
<p>graph.h</p>
<pre><code class="c">#include &lt;string.h&gt;
#define INF 99999999
#define MAX_VERTEX_NUM 100
#define MAX_NAME 10
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define Status int
typedef enum {DG,DN,UDG,UDN}GraphType;
typedef struct ArcCell{
    int w;//边的权值,0为不连通
}GArc,ArcArray[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
typedef struct Vertex{
    TCHAR name[MAX_NAME];//顶的名称
    int x,y;//用于绘制该顶时的位置
    int l;//dijkstra算法需要
    int state;//=0正常，=1选中
}GVex,VexArray[MAX_VERTEX_NUM];
typedef struct Graph{
    ArcArray arcs;
    VexArray vexs;
    int arcnum,vexnum;
    GraphType type;
}MGraph;
typedef struct DijkstraResult{
    int vexbegin;//表示这个结果是从该顶到其他顶的最短距离
    int prev[MAX_VERTEX_NUM];//最短路径上每个顶的前一个顶
    int dist[MAX_VERTEX_NUM];//每个顶到vexbegin的最短距离
}DijRes;
Status CreateGraph(MGraph* g){
    g-&gt;arcnum=0;
    g-&gt;vexnum=0;
    memset(g-&gt;vexs,0,sizeof(GVex)*MAX_VERTEX_NUM);
    memset(g-&gt;arcs,0,sizeof(GArc)*MAX_VERTEX_NUM*MAX_VERTEX_NUM);
    return OK;
}
Status DestoryGraph(MGraph *g){
    g-&gt;arcnum=0;
    g-&gt;vexnum=0;
    memset(g-&gt;vexs,0,sizeof(GVex)*MAX_VERTEX_NUM);
    memset(g-&gt;arcs,0,sizeof(GArc)*MAX_VERTEX_NUM*MAX_VERTEX_NUM);
    return OK;
}
int LocateVex(MGraph g,TCHAR vexname[]){//获取顶在图中的位置，即在顶数组中的下标,未找到返回-1 
    int i;
    for(i=0;i&lt;g.vexnum;i++){
        if(!_tcscmp(g.vexs[i].name,vexname)) return i;
    }
    return -1;
}
Status InsertVex(MGraph *g,TCHAR vexname[],int x,int y){//添加一个顶，不允许为空，不允许重名 
    _tcscpy_s(g-&gt;vexs[g-&gt;vexnum].name,vexname);
    g-&gt;vexs[g-&gt;vexnum].x=x;
    g-&gt;vexs[g-&gt;vexnum].y=y;
    g-&gt;vexs[g-&gt;vexnum].l=0;
    g-&gt;vexnum++;
    return OK; 
}
Status DeleteVex(MGraph *g,TCHAR vexname[]){
    int i=LocateVex(*g,vexname),j;
    if(i==-1) return ERROR;
    _tcscpy_s(g-&gt;vexs[i].name,g-&gt;vexs[g-&gt;vexnum-1].name);//最后一个顶覆盖要删除的顶 
    _tcscpy_s(g-&gt;vexs[g-&gt;vexnum-1].name,_T(&quot;&quot;));
    for(j=0;j&lt;MAX_VERTEX_NUM;j++){
        g-&gt;arcs[i][j].w=g-&gt;arcs[g-&gt;vexnum-1][j].w;
        g-&gt;arcs[g-&gt;vexnum-1][j].w=0;
    }
    return OK; 
}

DijRes Dijkstra(MGraph g,int v){//求其他各顶到顶v的最短路径
    DijRes r={};
    int flag[MAX_VERTEX_NUM]={0};//标志是否已找到最短路径
    int i,j,mindist,minu;
    for(i=0;i&lt;g.vexnum;i++){//初始化每个顶到v的距离
        if(g.arcs[v][i].w){//连通则初始距离为边权
            r.dist[i]=g.arcs[v][i].w;
            r.prev[i]=v;
        }
        else{//不连通为无穷
            r.dist[i]=INF;
            r.prev[i]=-1;
        }
    }
    r.dist[v]=0;//v到v为0
    flag[v]=1;//v标志为已找到
    for(i=1;i&lt;g.vexnum;i++){//遍历vexnum-1次,每次找出一个顶点的最短路径
        mindist=INF+1;
        minu=-1;
        for (j=0;j&lt;g.vexnum;j++){//求出未标记的顶中到v最短的
            if(flag[j]==0 &amp;&amp; r.dist[j]&lt;mindist){
                mindist=r.dist[j];
                minu=j;
            }
        }
        flag[minu]=1;
        for (j=0;j&lt;g.vexnum;j++){//根据新找到的顶u更新其他各顶最短距离
            int sum=mindist+(g.arcs[minu][j].w==0?INF:g.arcs[minu][j].w); // 边权为0不连通，以无穷计算
            if (flag[j]==0 &amp;&amp; (sum&lt;r.dist[j])){
                r.dist[j]=sum;
                r.prev[j]=minu;
            }
        }

    }

    return r;
}
</code></pre>
<p>ShortestPaths.cpp</p>
<pre><code class="c">    // MinRoad.cpp : 定义控制台应用程序的入口点。
    #define SPACE 20 //按钮间隔大小
    #define HEIGHT 480
    #define WIDTH 800
    #define BUTTONHEIGHT 40 //按钮大小
    #define BUTTONWIDTH 150 //按钮大小
    #define CONTROLWIDTH BUTTONWIDTH+2*SPACE //控制区大小
    #define VEXRADIUS 20 //顶半径
    #define ARROWLEN 10 //箭头斜边的长
    #define PI 3.1415926
    #define HPI 1.5707963

    #include &lt;graphics.h&gt;//easyx图形库头文件
    #include &lt;windows.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;math.h&gt;
    #include &quot;graph.h&quot;//图
    TCHAR runpath[256];//运行路径
    int MODE=0;//0为无向图，1为有向图
    int vsel=-1;//当前选中顶
    int vmov=-1;//当前移动顶
    MGraph g;//定义一个图
    void DrawButton(int left,int top,LPCTSTR text){

        setbkmode(TRANSPARENT);//设置字体背景透明
        setfillcolor(RGB(136,247,104));//设置填充颜色
        setlinestyle(PS_SOLID,4);//设置线型线宽
        setlinecolor(RGB(249,102,102));//设置线颜色
        settextstyle(25, 0, _T(&quot;宋体&quot;),0,0,FW_BOLD,0,0,0);//设置字体，大小，粗细
        settextcolor(RGB(0,0,255));//设置字体颜色

        RECT r;
        r.left=left; r.top=top; r.right=left+BUTTONWIDTH; r.bottom=top+BUTTONHEIGHT;
        fillroundrect(left,top,left+BUTTONWIDTH,top+BUTTONHEIGHT,5,5);//带边框填充
        drawtext(text,&amp;r,DT_CENTER|DT_VCENTER|DT_SINGLELINE);//输出字
    }
    void InitUI(){
        initgraph(WIDTH, HEIGHT);   // 创建绘图窗口
        int t=SPACE;
        DrawButton(SPACE,t,(LPCTSTR)L&quot;帮  助&quot;);
        t+=SPACE+BUTTONHEIGHT;
        DrawButton(SPACE,t,(LPCTSTR)L&quot;导出文件&quot;);
        t+=SPACE+BUTTONHEIGHT;
        DrawButton(SPACE,t,(LPCTSTR)L&quot;导入文件&quot;);
        t+=SPACE+BUTTONHEIGHT;
        DrawButton(SPACE,t,(LPCTSTR)L&quot;关  于&quot;);
        line(CONTROLWIDTH,0,CONTROLWIDTH,HEIGHT);
        HRGN rgn = CreateRectRgn(CONTROLWIDTH,0,WIDTH,HEIGHT);
        setcliprgn(rgn);//之后的绘图区域只在该矩形内有效
        DeleteObject(rgn);    

    }
    void DrawVex(int i){
        setbkmode(TRANSPARENT);//设置字体背景透明
        setfillcolor(RGB(255,188,121));//设置填充颜色
        setlinestyle(PS_SOLID,4);//设置线型线宽

        if(g.vexs[i].state==0)
            setlinecolor(RGB(129,29,228));//设置线颜色
        else
            setlinecolor(RGB(92,185,0));//设置线颜色(选中状态)
        settextstyle(30, 0, _T(&quot;Arial&quot;),0,0,FW_BOLD+100,0,0,0);//设置字体，大小，粗细
        settextcolor(RGB(255,0,0));//设置字体颜色

        RECT r;
        r.left=g.vexs[i].x-VEXRADIUS; r.top=g.vexs[i].y-VEXRADIUS; 
        r.right=g.vexs[i].x+VEXRADIUS; r.bottom=g.vexs[i].y+VEXRADIUS;
        fillcircle(g.vexs[i].x,g.vexs[i].y,VEXRADIUS);
        drawtext((LPCTSTR)(g.vexs[i].name),&amp;r,DT_CENTER|DT_VCENTER|DT_SINGLELINE);
    }
    double GetAngle(int x1,int y1,int x2,int y2){//从(x1,y1)到(x2,y2)的向量的方位角，以x轴为0度，顺时针，弧度值
        double a=atan(((double)(y2-y1))/(x2-x1));//得到-pi/2~pi/2的弧度值
        if(x2&gt;x1) return a;
        else if(x2==x1) return (y2&gt;=y1)?HPI:-HPI;//pi/2和-pi/2,两点重合这里会返回pi/2
        else return (y2&gt;=y1)?a+PI:a-PI;
    }
    void DrawArc(int i,int j,int mode,int inroad){//画边;mode=0,无向;mode=1,有向,i到j;inroad=1则换一种颜色画边
        if(!inroad){
            setlinestyle(PS_SOLID,3);//设置线型线宽
            setlinecolor(RGB(0,196,166));//设置线颜色
        }
        else{
            setlinestyle(PS_SOLID,4);//设置线型线宽
            setlinecolor(RGB(255,250,28));//设置线颜色
        }
        settextstyle(23, 0, _T(&quot;Arial&quot;),0,0,FW_BOLD,0,0,0);//设置字体，大小，粗细
        TCHAR tw[10]={};

        _stprintf_s(tw,_T(&quot;%d&quot;),g.arcs[i][j].w);//即使对于无向图也通用，因为arcs[i][j]和arcs[j][i]一样

        if(!mode){//无向图，直接连线
            line(g.vexs[i].x,g.vexs[i].y,g.vexs[j].x,g.vexs[j].y);
            outtextxy((g.vexs[i].x+g.vexs[j].x)/2,(g.vexs[i].y+g.vexs[j].y)/2,tw);
        }
        else{//有向图，画边时两个方向的线需要错开，不重叠，并且带箭头
            double a=GetAngle(g.vexs[i].x,g.vexs[i].y,g.vexs[j].x,g.vexs[j].y);//从顶i到j的向量的方位角
            double da=30.0/180.0*PI;//30度角对应的弧度,
            int x1=g.vexs[i].x+cos(a-da)*VEXRADIUS,y1=g.vexs[i].y+sin(a-da)*VEXRADIUS;
            int x2=g.vexs[j].x+cos(a+da-PI)*VEXRADIUS,y2=g.vexs[j].y+sin(a+da-PI)*VEXRADIUS;
            line(x1,y1,x2,y2);//画i到j的边的直线,下面画箭头

            double len1_2=sqrt(pow((long double)(g.vexs[i].x-g.vexs[j].x),2)+pow((long double)(g.vexs[i].y-g.vexs[j].y),2))/2;//该边1/2长
            int arrx=x1+len1_2*cos(a),arry=y1+len1_2*sin(a);//箭头端点所在坐标
            double db=2.617994;//150度角对应的弧度
            line(arrx,arry,arrx+cos(a-db)*ARROWLEN,arry+sin(a-db)*ARROWLEN);//箭头一侧边
            line(arrx,arry,arrx+cos(a+db)*ARROWLEN,arry+sin(a+db)*ARROWLEN);//箭头一侧边
        outtextxy((x1+x2)/2,(y1+y2)/2,tw);
    }
}
void DrawMGraph(){
    clearcliprgn();//清空绘图区
    int i,j;

    for(i=0;i&lt;g.vexnum;i++){//先画边，再画顶不然边会部分叠在顶上
        for(j=0;j&lt;g.vexnum;j++){
            if(g.arcs[i][j].w) DrawArc(i,j,MODE,0);
        }
    }
    for(i=0;i&lt;g.vexnum;i++){
        DrawVex(i);
    }
}

void OnButtonClick(int i){
    FILE* fp;
    TCHAR filename[32]=_T(&quot;test&quot;);
    TCHAR filepath[256];
    switch(i){
        case 1:    MessageBox(GetHWnd(),_T(\
&quot;1.点击空白处添加新顶.\n2.在某顶上按住右键可移动该顶.\n3.左键单击某个顶可以选中.\n4.选中某顶后,ctrl+左键单击另一顶可添加边.\n5.选中某顶后,shift+左键单击另一顶可求最短路径.&quot;\
),_T(&quot;Help&quot;),MB_OK|MB_ICONINFORMATION);
                break;

        case 2:    if(InputBox(filename,32,_T(&quot;文件将保存在当前运行目录下，无向图后缀名为.udg，有向图后缀名为.dg\n请输入文件名(不带后缀名):&quot;),_T(&quot;保存文件&quot;),(LPCTSTR)filename,0,0,0)){
                    _stprintf_s(filepath,_T(&quot;%s%s%s&quot;),runpath,filename,MODE?_T(&quot;.dg&quot;):_T(&quot;.udg&quot;));//生成保存路径

                    if(!_tfopen_s(&amp;fp,filepath,_T(&quot;wb+&quot;))){
                        fwrite(&amp;g,sizeof(g),1,fp);
                        fclose(fp);
                        MessageBox(GetHWnd(),_T(&quot;导出成功！&quot;),_T(&quot;提示&quot;),MB_OK|MB_ICONINFORMATION);
                    }
                    else{
                        MessageBox(GetHWnd(),_T(&quot;文件不存在！！&quot;),_T(&quot;错误&quot;),MB_OK|MB_ICONWARNING);
                    }
                }
                break;
        case 3:    if(InputBox(filename,32,_T(&quot;将打开当前运行目录下的文件，无向图后缀名为.udg，有向图后缀名为.dg\n请输入文件名(不带后缀名):&quot;),_T(&quot;打开文件&quot;),(LPCTSTR)filename,0,0,0)){
                    _stprintf_s(filepath,_T(&quot;%s%s%s&quot;),runpath,filename,MODE?_T(&quot;.dg&quot;):_T(&quot;.udg&quot;));//生成保存路径
                    //MessageBox(GetHWnd(),filepath,_T(&quot;aaa&quot;),MB_OK|MB_ICONINFORMATION);
                    if(!_tfopen_s(&amp;fp,filepath,_T(&quot;rb+&quot;))){
                        fread(&amp;g,sizeof(g),1,fp);
                        fclose(fp);
                        DrawMGraph();
                    }
                    else{
                        MessageBox(GetHWnd(),_T(&quot;文件不存在！！&quot;),_T(&quot;错误&quot;),MB_OK|MB_ICONWARNING);
                    }
                }
                break;
        case 4:    MessageBox(GetHWnd(),_T(&quot;ShortestPaths V1.0\nCode by LinXiang(PB16020923)&quot;),_T(&quot;About&quot;),MB_OK|MB_ICONINFORMATION);
                break;
    }
}
int IsInRange(int a,int up,int down){
    return a&lt;=up &amp;&amp; a&gt;=down;
}
int GetPosInVex(int x,int y){//获取当前坐标下的顶下标，没有返回-1
    int i,xu=x+VEXRADIUS,xd=x-VEXRADIUS,yu=y+VEXRADIUS,yd=y-VEXRADIUS;
    //反过来判断某个顶在不在x,y范围内，这样节省计算，不用算每个顶边界
    for(i=0;i&lt;g.vexnum;i++){
        if(IsInRange(g.vexs[i].x,xu,xd) &amp;&amp; IsInRange(g.vexs[i].y,yu,yd)) return i;
    }
    return -1;
}
void SetVexSelected(int i){
    g.vexs[i].state=1;
    DrawVex(i);//更新为选中状态
    vsel=i;//记下当前选中顶
}
void SetVexNoSelected(){
    g.vexs[vsel].state=0;
    DrawVex(vsel);//更新为正常选中状态
    vsel=-1;//
}
void GetRunPath(TCHAR *text,TCHAR *path){//获取当前运行路径
    int pos;//最后一个\的位置 
    int i=0;
    while(*(text+i)){
        if(*(text+i)==&#39;\\&#39;) pos=i;
        i++;
    }
    _tcscpy_s(path,256,text);
    path[pos+1]=0;
}
int _tmain(int argc,TCHAR *argv[])
{
    GetRunPath(argv[0],runpath);

    if(IDYES==MessageBox(GetHWnd(),_T(&quot;选择‘是’为进入 有向图 模式，\n选择‘否’为进入 无向图 模式。&quot;),_T(&quot;选择模式&quot;),MB_YESNO|MB_ICONQUESTION))
        MODE=1;
    else MODE=0;
    InitUI();
    CreateGraph(&amp;g);
    while(true){
        MOUSEMSG m = GetMouseMsg();// 获取一条鼠标消息
        switch(m.uMsg){
            int vi;
            case WM_MOUSEMOVE://移动
                if(vmov!=-1){
                    g.vexs[vmov].x=m.x;
                    g.vexs[vmov].y=m.y;
                    DrawMGraph();//重绘全部
                }
                break;
            case WM_RBUTTONDOWN://右键按下，开始移动 
                vi=GetPosInVex(m.x,m.y);
                if(vi!=-1)
                    vmov=vi;
                break;
            case WM_RBUTTONUP://右键弹起，结束移动 
                if(vmov!=-1)
                    vmov=-1;
                break;
            case WM_LBUTTONDOWN://按下左键
                if(m.mkCtrl){//同时按下CTRL
                    vi=GetPosInVex(m.x,m.y);
                    if(vi!=-1 &amp;&amp; vsel!=-1 &amp;&amp; vi!=vsel){//按下ctrl选择了一顶，并且之前已经选中一顶，而且两顶不同，则添新边
                        TCHAR tn[10]=_T(&quot;1&quot;);
                        if(InputBox(tn,128,_T(&quot;Input a arc weight&quot;),_T(&quot;Add a arc&quot;),(LPCTSTR)tn,0,0,0)){//输入了权

                            if(!MODE){//无向图
                                g.arcs[vi][vsel].w=g.arcs[vsel][vi].w=_ttoi(tn);
                                DrawArc(vsel,vi,MODE,0);
                            }
                            else{//有向图
                                g.arcs[vsel][vi].w=_ttoi(tn);
                                DrawArc(vsel,vi,MODE,0);
                            }

                        }
                    }
                }
                else if(m.mkShift){//同时按下SHIFT
                    vi=GetPosInVex(m.x,m.y);
                    if(vi!=-1 &amp;&amp; vsel!=-1 &amp;&amp; vi!=vsel){//按下ctrl选择了一顶，并且之前已经选中一顶，而且两顶不同，则求最短路径
                        DrawMGraph();//重绘全部,避免图中有画过其他路径
                        DijRes r=Dijkstra(g,vsel);//求出vel到各顶最短路径
                        int tmp=vi;//倒推路径，先画边
                        while(r.prev[tmp]!=-1){
                            DrawArc(r.prev[tmp],tmp,MODE,1);
                            tmp=r.prev[tmp];
                        }
                        tmp=vi;//倒推路径，再画顶
                        while(tmp!=-1){
                            DrawVex(tmp);
                            tmp=r.prev[tmp];
                        }
                    }
                }
                else{//仅仅按下左键
                    if(m.x&lt;CONTROLWIDTH){//控制区
                        if(m.y%(SPACE+BUTTONHEIGHT)&gt;SPACE)
                            OnButtonClick(m.y/(SPACE+BUTTONHEIGHT)+1);
                    }
                    else{//绘图区
                        int vi=GetPosInVex(m.x,m.y);
                        if(vi!=-1){//按下了某个顶
                            if(vsel!=-1) //如果有选中的，先取消选中状态
                                SetVexNoSelected();
                            SetVexSelected(vi);
                        }
                        else{//按下了空白区域
                            if(vsel!=-1){//如果有选中的，取消选中状态
                            SetVexNoSelected();
                            break;
                        }

                        //以下添加新顶
                                //TCHAR根据是否有UNICODE宏分别对应char和wchar_t
                                //tn相当于TCHAR* 也就是LPTSTR
                        TCHAR tn[MAX_NAME]=_T(&quot;0&quot;);
                        tn[0]+=g.vexnum;
                        if(InputBox(tn,128,_T(&quot;Input a name:&quot;),_T(&quot;Add a vex&quot;),(LPCTSTR)tn,0,0,0)){
                                //_T将字符串常量转为unicode版本，(LPCTSTR)把字符串变量转为常量
                            InsertVex(&amp;g,tn,m.x,m.y);
                            DrawVex(g.vexnum-1);
                        }
                    }
                }
            }
            break;
        }
    }
    closegraph();// 关闭绘图窗口
    return 0;
}
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DS/">DS</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ds/lab3_Haffman" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/11/ds/lab3_Haffman/" class="article-date">
      <time datetime="2017-11-10T16:00:00.000Z" itemprop="datePublished">2017-11-11</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/11/ds/lab3_Haffman/">数据结构上机题3 哈夫曼压缩</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="哈夫曼压缩"><a href="#哈夫曼压缩" class="headerlink" title="哈夫曼压缩"></a>哈夫曼压缩</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实验三: 此次实验限定语言C/C++，允许使用stl。</p>
<p>ddl：下下周六（11月19日）。</p>
<p>实验要求：实现任意二进制文件压缩解压。将哈夫曼树或者词频率表保存到文件，压缩后解压所需信息全部从你自己压缩得到的文件中拿到。检查:对于一般txt文档实现效果明显的压缩结果并正确解压7分，大文件（几十兆以上）非文本文件正确压缩解压。（9分）报告1分。本周六实验一和二未检查完的来检查，下周六实验三写好的可以提前来检查。下下周六ddl</p>
<h2 id="一、-需求分析"><a href="#一、-需求分析" class="headerlink" title="一、    需求分析"></a>一、    需求分析</h2><ol>
<li><p>实现功能：</p>
<p>（1）    利用Haffman编码压缩文件。打开文件后扫描文件读入数据，以二进制方式读取，每次处理8位（1个字节），八位二进制码有256种组合，对应ascii码中0-255的字符，读取结束后，统计出字符频率表并降序排序，根据字符频率表创建Haffman树，导出Haffman编码，之后再次扫描文件，将每个字符对应的Haffman编码依次写入目标文件，完成压缩。</p>
<p>（2）    解压本程序创建的压缩文件。打开文件后扫描文件读入数据，以二进制方式读取，首先读取创建压缩文件是存储在文件头的字符频率表或者Haffman树，然后读取压缩数据，设置一个缓存空间buf，每次处理1位的数据，查找Haffman编码对应的字符，输出至目标文件，完成解压。</p>
<p>（3）    通过修改Windows注册表设置右键菜单快捷方式来打开本程序，以便传入要处理的文件路径。</p>
</li>
<li><p>模块化设计，创建词频表和Haffman树两种数据结构。</p>
</li>
<li><p>采用main函数的参数传入要压缩或者解压的文件路径，然后处理文件并显示处理界面。如果没有传入任何文件路径，则显示设置界面。</p>
</li>
<li><p>处理界面上显示当前处理过程（解压/压缩）、处理的文件名、文件大小，实时输出处理的进度、已花时间和剩余时间。</p>
</li>
<li><p>测试数据：选取几种代表性的文件：</p>
<p>（1）    文本文件，实现较明显的压缩。</p>
<p>（2）    可执行文件和较大的二进制文件，实现正确的解压缩，解压缩前后文件一致，能正确打开执行或访问。</p>
</li>
</ol>
<h2 id="二、-概要设计"><a href="#二、-概要设计" class="headerlink" title="二、    概要设计"></a>二、    概要设计</h2><ol>
<li><p>抽象数据类型词频表定义如下：</p>
<pre><code>ADT FrequencyList{
    数据对象：Frequency={ch,f|0&lt;=ch&lt;=255,f&gt;=0}
              FrequencyList={Frequency}
    数据关系：无
    基本操作：    
        CreateFrequencyListFromFile(&amp;file,&amp;fl);
            初始条件：文件file存在且被打开。
            操作结果：从文件数据创建词频表fl。
        SaveFrequencyListToFile(&amp;file,fl);
            初始条件：词频表fl存在，文件file存在且被打开。
            操作结果：保存词频表fl到文件file中。
        LoadFrequencyListFromFile(&amp;file,&amp;fl);
            初始条件：文件file存在且被打开，文件file是按
CreateFrequencyListFromFile方法创建的文件。
            操作结果：从文件数据载入存储的词频表fl。 
}ADT FrequencyList
</code></pre></li>
<li><p>抽象数据类型哈夫曼树定义如下：</p>
<pre><code>ADT HaffmanTree{
    数据对象：HaffmanTreeNode={lchild,rchild,parent,ch,f}
              HaffmanTree={HaffmanTreeNode}
    数据关系：每个节点指向左右两个孩子节点（如果有的话）
    基本操作：
        CreateHaffmanTreeFromFrequencyList(fl,&amp;ht);
            初始条件：词频表fl存在。
            操作结果：从词频表fl创建哈夫曼树ht。
        CreateHaffmanCode(ht,&amp;haffmancode);
            初始条件：Haffman树ht存在。
            操作结果：根据哈夫曼树ht生成哈夫曼编码haffmancode。  
}ADT HaffmanTree
</code></pre></li>
<li><p>主函数，压缩函数，解压函数的实现框架</p>
<p><code>`</code><br>//以下代码是实现框架，不保证细节完备，详情请看后附源代码<br>int main(int argc,char *argv[]){</p>
<pre><code>界面初始化;
if(argc&gt;1){
    根据argv[1]的文件路径获取文件名FILENAME;
    获取文件大小FILESIZE;
    判断文件类型FILETYPE;
</code></pre></li>
</ol>
<p>   ​<code>`</code><br>       绘制文件处理界面;</p>
<pre><code>   计时开始，记录time_begin; 
   if(FILETYPE==0){
       HaffmanCompress压缩;
   }
   else{
       HaffmanDecompress解压;
   }
</code></pre><p>   }<br>   else{<br>       绘制设置界面;<br>       for(;;){<br>           读取鼠标信息;<br>           if (鼠标点击){<br>               设置右键;<br>           }<br>       }<br>   }<br>   输出完成信息;<br>   ​<code>`</code></p>
<p>   }<br>   Status HaffmanCompress(当前文件,目标文件,哈夫曼编码表,当前文件总长度){//压缩<br>       while(读取文件每次n字节 &amp;&amp; 文件没有结束){//<br>           for(i=0;i&lt;n;i++){<br>               获取该字节对应的哈夫曼编码;<br>               while(哈夫曼编码指针){<br>                   缓存左移一位;<br>                   缓存最低位存哈夫曼编码的当前位;<br>                   哈夫曼编码指针++;<br>                   缓存长度++;<br>                   if(缓存达到输出长度){<br>                       缓存长度=0;<br>                       把缓存写到文件;<br>                   }<br>               }<br>               进度++;<br>               刷新显示进度;<br>           }<br>       }<br>       while(缓存长度不足指定长度){<br>           文件尾补足长度;<br>       }<br>       把缓存写到文件;<br>       return OK;<br>   }<br>   Status HaffmanDecompress(当前文件,目标文件,哈夫曼树){//解压<br>       读取目标文件总长度bytenum;<br>       htn=哈夫曼树根结点;<br>       while(k&lt;总长度){<br>           读取一定长度数据写入缓存inbuf;<br>           do{<br>               取缓存inbuf最高位b;<br>               缓存inbuf左移一位;<br>               if(b==0){<br>                   htn=htn-&gt;lchild;<br>               }<br>               else{<br>                   htn=htn-&gt;rchild;<br>               }<br>               if(htn左孩子和右孩子都是空){//到达叶结点<br>                   输出叶上的字符到缓存outbuf;<br>                   if(outbuf到一定长度){<br>                       写出缓存outbuf到目标文件;<br>                   }<br>                   计数k++;<br>                   if(k==bytenum) break;<br>                   回根结点;<br>               }<br>           }while(缓存inbuf还没处理完);<br>           刷新显示进度;<br>       }<br>       return OK;<br>   }</p>
<pre><code>
4. 本程序含四个模块

   (1)    主模块
   (2)    词频表模块
   (3)    哈夫曼树、编码和解压缩模块
   (4)    图形界面模块

![](lab3_Haffman/0.png)





## 三、    详细设计
1．    词频结点类型

```c
typedef struct Frequency{//一个字符(8位)及其出现频次 
    unsigned char ch;//0&lt;=ch&lt;=255
    unsigned int f;
}fre,*pfre;
</code></pre><p>2．    词频表类型</p>
<pre><code>typedef struct FrequencyList{//频度表，所有出现的字符及频次
    int num;//1&lt;=num&lt;=256
    pfre list; //频度表数组，动态申请 
}frelist,*pfrelist;
</code></pre><p>3．    哈夫曼树类型</p>
<pre><code class="c">typedef struct HaffmanTreeNode{
    struct HaffmanTreeNode *lchild,*rchild,*parent;
    unsigned int f;
    unsigned char ch;
}htreenode,*htree;
</code></pre>
<p>4．    词频表操作</p>
<pre><code class="c">Status CreateFrequencyListFromFile(FILE *fp,pfrelist *fl);
    //从任意文件中创建频度表 
Status SaveFrequencyListToFile(FILE *fp,pfrelist fl);
    //保存频度表到压缩文件中 
Status LoadFrequencyListFromFile(FILE *fp,pfrelist *fl);
//从压缩文件中读取频度表
</code></pre>
<p>5．    哈夫曼树操作及解压缩</p>
<pre><code class="c">Status CreateHaffmanTreeFromFrequencyList(pfrelist fl,htree* ht){
//从频度表创建哈夫曼数，频度表保证至少两种字符 
Status PreOrderTraverse(htree ht,int child,int i,char code[],char haffmancode[256][256]){
//先序遍历，child=0表示当前是左孩子，child=1表示当前是右孩子
//i为当前层次,code为当前遍历路径已存编码，haffmancode是编码表 
Status CreateHaffmanCode(htree ht,char haffmancode[256][256]){
//创建编码表haffmancode[256][256],牺牲一些空间以便快速索引
Status HaffmanCompress(FILE *fp1,FILE *fp2,char haffmancode[256][256],unsigned int bytenum){
//压缩,bytenum为总长度 
Status HaffmanDecompress(FILE *fp1,FILE *fp2,htree ht){
//解压,解压时直接用哈夫曼树搜索对应字符 
</code></pre>
<p>6．    图形界面操作</p>
<pre><code>SMALL_RECT UI_SetRect(int left,int top,int right,int bottom);
//根据坐标取返回对应矩形区域数据 
void UI_SetConsoleWindowSize(HANDLE hOut,int width,int height);
//设置窗口大小
void UI_SetConsoleScreenBufferSize(HANDLE hOut,int width,int height);
//设置缓冲区大小
void UI_InitSTDHandle(HANDLE *hOut,CONSOLE_SCREEN_BUFFER_INFO *bInfo,int width,int height);
//初始化 
void UI_DrawText(HANDLE hOut,WORD attr,char *text,int len,int row,int left,int right);
//在指定行左右位置之间居中输出一行文本
void UI_CleanText(HANDLE hOut,int row,int left,int right);
//在指定行左右位置之间清除一行文本
void UI_CleanTextRect(HANDLE hOut,int top,int bottom,int left,int right);
//在指定区域之间清除文本
void UI_DrawBox(HANDLE hOut,int bSingle,SMALL_RECT rc,WORD attr);
//画方框 
void ClearScreen(HANDLE hOut,DWORD att){
//清屏，且设置样式
</code></pre><p>7．    其他函数</p>
<pre><code>void GetCompressedFilePath(char *FPath,char *CFPath);
//从传入的路径求得对应压缩文件路径 
void GetDecompressedFilePath(char *FPath,char *DFPath);
//从传入的压缩文路径求得对应解压文件路径 
void GetFileNameFromPath(char *FPath,char *FName);
//从路径中提取文件名
long GetFileSizeFromPath(char *FPath);
//获取文件大小 
int GetFileTypeFromPath(char *FPath);
//判断文件类型是解压(1)还是压缩(0)
void UIInit();
//UI初始化 
void DrawAllBox();
//绘制所有方框 
void DrawInfoText(char *filename,int type,int size);
//显示文件名，类型是解压(1)还是压缩(0)
void UpdateTimeText(double progress);
//根据进度(0-1)更新剩余时间 
void DrawSelect(int select);
//没有文件传入时显示配置界面,select=1表示已选中，即当前已创建右键菜单
int CheckKey();
//检查右键菜单注册表是否已设置 
void SetKey(char *exepath);
//设置或取消右键菜单注册表 
int Compress(char *fpath);
//预处理及压缩 
int Decompress(char *fpath);
//预处理及解压 
</code></pre><p>8．    具体的函数实现见附录，均有详细注释，此处不再赘述。</p>
<h2 id="四、-调试分析"><a href="#四、-调试分析" class="headerlink" title="四、    调试分析"></a>四、    调试分析</h2><p>1．    本程序的难点在于哈夫曼树的创建、存储、读取、匹配。<br>2．    本程序选择存储词频表而不是哈夫曼树，在解压时读取词频表重新创建哈夫曼树，文件结构如下图。</p>
<p><img src="//l-x.me/2017/11/11/ds/lab3_Haffman/1.png" alt="">   </p>
<p>FileTypeMark位于文件头，标记了“#HAFFMANCOMPRESSFILE#”，以供解压时识别为压缩文件。之后的一段数据FrequencyList 存放了字符频率表，表头记录出现了字符类型总数，之后为各个字符及其频度。最后的部分存放了经过哈夫曼编码后的原文件数据，头部记录了原文件的长度。</p>
<p>3．    在文件的读取和存储上，设置一个读写缓存，每次读入一定的字节数，然后进行处理，而不是每次读入一个字节，这样效率太低，写出时同理。</p>
<p>4．    解压时重建哈夫曼树后，不要再次导出哈夫曼编码，每次读取一位二进制数据，直接搜索哈夫曼树，是0则跳转左孩子，是1则跳转右孩子。</p>
<p>5．    空文件和只有一种字符时应该单独考虑，哈夫曼树不能处理。</p>
<p>6．    之前在压缩时每次存入4个字节（32位），若文件尾不是整字节，补足为整字节（8位的倍数），看似没有问题，但是在读取时仍按4字节读取存入unsigned int，末尾的数据若非刚好为4个字节（低位为空），则读入时有效数据会被存入unsigned int的低位（int存储时先存入了低8-1位，再存16-9位…以此类推），造成错误。</p>
<p>7．    关于fread，若不考虑返回值，fread(buf,size,count,fp)，size和count的值可互换，只要size*count是需要读取的字节数即可。但是如果想知道实际读取了多少字节，比如一次读入1024字节，应该写为fread(buf,1,1024,fp)，当剩余数据不足1024时，会返回实际读取的count数，在这里就是字节数。若写为fread(buf,1024,1,fp)，当剩余数据超过1024时，返回1024，当剩余数据不足1024时，将返回0(虽然buf中会存有实际读取的数据)。</p>
<p>8．    还是fread的问题，传统情况下为了避免最后一个字节使用了两次，采用while(fread(buf,1,1,fp) &amp;&amp; !feof(fp)) 因为fread读完最后一个字节后，feof仍然不变，再次fread才触发feof。这里一次读取一个字节，fread(buf,1,1,fp)的返回值只会是0和1，即使读取最后一个字节也为1，再次读取才0，因此while中用&amp;&amp;没有问题，两个条件只会同为0或同为1。如果一次读取多个字节（比如1024），在文件总长度为1024的倍数时，和上述情况没有区别，若非1024倍数，最后一次读取fread将返回实际读取数量(&lt;1024)，但是此时已经触发feof（因为最后一次读取是没有满足fread的请求的，这里的逻辑很微妙）,故while中&amp;&amp;应该改用||。</p>
<p>9．    在界面更新问题上，编写了一个更新显示进度函数，直接在压缩/解压函数中调用。</p>
<h2 id="五、-用户手册"><a href="#五、-用户手册" class="headerlink" title="五、    用户手册"></a>五、    用户手册</h2><p><img src="//l-x.me/2017/11/11/ds/lab3_Haffman/2.png" alt=""></p>
<p><img src="//l-x.me/2017/11/11/ds/lab3_Haffman/3.png" alt=""></p>
<h2 id="六、-测试结果"><a href="#六、-测试结果" class="headerlink" title="六、    测试结果"></a>六、    测试结果</h2><ol>
<li>一个文本文件“四大名著.txt”（原大小 6,321,865字节，压缩后4,827,905字节，压缩率75%），一个可执行文件（压缩率77%），实现明显的压缩。</li>
<li>和一份pdf文档实现正确解压缩，但压缩效果不明显（压缩率99%），解压缩前后md5值不变。</li>
<li>解压缩时间在可接受的范围内，约16MB/s.</li>
</ol>
<p><img src="//l-x.me/2017/11/11/ds/lab3_Haffman/4.png" alt=""><br><img src="//l-x.me/2017/11/11/ds/lab3_Haffman/5.png" alt=""><br><img src="//l-x.me/2017/11/11/ds/lab3_Haffman/6.png" alt=""><br><img src="//l-x.me/2017/11/11/ds/lab3_Haffman/7.png" alt=""><br><img src="//l-x.me/2017/11/11/ds/lab3_Haffman/8.png" alt="">   </p>
<h2 id="七、-附录"><a href="#七、-附录" class="headerlink" title="七、    附录"></a>七、    附录</h2><p>源程序文件清单：</p>
<p>（1）    FrequencyList.h</p>
<p>（2）    HaffmanTree.h</p>
<p>（3）    MyUI.h</p>
<p>（4）    Hzip.c</p>
<p>FrequencyList.h</p>
<pre><code>/*
    Last Update time: 2017-11-01 
    Version：1.0
    Author：LinXiang (PB16020923) 
    Description：
        FrequencyList.
*/
#ifndef FREQUENCYLIST_H
#define FREQUENCYLIST_H
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define OK 1
#define ERROR 0
typedef int Status;  
typedef struct Frequency{//一个字符(8位)及其出现频次 
    unsigned char ch;//0&lt;=ch&lt;=255
    unsigned int f;
}fre,*pfre;
typedef struct FrequencyList{//频度表，所有出现的字符及频次
    int num;//1&lt;=num&lt;=256
    pfre list; //频度表数组，动态申请 
}frelist,*pfrelist;
int frecmp(const void *a,const void *b){
    pfre aa=(pfre)a;
    pfre bb=(pfre)b;
    return (int)(bb-&gt;f-aa-&gt;f);//b-a这样才能让qsort降序排列 
}
void UpdateTimeText(double progress);//声明以便下面函数调用更新进度 
Status CreateFrequencyListFromFile(FILE *fp,pfrelist *fl){//从任意文件中创建频度表 
    fre arr[256]={};//临时存放所有字符，直接按下标存入更方便，不用插入或遍历 
    unsigned char buf[1048576]={};//当前读入缓存 
    int i,n; //n表示实际读入的字符数，仅在文件尾时不是1024 
    while((n=fread(buf,1,1048576,fp)) || !feof(fp)){//读取文件每次1024字节，
    //注意size=1,count=1024,才能知道实际成功读入字节数(fread返回值),不要反过来,反过来的话一旦不满1024，fread返回值将为0 
        for(i=0;i&lt;n;i++){
            arr[buf[i]].ch=buf[i];
            arr[buf[i]].f++;
        }
    }
    qsort(arr,256,sizeof(fre),&amp;frecmp);//排序，不出现的字符会被排至尾部 
    *fl=(pfrelist)malloc(sizeof(frelist));//让fl存放指向frelist的指针 
    for(i=0;i&lt;256;i++){//统计出现的字符数量 
        if(arr[i].f==0) break; 
    }
    (*fl)-&gt;num=i;
    (*fl)-&gt;list=(pfre)malloc(sizeof(fre)*((*fl)-&gt;num));//申请频度表的数组空间 
    for(i=0;i&lt;(*fl)-&gt;num;i++){
        (*fl)-&gt;list[i].ch=arr[i].ch; 
        (*fl)-&gt;list[i].f=arr[i].f;
    }
    return OK;
}
Status SaveFrequencyListToFile(FILE *fp,pfrelist fl){//保存频度表到压缩文件中 
    fwrite(&amp;(fl-&gt;num),4,1,fp);
    int i;  
    for(i=0;i&lt;fl-&gt;num;i++){
        fwrite(&amp;(fl-&gt;list[i].ch),1,1,fp);
        fwrite(&amp;(fl-&gt;list[i].f),4,1,fp);
    }
    return OK; 
}
Status LoadFrequencyListFromFile(FILE *fp,pfrelist *fl){//从压缩文件中读取频度表
    *fl=(pfrelist)malloc(sizeof(frelist));//让fl存放指向frelist的指针 
    fread(&amp;((*fl)-&gt;num),4,1,fp);
    (*fl)-&gt;list=(pfre)malloc(sizeof(fre)*((*fl)-&gt;num));//申请频度表的数组空间 
    int i;  
    for(i=0;i&lt;(*fl)-&gt;num;i++){
        fread(&amp;((*fl)-&gt;list[i].ch),1,1,fp);
        fread(&amp;((*fl)-&gt;list[i].f),4,1,fp);
    }
    return OK; 
}
#endif
</code></pre><p>HaffmanTree.h</p>
<pre><code class="c">/*
    Last Update time: 2017-11-01 
    Version：1.0
    Author：LinXiang (PB16020923) 
    Description：
        HaffmanTree.
*/
#ifndef HAFFMANTREE_H
#define HAFFMANTREE_H
#define OK 1
#define ERROR 0
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &quot;FrequencyList.h&quot;
typedef int Status; 
typedef struct HaffmanTreeNode{
    struct HaffmanTreeNode *lchild,*rchild,*parent;
    unsigned int f;
    unsigned char ch;
}htreenode,*htree;
void UpdateTimeText(double progress);//声明以便下面函数调用更新进度 
Status CreateHaffmanTreeFromFrequencyList(pfrelist fl,htree* ht){
//从频度表创建哈夫曼数，频度表保证至少两种字符 
    int hfn=fl-&gt;num*2-1;//haffmantreenode个数
    htreenode *arr=(htreenode *)malloc(sizeof(htreenode)*hfn);
    int i,t;
    for(i=0;i&lt;fl-&gt;num;i++){//前 fl-&gt;num 个放叶结点 
        t=fl-&gt;num-i-1;//使升序排列 
        arr[t].ch=fl-&gt;list[i].ch;
        arr[t].f=fl-&gt;list[i].f;
        arr[t].lchild=NULL;
        arr[t].rchild=NULL;
        arr[t].parent=NULL;
    }
    int j,k;
    for(j=i,k=0;i&lt;hfn;i++){
        arr[i].f=0;//权值初始为0 
        //先选择最小的一个做左孩子 
        if(i-j&gt;=1 &amp;&amp; fl-&gt;num-k&gt;=1){//叶结点和非叶结点都至少有一个可选 
            if(arr[k].f&lt;=arr[j].f){
                arr[i].lchild=&amp;arr[k];
                arr[k].parent=&amp;arr[i];
                arr[i].f+=arr[k].f; 
                k++;
            }
            else{
                arr[i].lchild=&amp;arr[j];
                arr[j].parent=&amp;arr[i];
                arr[i].f+=arr[j].f; 
                j++;
            }
        }
        else if(fl-&gt;num-k&gt;=1){//只有叶结点可选 
            arr[i].lchild=&amp;arr[k];
            arr[k].parent=&amp;arr[i];
            arr[i].f+=arr[k].f; 
            k++;
        }
        else{//只有非叶结点可选 
            arr[i].lchild=&amp;arr[j];
            arr[j].parent=&amp;arr[i];
            arr[i].f+=arr[j].f; 
            j++;
        } 

        //再选择最小的一个做右孩子 
        if(i-j&gt;=1 &amp;&amp; fl-&gt;num-k&gt;=1){//叶结点和非叶结点都至少有一个可选 
            if(arr[k].f&lt;=arr[j].f){
                arr[i].rchild=&amp;arr[k];
                arr[k].parent=&amp;arr[i];
                arr[i].f+=arr[k].f;
                k++;
            }
            else{
                arr[i].rchild=&amp;arr[j];
                arr[j].parent=&amp;arr[i];
                arr[i].f+=arr[j].f;
                j++;
            }
        }
        else if(fl-&gt;num-k&gt;=1){//只有叶结点可选 
            arr[i].rchild=&amp;arr[k];
            arr[k].parent=&amp;arr[i];
            arr[i].f+=arr[k].f;
            k++;
        }
        else{//只有非叶结点可选 
            arr[i].rchild=&amp;arr[j];
            arr[j].parent=&amp;arr[i];
            arr[i].f+=arr[j].f;
            j++;
        }
    }
    *ht=&amp;arr[hfn-1];//指向根 
    return OK; 
}
Status PreOrderTraverse(htree ht,int child,int i,char code[],char haffmancode[256][256]){
//先序遍历，child=0表示当前是左孩子，child=1表示当前是右孩子,i为当前层次,code为当前遍历路径已存编码，haffmancode是编码表 
    if(ht==NULL) return ERROR;
    code[i]=child+&#39;0&#39;;
    if(ht-&gt;lchild==NULL &amp;&amp; ht-&gt;rchild==NULL){//这是个叶结点  
        strcpy(haffmancode[ht-&gt;ch],code);//把当前编码保存到编码表里 
    }
    else{
        PreOrderTraverse(ht-&gt;lchild,0,i+1,code,haffmancode);
        PreOrderTraverse(ht-&gt;rchild,1,i+1,code,haffmancode);
    }
    code[i]=0;//恢复
    return OK; 
} 
Status CreateHaffmanCode(htree ht,char haffmancode[256][256]){
//编码表haffmancode[256][256]牺牲一些空间以便快速索引
    char code[256]={};//临时存放编码 
    PreOrderTraverse(ht-&gt;lchild,0,0,code,haffmancode);
    PreOrderTraverse(ht-&gt;rchild,1,0,code,haffmancode);
    return OK;
}
Status HaffmanCompress(FILE *fp1,FILE *fp2,char haffmancode[256][256],unsigned int bytenum){
//压缩,bytenum为总长度 
    unsigned char inbuf[262144]={};//当前读入 
    unsigned int outbuf=0;//操作的缓存，满32位(4字节)才写入outbuf2，这个缓存主要用于位操作 
    unsigned int outbuf2[262144]={};//输出的缓存1024*4字节 
    fwrite(&amp;bytenum,4,1,fp2);//记下总长度 
    int up=bytenum/100;//设置界面更新间隔
    if(up==0) up=1; //文件过小，界面更新间隔为0，置1 
    int cnt=0;//循环计数器，缓存输出用的 
    unsigned int k=0;//计数器，更新界面用的
    int cnt2=0; //循环计数器，缓存输出用的
    int i,n=0;
    while((n=fread(inbuf,1,262144,fp1)) || !feof(fp1)){//读取文件每次262144字节
        for(i=0;i&lt;n;i++){   
            char *p=haffmancode[inbuf[i]];
            while(*p){
                outbuf&lt;&lt;=1;//左移一位 
                outbuf | = (*p-&#39;0&#39;);//最低位存p
                p++;
                cnt++;
                if(cnt%32==0){//满8位输出 
                    cnt=0;
                    outbuf2[cnt2++]=outbuf;
                    outbuf=0;
                    if(cnt2==262144){
                        cnt2=0;
                        fwrite(outbuf2,4,262144,fp2);
                        memset(outbuf2,0,262144*4);
                    }
                } 
            }
            k++;
            if(k%up==0) UpdateTimeText((double)k/(double)bytenum);
        }
    }
    while(cnt%32!=0){//文件尾补足为32位的整数倍 
        outbuf&lt;&lt;=1;
        cnt++;
    }
    outbuf2[cnt2++]=outbuf;
    fwrite(outbuf2,4,cnt2,fp2);
    return OK;
}
Status HaffmanDecompress(FILE *fp1,FILE *fp2,htree ht){//解压,解压时直接用哈夫曼数搜索对应字符 
    unsigned int inbuf=0;//输入的缓存，每次读取32位(4字节)
    unsigned char outbuf=0;//输出缓存（1字节） 
    unsigned char outbuf2[1048576]={};//输出缓存2（1048576字节） 
    unsigned int bytenum;//总字节数 
    unsigned int k=0; 
    int cnt=0;
    int b;
    htreenode* htn=ht;
    fread(&amp;bytenum,4,1,fp1);//读取总长度 
    int up=bytenum/100;//设置界面更新间隔
    if(up==0) up=1; //文件过小，界面更新间隔为0，置1 
    int cnt2=0;
    while(k&lt;bytenum){
        fread(&amp;inbuf,1,4,fp1);//size=1,count=4
        do{
            b=inbuf &amp; 0x80000000;//取最高位 
            inbuf&lt;&lt;=1;//左移一位 
            cnt++;
            if(b==0){
                htn=htn-&gt;lchild;
            }
            else{
                htn=htn-&gt;rchild;
            }
            if(htn-&gt;lchild==NULL &amp;&amp; htn-&gt;rchild==NULL){//到达叶结点 
                outbuf=htn-&gt;ch;
                outbuf2[cnt2++]=outbuf;
                outbuf=0;
                if(cnt2==1048576){
                    cnt2=0;
                    fwrite(outbuf2,1,1048576,fp2);
                    memset(outbuf2,0,1048576);
                }   
                k++;//计数加一 
                if(k==bytenum) break;
                htn=ht;//回根结点 
            }
        }while(cnt%32!=0);
        cnt=0;
        if(k%up==0) UpdateTimeText((double)k/(double)bytenum);
    }
    fwrite(outbuf2,1,cnt2,fp2);
    return OK;
}
#endif
</code></pre>
<p>Hzip.c</p>
<pre><code class="c">/*
    Last Update time: 2017-11-11     
    Version：1.1
    Author：LinXiang (PB16020923) 
    Description：
        Hzip.c.
*/
#include &lt;stdio.h&gt;
#include &lt;string.h&gt; 
#include &lt;time.h&gt;
#include &quot;MyUI.h&quot;
#include &quot;FrequencyList.h&quot;
#include &quot;HaffmanTree.h&quot;
#define WIDTH 50 //窗口的宽和高 
#define HEIGHT 15
HANDLE hout;
HANDLE hin;
time_t time_begin;
time_t time_now;
long FILESIZE;//记录文件长度，用于读取文件时计算进度
int FILETYPE;// 
char FILENAME[30]; 
void GetCompressedFilePath(char *FPath,char *CFPath){//从传入的路径求得对应压缩文件路径 
    strcpy(CFPath,FPath);
    strcat(CFPath,&quot;.hzip&quot;);
}
void GetDecompressedFilePath(char *FPath,char *DFPath){//从传入的压缩文路径求得对应解压文件路径 
    strcpy(DFPath,FPath);
    DFPath[strlen(DFPath)-5]=0;//去除尾部&quot;.hzip&quot; 
}
void GetFileNameFromPath(char *FPath,char *FName){//从路径中提取文件名
    char *pos;//最后一个\的位置 
    char *p=FPath;
    while(*p){
        if(*p==&#39;\\&#39;) pos=p;
        p++;
    }
    while(*pos){
        *FName++=*(++pos);//此法即可跳过‘\’本身，又可复制字符串结束符到FName中 
    }
}
long GetFileSizeFromPath(char *FPath){ //获取文件大小 
    FILE *fp=fopen(FPath,&quot;r&quot;);  
    if(!fp) return -1;  
    fseek(fp,0L,SEEK_END);  
    long size=ftell(fp);  
    fclose(fp);  
    return size;  
} 
int GetFileTypeFromPath(char *FPath){//判断是解压(1)还是压缩(0)
    FILE *fp=fopen(FPath,&quot;rb+&quot;);
    char MARK[22];
    int type;
    if(!fread(MARK,21,1,fp)){
        type=0;
    }
    else{
        MARK[21]=0;//字符串结尾 
        if(strcmp(&quot;#HAFFMANCOMPRESSFILE#&quot;,MARK)) type=0;
        else type=1;    
    }
    fclose(fp);
    return type;
}
void UIInit(){//UI初始化 
    UI_InitSTDHandle(&amp;hout,&amp;hin,WIDTH,HEIGHT);
    UI_SetConsoleScreenBufferSize(hout,WIDTH,HEIGHT);//设置缓冲区大小
    UI_SetConsoleWindowSize(hout,WIDTH,HEIGHT);//设置窗口大小 
    //system(&quot;color F0&quot;);此句与鼠标操作冲突！！！！！不要用system() 
    ClearScreen(hout,B_WHITE); //清屏并设置前景背景色，不要用上句 

    COORD curpos;
    curpos.X=5;
    curpos.Y=HEIGHT-2;
    SetConsoleCursorPosition(hout,curpos);//设置光标位置 
    CONSOLE_CURSOR_INFO cursor_info={1,0}; 
    SetConsoleCursorInfo(hout,&amp;cursor_info);//隐藏光标 
}
void DrawAllBox(){//绘制所有方框 
    SMALL_RECT rc;
    rc=UI_SetRect(0,0,WIDTH-1,3);
    UI_DrawBox(hout,1,rc,B_WHITE | F_RED);
    rc=UI_SetRect(0,4,WIDTH-1,7);
    UI_DrawBox(hout,1,rc,B_WHITE | F_BLUE);
    rc=UI_SetRect(0,8,WIDTH-1,11);
    UI_DrawBox(hout,1,rc,B_WHITE | F_BLUE); 
    rc=UI_SetRect(0,12,WIDTH-1,14);
    UI_DrawBox(hout,1,rc,B_WHITE | F_CYAN); 
}
void DrawInfoText(char *filename,int type,int size){//文件名，类型是解压(1)还是压缩(0)
    char t_title[30];
    sprintf(t_title,&quot;Hzip V1.1&quot;);
    UI_DrawText(hout,B_WHITE | F_RED,t_title,strlen(t_title),1,0+2,WIDTH-1-2);
    sprintf(t_title,&quot;Code by PB16020923&quot;);
    UI_DrawText(hout,B_WHITE | F_RED,t_title,strlen(t_title),2,0+2,WIDTH-1-2);
    //窗口标题显示当前操作
    char t_info[38];
    sprintf(t_info,&quot;Hzip V1.1 - %s&quot;,type==0?&quot;Compressing...&quot;:&quot;Decompressing...&quot;);
    SetConsoleTitle(t_info);
    //文件名
    char t_filename[38];
    sprintf(t_filename,&quot;FileName: %s&quot;,filename);    
    UI_DrawText(hout,B_WHITE | F_BLUE,t_filename,strlen(t_filename),5,0+2,WIDTH-1-2);
    //文件大小 
    char t_size[38];
    sprintf(t_size,&quot;Size: %0.2f KB&quot;,(double)size/1024);
    UI_DrawText(hout,B_WHITE | F_BLUE,t_size,strlen(t_size),6,0+2,WIDTH-1-2);   
}
void UpdateTimeText(double progress){//根据进度(0-1)更新剩余时间 
    time(&amp;time_now); 
    //已花时间 
    char t_spenttime[40];
    sprintf(t_spenttime,&quot;Spent Time: %d s&quot;,time_now-time_begin);
    UI_CleanText(hout,9,0+2,WIDTH-1-2);
    UI_DrawText(hout,B_WHITE | F_BLUE,t_spenttime,strlen(t_spenttime),9,0+2,WIDTH-1-2);
    //剩余时间 
    char t_remainedtime[40];
    sprintf(t_remainedtime,&quot;Remained Time: %d s&quot;,(int)((time_now-time_begin)*(1-progress)/progress));
    UI_CleanText(hout,10,0+2,WIDTH-1-2);
    UI_DrawText(hout,B_WHITE | F_BLUE,t_remainedtime,strlen(t_remainedtime),10,0+2,WIDTH-1-2);
    //画进度条 
    int k=47*progress,i;
    for(i=2;i&lt;=k;i++){
        //UI_DrawText(hout,B_BLUE,&quot; &quot;,1,12,i,i);
        UI_DrawText(hout,B_CYAN,&quot; &quot;,1,13,i,i);
    }
}
void DrawSelect(int select){//没有文件传入时显示配置界面,select=1表示已选中，即当前已创建右键菜单
    ClearScreen(hout,B_WHITE); 
    SMALL_RECT rc;
    rc=UI_SetRect(0,0,WIDTH-1,4);
    UI_DrawBox(hout,1,rc,B_WHITE | F_RED);      
    char t_title[38];
    sprintf(t_title,&quot;Hzip V1.1 - Setting&quot;);
    UI_DrawText(hout,B_WHITE | F_RED,t_title,strlen(t_title),2,0+2,WIDTH-1-2);

    int dx=10,dy=5;
    rc=UI_SetRect(0+dx,0+dy,5+dx,2+dy);
    UI_DrawBox(hout,1,rc,B_WHITE | F_BLUE);
    UI_DrawText(hout,B_WHITE | F_BLUE,select==1?&quot;√&quot;:&quot;  &quot;,2,1+dy,2+dx,3+dx);   
    char t_cj[30]=&quot;Create right-click menu&quot;;
    UI_DrawText(hout,B_WHITE | F_BLUE,t_cj,strlen(t_cj),1+dy,7+dx,7+dx+strlen(t_cj));
}
int CheckKey(){//检查右键菜单注册表是否已设置 
    HKEY k1,k2,k3;
    if(RegOpenKeyEx(HKEY_CLASSES_ROOT,&quot;*&quot;,0,KEY_ALL_ACCESS,&amp;k1) != ERROR_SUCCESS){
        return 0;
    }
    if(RegOpenKeyEx(k1,&quot;shell&quot;,0,KEY_ALL_ACCESS,&amp;k2) != ERROR_SUCCESS){
        return 0;
    }
    if(RegOpenKeyEx(k2,&quot;Use Hzip to compress/decompress...&quot;,0,KEY_ALL_ACCESS,&amp;k3) != ERROR_SUCCESS){ 
        return 0;
    }   
    return 1;
}
void SetKey(char *exepath){//设置或取消右键菜单注册表 
    HKEY k1,k2,k3,k4;
    char readvalue[128]={};
    char setvalue[128]={};
    if(RegOpenKeyEx(HKEY_CLASSES_ROOT,&quot;*&quot;,0,KEY_ALL_ACCESS,&amp;k1) != ERROR_SUCCESS){
        RegCreateKey(HKEY_CLASSES_ROOT,&quot;*&quot;,&amp;k1);
    }
    if(RegOpenKeyEx(k1,&quot;shell&quot;,0,KEY_ALL_ACCESS,&amp;k2) != ERROR_SUCCESS){
        RegCreateKey(k1,&quot;shell&quot;,&amp;k2);
    }
    if(RegOpenKeyEx(k2,&quot;Use Hzip to compress/decompress...&quot;,0,KEY_ALL_ACCESS,&amp;k3) != ERROR_SUCCESS){//没有右键 
        RegCreateKey(k2,&quot;Use Hzip to compress/decompress...&quot;,&amp;k3);
        RegCreateKey(k3,&quot;command&quot;,&amp;k4);
        strcpy(setvalue,exepath);
        strcat(setvalue,&quot; %1&quot;);
        RegSetValueEx(k4,NULL,0,REG_SZ,setvalue,sizeof(setvalue));
        DrawSelect(1);
        MessageBox(NULL,&quot;Program has created a right-click menu to use Hzip.&quot;,&quot;SET&quot;,MB_OK|MB_ICONINFORMATION);
    }
    else{//有右键，删除 
        RegDeleteKey(k3,&quot;command&quot;);
        RegDeleteKey(k2,&quot;Use Hzip to compress/decompress...&quot;);
        DrawSelect(0);
        MessageBox(NULL,&quot;Program has deteled the right-click menu to use Hzip.&quot;,&quot;DETELE&quot;,MB_OK|MB_ICONINFORMATION);
    }   
    RegCloseKey(k1);
    RegCloseKey(k2);
    RegCloseKey(k3);
    RegCloseKey(k4);
}
int Compress(char *fpath){//预处理及压缩 
    FILE *fp1=fopen(fpath,&quot;rb+&quot;);
    char cfpath[512];
    GetCompressedFilePath(fpath,cfpath);//生成压缩文件存储路径 
    FILE *fp2=fopen(cfpath,&quot;wb+&quot;);
    char MARK[21]=&quot;#HAFFMANCOMPRESSFILE#&quot;;
    fwrite(MARK,21,1,fp2);//标记这是一个压缩文件 

    pfrelist fl;
    CreateFrequencyListFromFile(fp1,&amp;fl);//读取源文件，创建频度表
    SaveFrequencyListToFile(fp2,fl);//保存频度表到目标文件
if(fl-&gt;num!=0 &amp;&amp; fl-&gt;num!=1){
//0表示空文件，1表示只有一种字符，这两种情况都不用编码，保存频度表即可 
        htree ht;
        CreateHaffmanTreeFromFrequencyList(fl,&amp;ht);//从频度表创建哈夫曼树 
        char haffmancode[256][256]={};
        CreateHaffmanCode(ht,haffmancode);
        fseek(fp1,0,SEEK_SET);//源文件移回文件头 
        HaffmanCompress(fp1,fp2,haffmancode,ht-&gt;f);//根结点的权值即为总字符数        
    }
    fclose(fp1);
    fclose(fp2);
}
int Decompress(char *fpath){//预处理及解压 
    FILE *fp1=fopen(fpath,&quot;rb+&quot;);
    char dfpath[512];
    GetDecompressedFilePath(fpath,dfpath);//生成解压文件存储路径 
    FILE *fp2=fopen(dfpath,&quot;wb+&quot;);
    fseek(fp1,21,SEEK_SET);//跳过标记 

    pfrelist fl;
    LoadFrequencyListFromFile(fp1,&amp;fl);
    if(fl-&gt;num==0) ;//空文件，不操作
    else if(fl-&gt;num==1){//只有一种字符的文件 
        unsigned int i;
        for(i=0;i&lt;fl-&gt;list[0].f;i++) fwrite(&amp;(fl-&gt;list[0].ch),1,1,fp2);
    }
    else{
        htree ht;
        CreateHaffmanTreeFromFrequencyList(fl,&amp;ht);
//从频度表创建哈夫曼树，解压时不用再生成哈夫曼编码，搜索树即可 
        HaffmanDecompress(fp1,fp2,ht);      
    }

    fclose(fp1);
    fclose(fp2);
}
int main(int argc,char *argv[]){
    UIInit();

    if(argc&gt;1){//有传入路径
        DrawAllBox();
        FILETYPE=GetFileTypeFromPath(argv[1]);  
        FILESIZE=GetFileSizeFromPath(argv[1]); 
        GetFileNameFromPath(argv[1],FILENAME); 
        DrawInfoText(FILENAME,FILETYPE,FILESIZE);

        time(&amp;time_begin); //计时开始 
        if(FILETYPE==0){
            Compress(argv[1]);
        }
        else{
            Decompress(argv[1]);
        }
        UpdateTimeText(1);
    }
    else{
        DrawSelect(CheckKey());
        INPUT_RECORD inrec;
        DWORD res;//返回已读取的记录数
        COORD pos={0,0};
        int k;
        for(;;){
            k++;
            ReadConsoleInput(hin,&amp;inrec,1,&amp;res);//读取鼠标信息
            if (inrec.EventType==MOUSE_EVENT){
                if (inrec.Event.MouseEvent.dwEventFlags==0 &amp;&amp; \
                inrec.Event.MouseEvent.dwButtonState==FROM_LEFT_1ST_BUTTON_PRESSED){
                    SetKey(argv[0]);//设置右键

                }
            }
        }
    }
    char t_finish[30];
    sprintf(t_finish,&quot;Finished! Press any key to exit!&quot;);
    UI_DrawText(hout,F_CYAN | B_BLACK,t_finish,strlen(t_finish),HEIGHT-2,0+2,WIDTH-1-2);
    getchar();
}
</code></pre>
<p>MyUI.h<br>​<br>​    界面部分，代码过长且与数据结构关系不大，此处不贴出</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DS/">DS</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ds/lab2_Bank" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/29/ds/lab2_Bank/" class="article-date">
      <time datetime="2017-10-28T16:00:00.000Z" itemprop="datePublished">2017-10-29</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/29/ds/lab2_Bank/">数据结构上机题2 模拟银行业务办理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol>
<li>检查日期：<br>10.28截止（下周六10.21做完的可以提前检查，人会比较少）</li>
<li>实验内容：<br>参考题集中P100的实验2.6银行模拟（做P102实验2.8电梯模拟也可以）输出界面要求按照时间顺序输出时间，事件，并计算平均等待时间。不出意外的话，要么rand设置会出现队伍越来越长要么会出现队伍变空没人。那么设置关门时间清空所有排队者或者中午吃饭关门等等，vip通道可自己设计。可自己添加辅助条件，要求合理，能说服助教。输出界面鼓励同学们用图形界面（动画的方式）来呈现。给分以完成程度评定（大家要仔细理解题集上面实验的题意哈）</li>
<li>要求：数据结构用链表与队列，还要有上述能表现出事件先后顺序的输出界面（希望大家的输出界面友好一点…），源代码当场检查完拷到实验室电脑上（命名：学号+姓名+实验x），每次上机要先签到，依签到顺序检查，本次实验要写实验报告（格式参考题集P105迷宫问题的实习报告）实验报告要求纸质版，记得写名字学号，实验检查结束后周一上课交。<br>以及：实验一还没有检查的同学下周六还可以接着去检查。（实验一不需要实验报告，只需提交源代码）</li>
</ol>
<h2 id="一、-需求分析"><a href="#一、-需求分析" class="headerlink" title="一、    需求分析"></a>一、    需求分析</h2><ol>
<li><p>实现功能：模拟银行业务办理。银行只能同时运行一个窗口，但设有两个队列。客户到达时，先排第一个队列，客户可以办理两种业务：取款或存款。如果是第一种业务，但银行现有的资金不能满足客户，那么客户立刻排入第二个队列队尾进行等候，否则，花费一定时间办理业务后立刻离开。每当办理完一个第二种业务客户时，顺序检查（假设检查不需要时间）第二个队列的客户，对于能满足者进行业务办理，否则排入队尾继续等候。如果检查过程中，银行的资金已经小于刚才办理完第一种业务的客户时的资金或者第二个队列中的所有客户已经检查了一遍，则停止检查，继续接待第一个队列中的客户。在到达营业结束时间时，所有客户立刻离开银行。计算所有客户在银行内逗留的平均时间并输出。</p>
</li>
<li><p>初始时需要设置银行营业时间CloseTime(int,&gt;0)、银行初始资金BankMoney(int,&gt;0)、下一个客户到来时间间隔的上下限NextCutormerTime(int,&gt;0)、客户办理业务所需时间的上下限DurTime(int,&gt;0)、客户交易金额的上下限Amount(int,!=0)，由用户通过控制台窗口输入。</p>
</li>
<li><p>模拟业务办理过程采用事件驱动方式，用动态链表数据结构实现事件的加入与执行。</p>
</li>
<li><p>客户队列用顺序存储的循环队列存放。</p>
</li>
<li><p>模拟过程中在控制台中实时输出当前时间、银行资金、正在办理业务的客户、两个队列中的客户、发生的事件。</p>
</li>
<li><p>测试数据：任意，注意测定两种极端情况，<br>（1）    两个客户到达间隔极短，而客户办理时间极长。<br>（2）    两个客户到达间隔极长，而客户办理时间极短。</p>
</li>
</ol>
<h2 id="二、-概要设计"><a href="#二、-概要设计" class="headerlink" title="二、    概要设计"></a>二、    概要设计</h2><ol>
<li><p>抽象数据类型客户队列定义如下：</p>
<p>  ADT UserQueue{</p>
<pre><code>  数据对象：D={User|User.id=1,2,...,n;n&gt;=0}
  数据关系：无
  基本操作：
      InitQueue(&amp;q);
          操作结果：创建客户队列q。
      DestoryQueue(&amp;q);
          初始条件：客户队列q存在。
          操作结果：销毁客户队列q。
      QueueLength(q);
          初始条件：客户队列q存在。
          操作结果：返回客户队列q的长度。
      EnQueue(&amp;q,elem);
          初始条件：客户队列q存在。
          操作结果：将客户elem加入客户队列q的队尾。         
      DeQueue(&amp;q,&amp;elem);
          初始条件：客户队列q存在。
          操作结果：将客户从客户队列q的队头删除，存放在elem中。   
      PeekQueueByPos(&amp;q,i,&amp;elem);
          初始条件：客户队列q存在。
          操作结果：返回客户队列q的第i个元素但不出队。   
</code></pre><p>  }ADT UserQueue</p>
</li>
</ol>
<ol start="2">
<li><p>抽象数据类型事件链表定义如下：</p>
<p>  ADT EventLinkList{</p>
<pre><code>  数据对象：D={Event}
  数据关系：无
  基本操作：
      MakeEventNode(occurtime,type);
          操作结果：根据参数创建事件节点。
      DestoryEventList(&amp;el);
          初始条件：事件链表el存在。
          操作结果：销毁事件链表el。
      InitEventList(&amp;el);
          初始条件：事件链表el存在。
          操作结果：创建事件链表el。
      InsertEventToListInOrder(el,&amp;ev);
          初始条件：事件链表el存在。
          操作结果：将事件ev按时间顺序插入事件链表el。
      DeleteEventFromListByPos(el,pos,&amp;ev);
          初始条件：事件链表el存在。
          操作结果：删除事件链表el的第pos个事件，放在ev中。  
</code></pre><p>  }ADT EventLinkList</p>
</li>
<li><p>主程序</p>
<p>  void main(){</p>
<pre><code>  用户输入参数;
  初始化窗口及各数据类型;
  while(营业未结束){
      取下一个事件;
      switch(该事件){
          case 到来: 加入用户队列；
              if(服务窗口空闲) 服务队列1的下一个客户;
              break;
          case 离开:
              停留时间计算并加入统计时间;
              银行资金改变;
              if(该客户是存款) 检查队列2;
              else (该客户是取款 &amp;&amp; 客户来自队列2) 继续检查队列2;
              if(不是正在检查队列2) 服务队列1的下一个客户;
              break;  
          case 结束: 队列中所有客户离开； 
      }
  }
  输出平均时间;
</code></pre><p>  }</p>
</li>
<li><p>本程序含四个模块</p>
<p>(1)    主模块<br>(2)    用户队列模块<br>(3)    事件链表模块<br>(4)    图形界面模块<br><img src="//l-x.me/2017/10/29/ds/lab2_Bank/0.png" alt=""></p>
</li>
</ol>
<h2 id="三、-详细设计"><a href="#三、-详细设计" class="headerlink" title="三、    详细设计"></a>三、    详细设计</h2><p>1．    客户类型</p>
<pre><code>typedef struct _User{
    int id; 
    int arrtime;
    int durtime;
    int amount;
}User;
</code></pre><p>2．    客户队列类型</p>
<pre><code>typedef struct _SqQueue{
    User *base;
    int front;
    int rear;
}SqQueue;
</code></pre><p>3．    事件及事件链表类型</p>
<pre><code>typedef struct _Event{
    int occurtime;
    enum TYPE type;
    struct _Event *next;
}Event,*EvList;
</code></pre><p>4．    客户队列操作</p>
<pre><code>Status InitQueue(SqQueue *q);
//初始化队列
Status DestoryQueue(SqQueue *q);
//销毁队列
int QueueLength(SqQueue q);
//队列长度
Status EnQueue(SqQueue *q,User elem);
//入队
Status DeQueue(SqQueue *q,User *elem);
//出队
Status PeekQueueByPos(SqQueue *q,int i,User *elem);
//查看第i个元素但不出队 
</code></pre><p>5．    事件链表操作</p>
<pre><code>Event* MakeEventNode(int occurtime,int type);
//创建事件结点 
Status DestoryEventList(EvList *l);
//销毁事件链表 
Status InitEventList(EvList *l);
//初始化事件链表 
Status InsertEventToListInOrder(EvList l,Event *ev);
//按时间顺序插入事件，插入后该事件将成为事件列表的一部分
Status DeleteEventFromListByPos(EvList l,int pos,Event *ev);
//删除指定位置的事件，pos=1...length,ev存放删除的事件 
</code></pre><p>6．    图形界面操作</p>
<pre><code>SMALL_RECT UI_SetRect(int left,int top,int right,int bottom);
//根据坐标取返回对应矩形区域数据 
void UI_SetConsoleWindowSize(HANDLE hOut,int width,int height);
//设置窗口大小
void UI_SetConsoleScreenBufferSize(HANDLE hOut,int width,int height);
//设置缓冲区大小
void UI_InitSTDHandle(HANDLE *hOut,CONSOLE_SCREEN_BUFFER_INFO *bInfo,int width,int height);
//初始化 
void UI_DrawText(HANDLE hOut,WORD attr,char *text,int len,int row,int left,int right);
//在指定行左右位置之间居中输出一行文本
void UI_CleanText(HANDLE hOut,int row,int left,int right);
//在指定行左右位置之间清除一行文本
void UI_CleanTextRect(HANDLE hOut,int top,int bottom,int left,int right);
//在指定区域之间清除文本
void UI_DrawBox(HANDLE hOut,int bSingle,SMALL_RECT rc,WORD attr);
//画方框 
</code></pre><p>7．    其他函数</p>
<pre><code>void ShowBox();
//绘制所有方框 
void ShowBankandTimeText();
//绘制时间和银行资金的文本 
void ShowMessageText1();
//绘制信息文本1 
void ShowMessageText2(int id,int type);
//绘制信息文本2
void ShowQueueText();
//绘制队列文本
int Random(int low,int high);
//随机数 
void RandNextCustomer();
//生成下一个客户到来事件 
void Init();
//初始化 
Status ServeNextCustomerInQueue1(SqQueue *q_point);
//服务队列1的下一个客户，如果不满足，则继续寻找下一个 
Status ServeNextCustomerInQueue2(SqQueue *q_point);
//服务队列2的下一个客户
Status Check();
//检查队列2 
</code></pre><p>8．    具体的函数实现见附录，均有详细注释，此处不再赘述。</p>
<h2 id="四、-调试分析"><a href="#四、-调试分析" class="headerlink" title="四、    调试分析"></a>四、    调试分析</h2><p>1．    本程序的难点在于在事件中对队列2的检查，以及对队列中下个办理业务的客户的选取。<br>​<br>2．    在对队列2的检查上，编写了Check函数，每当队列1的客户存款之后调用，在Check函数中顺序寻找下一个符合要求的客户，后调用ServeNextCustomerInQueue2进行业务办理，但该客户完成后，队列2中可能仍有满足需求的客户，故应设置全局变量Checking表示当前是在队列2检查状态，以便在该客户发生离开事件时，再次调用Check继续检查队列2，如果此时没有符合条件的客户，则置Checking状态为0，以便离开事件发生时，下一个办理业务的客户从队列1中选取。这种方法需要置全局变量，且思路不是很清晰，之前设想了将离开事件从main函数中剥离，而检查队列2时，进入Check函数，在其中满足了尽可能多的客户后才退回主函数，期间可调用离开事件函数处理队列2的客户离开，但考虑到本程序为事件驱动，事件按照时间顺序发生，在处理队列2的客户时，可能有新的客户到来事件发生，如果进入Check后一直执行至不能满足条件，可能导致时间线出现错乱，期间到来的客户事件将发生在之后唉。目前没有想到更好的方法。</p>
<p>3．    在对队列中下一个办理业务的客户的选取上，编写了ServeNextCustomerInQueue1和ServeNextCustomerInQueue2，这里出现了部分功能重叠，此乃败笔唉。主要是ServeNextCustomerInQueue1需要递归直至找到可以办理业务的下一个客户，但ServeNextCustomerInQueue2无需判断，在Check中已进行判断</p>
<p>4．    ServeNextCustomerInQueue中使用了DeQueue,因此参数需要传入q1的地址，之前疏忽，直接以q1为参数，导致q1中的元素执行了DeQueue仍然存在。</p>
<p>5．    本程序模拟银行业务，本来打算用时间作为循环变量，结束营业时间为结束条件，但是为了体现离散事件模拟，故采用事件驱动模式，即以事件为单位，一次循环发生一个事件，但在界面输出上，为了保证时间的连续性和可观看性，在输出上把两个事件之间的时间流逝体现出来</p>
<p>6．    使用C语言且不使用第三方库进行图形界面编程实在困难，之前打算学习一下MFC，然而其繁琐得令人望而却步！</p>
<h2 id="五、-用户手册"><a href="#五、-用户手册" class="headerlink" title="五、    用户手册"></a>五、    用户手册</h2><p><img src="//l-x.me/2017/10/29/ds/lab2_Bank/01.png" alt=""><br><img src="//l-x.me/2017/10/29/ds/lab2_Bank/02.png" alt="">  </p>
<h2 id="六、-测试结果"><a href="#六、-测试结果" class="headerlink" title="六、    测试结果"></a>六、    测试结果</h2><ol>
<li><p>输入及输出如图，两个客户到达间隔极短，而客户办理时间极长。<br><img src="//l-x.me/2017/10/29/ds/lab2_Bank/03.png" alt="">  </p>
</li>
<li><p>输入及输出如图，两个客户到达间隔极长，而客户办理时间极短。<br><img src="//l-x.me/2017/10/29/ds/lab2_Bank/04.png" alt="">   </p>
</li>
<li><p>其他截图<br><img src="//l-x.me/2017/10/29/ds/lab2_Bank/1.png" alt=""><br><img src="//l-x.me/2017/10/29/ds/lab2_Bank/2.png" alt=""><br><img src="//l-x.me/2017/10/29/ds/lab2_Bank/3.png" alt=""><br><img src="//l-x.me/2017/10/29/ds/lab2_Bank/4.png" alt=""><br><img src="//l-x.me/2017/10/29/ds/lab2_Bank/5.png" alt=""><br><img src="//l-x.me/2017/10/29/ds/lab2_Bank/6.png" alt="">  </p>
</li>
</ol>
<h2 id="七、-附录"><a href="#七、-附录" class="headerlink" title="七、    附录"></a>七、    附录</h2><ul>
<li>源程序文件清单：</li>
</ul>
<p>（1）    UserQueue.h<br>​<br>（2）    EventLinkList.h<br>​<br>（3）    MyUI.h<br>​<br>（4）    Bank.c</p>
<p>UserQueue.h</p>
<pre><code class="c">/*
    Last Update time: 2017-10-17 
    Version：1.0
    Author：LinXiang (PB16020923) 
    Description：
        UserQueue.
*/
#include &lt;stdlib.h&gt;
#define QMAXSIZE 100
#define OK 1
#define ERROR 0 
typedef int Status;
typedef struct _User{
    int id; 
    int arrtime;
    int durtime;
    int amount;
}User;
typedef struct _SqQueue{
    User *base;
    int front;
    int rear;
}SqQueue;
Status InitQueue(SqQueue *q){//初始化队列 
    q-&gt;base=(User *)malloc(QMAXSIZE*sizeof(User));
    q-&gt;front=0;
    q-&gt;rear=0;
    return OK;
} 
Status DestoryQueue(SqQueue *q){//销毁队列 
    if(!q-&gt;base) return ERROR; 
    free(q-&gt;base);
    q-&gt;front=0;
    q-&gt;rear=0;
    return OK;
}
int QueueLength(SqQueue q){//求队列长度 
    return (q.rear-q.front+QMAXSIZE) % QMAXSIZE;
}
Status EnQueue(SqQueue *q,User elem){//入队 
    if((q-&gt;rear+1) % QMAXSIZE==q-&gt;front) return ERROR;
    q-&gt;base[q-&gt;rear]=elem;
    q-&gt;rear=(q-&gt;rear+1) % QMAXSIZE;
    return OK;
}
Status DeQueue(SqQueue *q,User *elem){//出队 
    if(q-&gt;rear==q-&gt;front) return ERROR;
    *elem=q-&gt;base[q-&gt;front];
    q-&gt;front=(q-&gt;front+1) % QMAXSIZE;
    return OK;
}
Status PeekQueue(SqQueue *q,User *elem){//查看队头但不出队 
    if(q-&gt;rear==q-&gt;front) return ERROR;
    *elem=q-&gt;base[q-&gt;front];
    return OK;
}
Status PeekQueueByPos(SqQueue *q,int i,User *elem){//查看第i个元素但不出队 
    if(i&gt;QueueLength(*q)) return ERROR;
    *elem=q-&gt;base[(q-&gt;front+i-1) % QMAXSIZE];
    return OK;
}
</code></pre>
<p>EventLinkList.h</p>
<pre><code class="c">/*
    Last Update time: 2017-10-17 
    Version：1.0
    Author：LinXiang (PB16020923) 
    Description：
        EventLinkList.
*/
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define OK 1
#define ERROR 0 
enum TYPE{HEADNODE,ARR,LEAVE,CLOSE};//枚举事件类型，其中HEADNODE为表示头节点
typedef int Status;
typedef struct _Event{
    int occurtime;
    enum TYPE type;
    struct _Event *next;
}Event,*EvList;
Event* MakeEventNode(int occurtime,int type){//创建事件结点 
    Event *p=(Event*)malloc(sizeof(Event));
    p-&gt;type=(enum TYPE)type;
    p-&gt;occurtime=occurtime;
    p-&gt;next=NULL;
    return p;
}
Status DestoryEventList(EvList *l){//销毁事件链表 
    if(*l==NULL) return OK;
    Event *p=(*l)-&gt;next,*q;
    while(p!=NULL){
        q=p-&gt;next;
        free(p);
        p=q;
    } 
    free(*l);
    *l=NULL;
    return OK;
}
Status InitEventList(EvList *l){//初始化事件链表 
    if(*l!=NULL) DestoryEventList(l);
    *l=MakeEventNode(-1,HEADNODE);
    return OK;
}
Status InsertEventToListInOrder(EvList l,Event *ev){
//按时间顺序插入事件，插入后该事件将成为事件列表的一部分
    Event *q=l,*p;
    while(q-&gt;next!=NULL &amp;&amp; q-&gt;next-&gt;occurtime&lt;ev-&gt;occurtime){
        q=q-&gt;next;
    }
    ev-&gt;next=q-&gt;next;
    q-&gt;next=ev;
    return OK;
}
Status DeleteEventFromListByPos(EvList l,int pos,Event *ev){
//删除指定位置的事件，pos=1...length,ev存放删除的事件 
    if(pos&lt;1) return ERROR;
    Event *q=l;
    int i=1;
    while(q-&gt;next!=NULL &amp;&amp; i++&lt;pos){
        q=q-&gt;next;
    }
    if(q-&gt;next==NULL) return ERROR;
    else{
        Event *r=q-&gt;next;
        memcpy(ev,r,sizeof(Event)); 
        q-&gt;next=q-&gt;next-&gt;next;
        free(r);
    }
    return OK;  
}
</code></pre>
<p>MyUI.h</p>
<pre><code class="c">/*
    Last Update time: 2017-10-22 
    Version：1.0
    Author：LinXiang (PB16020923) 
    Description：
        MyUI.c.
*/
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#define F_GRAY FOREGROUND_INTENSITY 
#define F_CYAN FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY
#define F_ORANGE FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY
#define F_PURPLE FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY
#define F_RED FOREGROUND_RED | FOREGROUND_INTENSITY
#define F_GREEN FOREGROUND_GREEN | FOREGROUND_INTENSITY
#define F_BLUE FOREGROUND_BLUE | FOREGROUND_INTENSITY
#define F_WHITE FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY
#define F_USUALWHITE FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE //不加亮的白色为正常颜色 
#define F_BLACK FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | COMMON_LVB_REVERSE_VIDEO
#define B_GRAY BACKGROUND_INTENSITY 
#define B_CYAN BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_INTENSITY
#define B_ORANGE BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_INTENSITY
#define B_PURPLE BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY
#define B_BLUE BACKGROUND_BLUE | BACKGROUND_INTENSITY
#define B_RED BACKGROUND_RED | BACKGROUND_INTENSITY
#define B_GREEN BACKGROUND_GREEN | BACKGROUND_INTENSITY
#define B_WHITE BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE | BACKGROUND_INTENSITY
#define B_USUALWHITE BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE //不加亮的白色为正常颜色 
#define B_BLACK BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE | COMMON_LVB_REVERSE_VIDEO
SMALL_RECT UI_SetRect(int left,int top,int right,int bottom){
//根据坐标取返回对应矩形区域数据 
    SMALL_RECT rc={0,0,0,0};
    rc.Left=left;
    rc.Top=top;
    rc.Right=right;
    rc.Bottom=bottom;
    return rc;
}
void UI_SetConsoleWindowSize(HANDLE hOut,int width,int height) {//设置窗口大小
    SMALL_RECT rc;
    rc=UI_SetRect(0,0,width-1,height-1);
    SetConsoleWindowInfo(hOut,1,&amp;rc); // 重置窗口位置和大小
}
void UI_SetConsoleScreenBufferSize(HANDLE hOut,int width,int height) {
//设置缓冲区大小
    COORD size;
    size.X=width;
    size.Y=height;
    SetConsoleScreenBufferSize(hOut,size); // 重新设置缓冲区大小
}
void UI_InitSTDHandle(HANDLE *hOut,CONSOLE_SCREEN_BUFFER_INFO *bInfo,int width,int height){//初始化 
    *hOut=GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleScreenBufferInfo(*hOut, bInfo);
    SetConsoleOutputCP(437);//设置代码页
    UI_SetConsoleScreenBufferSize(*hOut,width,height);//必须先设置大的缓冲区 
    UI_SetConsoleWindowSize(*hOut,width,height);//才能设置对应大小的窗口 
}
void UI_DrawText(HANDLE hOut,WORD attr,char *text,int len,int row,int left,int right){//在指定行左右位置之间居中输出一行文本
    DWORD buf[128];//
    COORD pos;
    pos.Y=row;
    pos.X=(right-left+1-len)/2+left;
FillConsoleOutputAttribute(hOut, attr , len, pos, (LPDWORD)buf);
//给该坐标的字符上色 
WriteConsoleOutputCharacter(hOut, text, len, pos, (LPDWORD)buf);
//在pos处输出长为len的text 
}
void UI_CleanText(HANDLE hOut,int row,int left,int right){
//在指定行左右位置之间清除一行文本
    DWORD buf[128];//
    COORD pos;
    pos.Y=row;
    pos.X=left;
    WORD attr=F_BLACK; 
FillConsoleOutputAttribute(hOut, attr , right-left+1, pos, (LPDWORD)buf);
//给该坐标的字符上色 
FillConsoleOutputCharacter(hOut,&#39; &#39;, right-left+1, pos, (LPDWORD)buf);
//在pos处重复输出多个某字符 
}
void UI_CleanTextRect(HANDLE hOut,int top,int bottom,int left,int right){
//在指定区域之间清除文本
    DWORD buf[128];
    WORD attr=F_BLACK;
    int i;
    for(i=top;i&lt;=bottom;i++){
        COORD pos;
        pos.Y=i;
        pos.X=left;
        FillConsoleOutputAttribute(hOut, attr , right-left+1, pos, (LPDWORD)buf);
//给该坐标的字符上色 
        FillConsoleOutputCharacter(hOut,&#39; &#39;, right-left+1, pos, (LPDWORD)buf);
//在pos处重复输出多个某字符    
    }
}
void UI_DrawBox(HANDLE hOut,int bSingle,SMALL_RECT rc,WORD attr){//画方框 
    char chBox[6];
    DWORD buf[128];//存放最后一个参数：输出的字符数 
    COORD pos;
    if (bSingle) {
        chBox[0] = (char)0xda; // 左上角点
        chBox[1] = (char)0xbf; // 右上角点
        chBox[2] = (char)0xc0; // 左下角点
        chBox[3] = (char)0xd9; // 右下角点
        chBox[4] = (char)0xc4; // 水平
        chBox[5] = (char)0xb3; // 坚直
    }
    else{
        chBox[0] = (char)0xc9; // 左上角点
        chBox[1] = (char)0xbb; // 右上角点
        chBox[2] = (char)0xc8; // 左下角点
        chBox[3] = (char)0xbc; // 右下角点
        chBox[4] = (char)0xcd; // 水平
        chBox[5] = (char)0xba; // 坚直
    }
    pos.Y = rc.Top;
    // 画左上角
    pos.X = rc.Left;
FillConsoleOutputAttribute(hOut, attr , 1, pos, (LPDWORD)buf);
//给该坐标的字符上色 
    WriteConsoleOutputCharacter(hOut, &amp;chBox[0],1, pos, (LPDWORD)buf);
    // 画右上角
    pos.X = rc.Right;
FillConsoleOutputAttribute(hOut, attr , 1, pos, (LPDWORD)buf);
//给该坐标的字符上色 
    WriteConsoleOutputCharacter(hOut, &amp;chBox[1], 1, pos, (LPDWORD)buf);

    pos.Y = rc.Bottom;
    // 画左下角
    pos.X = rc.Left;
FillConsoleOutputAttribute(hOut, attr , 1, pos, (LPDWORD)buf);
//给该坐标的字符上色 
    WriteConsoleOutputCharacter(hOut, &amp;chBox[2], 1, pos, (LPDWORD)buf);
    // 画右下角
    pos.X = rc.Right;
FillConsoleOutputAttribute(hOut, attr , 1, pos, (LPDWORD)buf);
//给该坐标的字符上色 
    WriteConsoleOutputCharacter(hOut, &amp;chBox[3], 1, pos, (LPDWORD)buf);

    // 画边框的上 下边界
    for(pos.X = rc.Left+1;pos.X&lt;rc.Right;pos.X++){  
        pos.Y = rc.Top;
        FillConsoleOutputAttribute(hOut, attr , 1, pos, (LPDWORD)buf);
//给该坐标的字符上色 
        WriteConsoleOutputCharacter(hOut, &amp;chBox[4], 1, pos, (LPDWORD)buf);
// 画上边界
        pos.Y = rc.Bottom;
        FillConsoleOutputAttribute(hOut, attr , 1, pos, (LPDWORD)buf);
//给该坐标的字符上色 
        WriteConsoleOutputCharacter(hOut, &amp;chBox[4], 1, pos, (LPDWORD)buf);
// 画下边界
    }
    // 画边框的左右边界
    for (pos.Y = rc.Top+1; pos.Y&lt;rc.Bottom; pos.Y++){
        pos.X = rc.Left;
        FillConsoleOutputAttribute(hOut, attr , 1, pos, (LPDWORD)buf);
//给该坐标的字符上色 
        WriteConsoleOutputCharacter(hOut, &amp;chBox[5], 1, pos, (LPDWORD)buf);
// 画左边界
        pos.X = rc.Right;
        FillConsoleOutputAttribute(hOut, attr , 1, pos, (LPDWORD)buf);
//给该坐标的字符上色 
        WriteConsoleOutputCharacter(hOut, &amp;chBox[5], 1, pos, (LPDWORD)buf); 
// 画右边界
    }
}
</code></pre>
<p>Bank.c</p>
<pre><code class="c">/*
    Last Update time: 2017-10-26 
    Version：1.0
    Author：LinXiang (PB16020923) 
    Description：
        Bank.c.
*/
#include &quot;UserQueue.h&quot;
#include &quot;EventLinkList.h&quot;
#include &quot;MyUI.h&quot; 
#define DEBUG
#define TRUE 1
#define FALSE 0
#define WIDTH 120 //窗口的宽和高 
#define HEIGHT 50
int ScreenHeight=HEIGHT;//屏幕缓冲区的时间高度，会随队列长度而变，初始等于窗口高度
int CustomNum=0,BankMoney=10000,CloseTime=600,TotalTime=0,Time=0; 
//客户数，银行资金，结束时间，客户停留累计时间，当前时间
int NextCustomTime_LowerBound=1,NextCustomTime_UpperBound=10; //下一个客户到来的时间间隔上下限
int CustomDurTime_LowerBound=1,CustomDurTime_UpperBound=20; //客户办理业务时间的上下想
int CustomAmount_LowerBound=1,CustomAmount_UpperBound=9000; //客户服务的金额
int moneybeforecheck=0; //在检查队列2之前的银行资金
int MORE=0,checking=0;//继续营业，正在检查第二个队列 
EvList el=NULL; //事件链表
SqQueue q1,q2; //队列1，2
User servingusr={0,0,0,0};//正在服务的客户
HANDLE hout; //控制台句柄
CONSOLE_SCREEN_BUFFER_INFO binfo;
void ShowBox(){//绘制所有方框 
    system(&quot;cls&quot;);
    SMALL_RECT rc;
    rc=UI_SetRect(0,0,WIDTH-1,2);
    UI_DrawBox(hout,0,rc,F_CYAN); //画最上面的框

    rc=UI_SetRect(0,3,WIDTH/2-1,5);
    UI_DrawBox(hout,0,rc,F_GREEN);  //画第一个消息框
    rc=UI_SetRect(WIDTH/2,3,WIDTH-1,5);
    UI_DrawBox(hout,0,rc,F_GREEN);  //画第二个消息框

    rc=UI_SetRect(0,6,WIDTH/2-1,8);
    UI_DrawBox(hout,0,rc,F_ORANGE); //画队列1的框
    rc=UI_SetRect(WIDTH/2,6,WIDTH-1,8);
    UI_DrawBox(hout,0,rc,F_BLUE); //画队列2的框

    rc=UI_SetRect(0,6,WIDTH/2-1,ScreenHeight-1);
    UI_DrawBox(hout,0,rc,F_ORANGE); //画队列1的框
    rc=UI_SetRect(WIDTH/2,6,WIDTH-1,ScreenHeight-1);
    UI_DrawBox(hout,0,rc,F_BLUE); //画队列2的框
} 
void ShowBankandTimeText(){//绘制时间和银行资金的文本 
    char t_bankmony[30];
    sprintf(t_bankmony,&quot;BankMoney: %d YUAN&quot;,BankMoney);
    UI_CleanText(hout,1,WIDTH/2+1,WIDTH-1-1);//清除原先的文本 
    UI_DrawText(hout,F_CYAN,t_bankmony,strlen(t_bankmony),1,WIDTH/2+1,WIDTH-1-1);
    char t_time[30];
    sprintf(t_time,&quot;Time: %d minute&quot;,Time);
    UI_CleanText(hout,1,0+1,WIDTH/2-1-1);   
    UI_DrawText(hout,F_CYAN,t_time,strlen(t_time),1,0+1,WIDTH/2-1-1);   
    char t_q1[30];
    sprintf(t_q1,&quot;Queue 1: [%d] customers&quot;,QueueLength(q1));
    UI_CleanText(hout,7,0+1,WIDTH/2-1-1);
    UI_DrawText(hout,F_ORANGE,t_q1,strlen(t_q1),7,0+1,WIDTH/2-1-1);         
    char t_q2[30];
    sprintf(t_q2,&quot;Queue 2: [%d] customers&quot;,QueueLength(q2));
    UI_CleanText(hout,7,WIDTH/2+1,WIDTH-1-1);
    UI_DrawText(hout,F_BLUE,t_q2,strlen(t_q2),7,WIDTH/2+1,WIDTH-1-1);   
}
void ShowMessageText1(){//绘制信息文本1 
    char t_message[100];
    if(servingusr.id!=0)
        sprintf(t_message,&quot;Serving for ID:%-3d(AMOUNT:%-6d ARRTIME:%-4d DURTIME:%-3d)&quot;\
        ,servingusr.id,servingusr.amount,servingusr.arrtime,servingusr.durtime);
    else
        sprintf(t_message,&quot;Bank Info: Free.&quot;);
    UI_CleanText(hout,4,0+1,WIDTH/2-1-1);
    UI_DrawText(hout,F_GREEN,t_message,strlen(t_message),4,0+1,WIDTH/2-1-1);        
}
void ShowMessageText2(int id,int type){ //绘制信息文本2
    char t_message[100];
    switch(type){
        case 1: sprintf(t_message,&quot;Bank Info: ID:%d arrive at the %d minute.&quot;,id,Time); break;
        case 2: sprintf(t_message,&quot;Bank Info: ID:%d leave at the %d minute.&quot;,id,Time); break;
    }
    UI_CleanText(hout,4,WIDTH/2+1,WIDTH-1-1);
    UI_DrawText(hout,F_GREEN,t_message,strlen(t_message),4,WIDTH/2+1,WIDTH-1-1);        
}
void ShowQueueText(){//绘制队列文本
    User usr;
    UI_CleanTextRect(hout,9,ScreenHeight-1-1,0+1,WIDTH/2-1-1);
    UI_CleanTextRect(hout,9,ScreenHeight-1-1,WIDTH/2+1,WIDTH-1-1);
    int l=QueueLength(q1),i;
    if(l&gt;ScreenHeight-10){//超出缓冲区高度，重绘 
        UI_SetConsoleScreenBufferSize(hout,WIDTH,++ScreenHeight);
        ShowBox();
        ShowBankandTimeText();
    }
    for(i=1;i&lt;=l;i++){//输出队列1
        PeekQueueByPos(&amp;q1,i,&amp;usr);
        char t_q1c[80];
        sprintf(t_q1c,&quot;ID:%-3d (AMOUNT:%-6d ARRTIME:%-4d DURTIME:%-3d)&quot;,usr.id,usr.amount,usr.arrtime,usr.durtime);
        UI_DrawText(hout,F_ORANGE,t_q1c,strlen(t_q1c),9+i-1,0+1,WIDTH/2-1-1);
    }
    l=QueueLength(q2);
    if(l&gt;ScreenHeight-10){//超出缓冲区高度，重绘 
        UI_SetConsoleScreenBufferSize(hout,WIDTH,++ScreenHeight);
        ShowBox();
        ShowBankandTimeText();
    }
    for(i=1;i&lt;=l;i++){//输出队列2
        PeekQueueByPos(&amp;q2,i,&amp;usr);
        char t_q2c[80];
        sprintf(t_q2c,&quot;ID:%-3d (AMOUNT:%-6d ARRTIME:%-4d DURTIME:%-3d)&quot;,usr.id,usr.amount,usr.arrtime,usr.durtime);
        UI_DrawText(hout,F_BLUE,t_q2c,strlen(t_q2c),9+i-1,WIDTH/2+1,WIDTH-1-1);
    }
}
int Random(int low,int high){//随机数 
    return(low+rand()%(high-low+1));
}
void RandNextCustomer() {//生成下一个客户到来事件 
    int nexttime=Time+Random(NextCustomTime_LowerBound,NextCustomTime_UpperBound);
    if(nexttime&lt;CloseTime){
        Event *ev_arr=MakeEventNode(nexttime,ARR);
        InsertEventToListInOrder(el,ev_arr);//加入下一个客户到来事件 
    }
}
void Init(){//初始化 
    UI_InitSTDHandle(&amp;hout,&amp;binfo,WIDTH,HEIGHT);
    srand((unsigned int)time(NULL)); //置随机数种子
    InitEventList(&amp;el); 
    InitQueue(&amp;q1);
    InitQueue(&amp;q2); 
    Event *ev_cl=MakeEventNode(CloseTime,CLOSE);
    InsertEventToListInOrder(el,ev_cl);//加入营业结束事件 
    RandNextCustomer();//第一个客户 
}
Status ServeNextCustomerInQueue1(SqQueue *q_point){
//服务队列1的下一个客户，如果不满足，则继续寻找下一个 
//!!!此处传入q的地址是为了该函数内部使用了DeQueue，需要改变q 
    if(QueueLength(*q_point)){ //队列不为空
        DeQueue(q_point,&amp;servingusr); //取队头
        if(servingusr.amount&lt;0 &amp;&amp; -servingusr.amount&gt;BankMoney){ //是取款但银行满足不了，加入队2
            EnQueue(&amp;q2,servingusr);
            return ServeNextCustomerInQueue1(q_point); //往后寻找
        }
        Event *ev_leave=MakeEventNode(Time+servingusr.durtime,LEAVE);
        InsertEventToListInOrder(el,ev_leave);//加入该客户离开事件 
    }
    else{
        servingusr.id=0;//表示当前没有客户正在服务 
    }
    return OK;
}
Status ServeNextCustomerInQueue2(SqQueue *q_point){//服务队列2的下一个客户
    if(QueueLength(*q_point)){
        DeQueue(q_point,&amp;servingusr);
        Event *ev_leave=MakeEventNode(Time+servingusr.durtime,LEAVE);
        InsertEventToListInOrder(el,ev_leave);//加入该客户离开事件 
    }
    else{
        servingusr.id=0;//表示当前没有客户正在服务 
    }
    return OK;
}
Status Check(){//检查队列2 
    if(BankMoney&lt;=moneybeforecheck){
        checking=0;
        return FALSE;
    }
    int l=QueueLength(q2),k=0;
    while(k&lt;l){//尚未将队列2中的所有客户检查一遍 
        User usr;
        PeekQueue(&amp;q2,&amp;usr);
        if(-usr.amount&gt;BankMoney){//银行的钱不能满足该客户 
            k++; 
            DeQueue(&amp;q2,&amp;usr);
            EnQueue(&amp;q2,usr); //加入队尾
        }
        else{
            checking=1;
            ServeNextCustomerInQueue2(&amp;q2);
            return FALSE;
        }
    }
    //此时队列2已遍历一遍，无满足要求者 
    checking=0;
    return FALSE;   
}
int main(){
    system(&quot;color 0B&quot;);
    printf(&quot;Input the \n&lt;BankMoney&gt; &lt;CloseTime&gt; \n&lt;NextCustomTime_LowerBound&gt; &lt;NextCustomTime_UpperBound&gt;\n&quot;);
    printf(&quot;&lt;CustomDurTime_LowerBound&gt; &lt;CustomDurTime_UpperBound&gt; \n&lt;CustomAmount_LowerBound&gt; &lt;CustomAmount_UpperBound&gt;:\n&quot;);//让用户输入起始参数
    scanf(&quot;%d%d%d%d%d%d%d%d&quot;,&amp;BankMoney,&amp;CloseTime,&amp;NextCustomTime_LowerBound,&amp;NextCustomTime_UpperBound, \
    &amp;CustomDurTime_LowerBound,&amp;CustomDurTime_UpperBound,&amp;CustomAmount_LowerBound,&amp;CustomAmount_UpperBound);
    Init();
    MORE=1;
    ShowBox();
    while(MORE){
        Event ev;
        DeleteEventFromListByPos(el,1,&amp;ev);

        while(Time&lt;ev.occurtime){ //当前时间未到该时间发生的时间，则时间递增，体现时间连续性
            Time++;
            ShowBankandTimeText();
            ShowMessageText1();
            ShowQueueText();//更新各个文本
            Sleep(200); //延迟200ms
        }
        User usr;
        switch(ev.type){
            case ARR: //到来事件
                usr.id=++CustomNum;
                usr.arrtime=ev.occurtime;
usr.durtime=Random(CustomDurTime_LowerBound,CustomDurTime_UpperBound);
                usr.amount=(Random(0,1)==0?1:-1)*Random(CustomAmount_LowerBound,CustomAmount_UpperBound);
                EnQueue(&amp;q1,usr);
                ShowMessageText2(usr.id,1);
                RandNextCustomer();//随机生成下一个客户到来事件
                if(servingusr.id==0) //当前没有客户正在办理，则办理下一个
                //该情况出现在第一个客户或者之前队列以空但下一个客户未到来 
                    ServeNextCustomerInQueue1(&amp;q1); 
                break;
            case LEAVE: //离开事件
                ShowMessageText2(servingusr.id,2);
                TotalTime+=ev.occurtime-servingusr.arrtime+1;
                BankMoney+=servingusr.amount;
                if(servingusr.amount&gt;0){ //该客户是第二种业务（存款） 
                    moneybeforecheck=BankMoney-servingusr.amount;
                    Check(); //检查队列2
                }
                else if(servingusr.amount&lt;0 || checking){//该客户是第一种业务（取款）但来自队列2 
                    Check();//继续检查 
                }
                if(!checking) ServeNextCustomerInQueue1(&amp;q1);//不是正在检查队列2，则处理队列1下一个客户的办理 
                break;
            case CLOSE: //结束事件
                MORE=0;
                while(QueueLength(q1)){ //所有客户离开
                    DeQueue(&amp;q1,&amp;usr);
                    TotalTime+=Time-usr.arrtime;
                }
                while(QueueLength(q2)){
                    DeQueue(&amp;q2,&amp;usr);
                    TotalTime+=Time-usr.arrtime;
                }
                continue;
        }       
        Sleep(1000); //每个是事件延迟1s以便观看
    }
    ScreenHeight+=3;
    UI_SetConsoleScreenBufferSize(hout,WIDTH,ScreenHeight);
    UI_DrawBox(hout,1,UI_SetRect(0,ScreenHeight-1-2,WIDTH-1,ScreenHeight-1),F_RED);
    char t_awt[50];
    if(CustomNum)
        sprintf(t_awt,&quot;Average stay time: %d&quot;,TotalTime/CustomNum);
    else
        sprintf(t_awt,&quot;No Customer&quot;);
    UI_DrawText(hout,F_RED,t_awt,strlen(t_awt),ScreenHeight-1-1,1,WIDTH-1);
    MessageBox(NULL,t_awt,&quot;Close&quot;,MB_OK | MB_ICONINFORMATION); //输出平均停留时间
    ScreenHeight+=1;
    UI_SetConsoleScreenBufferSize(hout,WIDTH,ScreenHeight);
    COORD curpos;
    curpos.X=0;
    curpos.Y=ScreenHeight-1;
    SetConsoleCursorPosition(hout,curpos); 
    return 0;
}
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DS/">DS</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ds/lab1_Polynome" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/23/ds/lab1_Polynome/" class="article-date">
      <time datetime="2017-10-22T16:00:00.000Z" itemprop="datePublished">2017-10-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/23/ds/lab1_Polynome/">数据结构上机题1 一元稀疏多项式计算</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="一元稀疏多项式计算"><a href="#一元稀疏多项式计算" class="headerlink" title="一元稀疏多项式计算"></a>一元稀疏多项式计算</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>参考习题集81页1.5题一元稀疏多项式计算</p>
<ul>
<li>要求:<ul>
<li>禁止使用STL库。自己练习链表操作并实现。必须用链表。打钩区分成绩。最多三个√，以半个√为一档表明该项完成程度。检查结束后需要提交源代码。源代码发送到<a href="mailto:qiweizhen1997@163.com" target="_blank" rel="noopener">qiweizhen1997@163.com</a>。标注清楚姓名和学号。需不需要写实验报告看今年教务处要求。先别写。</li>
</ul>
</li>
<li>基础要求：<ul>
<li>最简单的输入输出:(一个√)<ol>
<li>输入并创建多项式(升序or降序，系数浮点型，指数整型)</li>
<li>输出多项式，项数+每项系数指数(升序or降序)</li>
<li>多项式相加(结果要输出)</li>
<li>多项式相减(结果要输出)</li>
</ol>
</li>
</ul>
</li>
<li>拓展：<ol>
<li>多项式乘法(一个√)</li>
<li>计算多项式在x处的值</li>
<li>多项式整理，支持乱序输入(2，3项共一个√)</li>
</ol>
</li>
<li>其他可选:<ol start="4">
<li>除法</li>
<li>友好的gui仿真界面</li>
<li>句法分析</li>
</ol>
</li>
<li>其余扩展自选<ul>
<li>由助教根据复杂度和完成度判断是否一个√</li>
</ul>
</li>
<li>注意事项：<ol>
<li>系数不允许出现0</li>
<li>基本要求可以用最简单的输入方法</li>
<li>检查过程中或者核对源代码时发现相似度非常高的代码，2人雷同分数除以2，3人除3</li>
</ol>
</li>
</ul>
<h2 id="测试截图"><a href="#测试截图" class="headerlink" title="测试截图"></a>测试截图</h2><p><img src="//l-x.me/2017/10/23/ds/lab1_Polynome/1.png" alt=""><br><img src="//l-x.me/2017/10/23/ds/lab1_Polynome/2.png" alt=""><br><img src="//l-x.me/2017/10/23/ds/lab1_Polynome/3.png" alt=""></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="C">    /*
        Last Update time: 2017-10-08 
        Version：1.2 
        Author：LinXiang (PB16020923) 
        Description：
            Polynome.
    */
    #include &lt;stdio.h&gt; 
    #include &lt;stdlib.h&gt;
    #include &lt;math.h&gt;
    #include &lt;string.h&gt; 
    #define OK 1
    #define ERROR 0 
    typedef int Status;
    typedef struct TermOfPolynome{
        double c;//Coefficient
        int e;//Exponent
        struct TermOfPolynome *next;
    }term;
    typedef term *poly;
    typedef struct PolynomeNode{
        poly thepoly;
        struct PolynomeNode* next;
    }polynode; 
    int Menu_Selected=0,NumOfPoly=0;
    polynode *list;//存放多个多项式的链表 
    char opt[5]={&#39;\0&#39;,&#39;+&#39;,&#39;-&#39;,&#39;*&#39;,&#39;/&#39;};
    //==================system===================
    void ShowMenu(){
        system(&quot;cls&quot;);
        //printf(&quot;0-退出\n1-添加多项式\n2-管理多项式\n3-计算\n4-求值\n&quot;);
        system(&quot;color 0B&quot;);
        printf(&quot;┏━━━━━━━━━━━━━━━━━━━━━━━┓\n&quot;);
        printf(&quot;┃                 多项式运算器V1.1             ┃\n&quot;);
        printf(&quot;┣━━━━━━━┳━━━━━━━┳━━━━━━━┫\n&quot;);
        printf(&quot;┃   0----退出  ┃ 1-添加多项式 ┃ 2-管理多项式 ┃\n&quot;);
        printf(&quot;┣━━━━━━━╋━━━━━━━╋━━━━━━━┫\n&quot;);
        printf(&quot;┃   3----计算  ┃   4----求值  ┃   5----求导  ┃\n&quot;);
        printf(&quot;┣━━━━━━━┻━━━━━━━┻━━━━━━━┫\n&quot;);
        printf(&quot;┃                    6-关于                    ┃\n&quot;);     
        printf(&quot;┗━━━━━━━━━━━━━━━━━━━━━━━┛\n&quot;);
    }
    void SendMessage(char *p){
        system(&quot;cls&quot;);
        int l=strlen(p),i;
        if(l/2*2!=l) l++;//使l能被2整除 
        printf(&quot;┏━&quot;);
        for(i=0;i&lt;l/2;i++){if(i==l/4-1) printf(&quot;信&quot;); else if(i==l/4) printf(&quot;息&quot;); else printf(&quot;━&quot;);} 
        printf(&quot;━┓\n┃  &quot;);
        printf(p); 
        if(strlen(p)!=l) printf(&quot; &quot;);//不是2的倍数长度则补空格 
        printf(&quot;  ┃\n┗━&quot;);
        for(i=0;i&lt;l/2;i++) printf(&quot;━&quot;);
        printf(&quot;━┛\n&quot;);
        system(&quot;pause&quot;);
    }
    void PrintTitle(char *s){
        printf(&quot;┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n&quot;);
        printf(&quot;┃                                   %s                                   ┃\n&quot;,s);
        printf(&quot;┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n&quot;);
    }
    void BackSpace(int n){//删除n个字符 
        int i;
        for(i=0;i&lt;n;i++) printf(&quot;\b&quot;);
        for(i=0;i&lt;n;i++) printf(&quot; &quot;);
        for(i=0;i&lt;n;i++) printf(&quot;\b&quot;);
    }
    int GetZeroNum(char *p){//计算浮点数末尾有几个0 
        char *q=p;
        int count=0;
        while(*q++!=&#39;.&#39;);
        while(*q){
            if(*q++==&#39;0&#39;) count++;
            else count=0;
        }
        return count; 
    }
    void ShowPoly(poly pl){
        if(pl-&gt;next==NULL) printf(&quot;0\n&quot;);
        else{
            term *q=pl-&gt;next; 
            while(q!=NULL){
                char s[100];
                sprintf(s,&quot;%6lf&quot;,q-&gt;c);//临时打印出系数 
                int zn=GetZeroNum(s);
                char text[10]=&quot;%s%.6lf&quot;;//格式文本 
                text[4]=6-zn+&#39;0&#39;;//修改该显示的小数位数，删尾0 
                printf(text,q-&gt;c&lt;0?&quot;\b&quot;:&quot;&quot;,q-&gt;c);//系数小于0,删&#39;+&#39; 
                if(q-&gt;e){//指数不为0
                    printf(&quot;%sX^%s%d%s&quot;,fabs(fabs(q-&gt;c)-1)&lt;1e-6?&quot;\b \b&quot;:&quot;&quot;\
                    ,q-&gt;e&lt;0?&quot;(&quot;:&quot;&quot;,q-&gt;e,q-&gt;e&lt;0?&quot;)&quot;:&quot;&quot;);
                }
                if(q-&gt;e==1) BackSpace(2);//删除&quot;^1&quot; 
                printf(&quot;+&quot;);
                q=q-&gt;next; 
            }
            printf(&quot;\b \n&quot;);
        }
    }
    void ShowAllPoly(polynode *list){
        int i;
        polynode *p=list-&gt;next;
        printf(&quot;==================================多项式列表==================================\n&quot;); 
        for(i=0;i&lt;NumOfPoly;i++,p=p-&gt;next){
            printf(&quot;(%d) &quot;,i+1);
            ShowPoly(p-&gt;thepoly);
        }
        printf(&quot;====================================共%2d个====================================\n&quot;,NumOfPoly); 
    }
    //======================term=====================
    term *MakeTerm(double c,int e){//创建一个项 
        term *p=(term *)malloc(sizeof(term));
        p-&gt;c=c;
        p-&gt;e=e;
        p-&gt;next=NULL;
        return p;
    }
    Status DeleteTermFromPolyByExponent(poly pl,int e){
        term *q=pl;
        while(q-&gt;next!=NULL &amp;&amp; q-&gt;next-&gt;e!=e){
            q=q-&gt;next;
        }
        if(q-&gt;next==NULL) return ERROR;
        else{
            term *r=q-&gt;next;
            q-&gt;next=q-&gt;next-&gt;next;
            free(r);
        }
        return OK;    
    }
    Status InsertTermToPolyInOrder(poly pl,term *t){//插入后该项将成为多项式的一部分或被销毁 
        term *q=pl;
        while(q-&gt;next!=NULL &amp;&amp; q-&gt;next-&gt;e&gt;t-&gt;e){
            q=q-&gt;next;
        }
        if(q-&gt;next==NULL){
            q-&gt;next=t;
            t-&gt;next=NULL;
        }
        else if(q-&gt;next-&gt;e==t-&gt;e){
            q-&gt;next-&gt;c+=t-&gt;c;
            free(t);
            if(fabs(q-&gt;next-&gt;c)&lt;1e-6) DeleteTermFromPolyByExponent(pl,q-&gt;next-&gt;e);
        }
        else{
             t-&gt;next=q-&gt;next;
             q-&gt;next=t;
        }
        return OK;
    }
    //======================poly=====================
    Status InitPoly(poly *pl){//这里传进指针的指针，是为了修改pl的值 
        *pl=MakeTerm(0,0);
        return OK;
    }
    Status DestoryPoly(poly *pl){
        term *q=*pl,*s;
        while(q!=NULL){
            s=q-&gt;next;
            free(q);
            q=s;
        }
        *pl=NULL;
        return OK;
    }
    Status AddPolyToList(polynode *list,poly pl){//把一个多项式加入到全局的列表里 
        polynode *p=list;
        while(p-&gt;next!=NULL) p=p-&gt;next;
        p-&gt;next=(polynode *)malloc(sizeof(polynode));
        p=p-&gt;next;
        p-&gt;thepoly=pl;
        p-&gt;next=NULL;
        NumOfPoly++;
    }
    Status DeletePolyFromListById(polynode *list,int id){
        polynode *p=list;
        int i=1;
        while(p-&gt;next!=NULL &amp;&amp; i++&lt;id) p=p-&gt;next;//找到要删除的前一个 
        if(p-&gt;next==NULL) return ERROR;
        polynode *q=p-&gt;next;
        p-&gt;next=p-&gt;next-&gt;next;
        DestoryPoly(&amp;(q-&gt;thepoly));
        free(q);
        NumOfPoly--;
        return OK;
    }
    poly LocatePolyById(polynode *list,int id){
        polynode *p=list-&gt;next;
        int i=1;
        while(p!=NULL &amp;&amp; i++&lt;id) p=p-&gt;next;
        return p-&gt;thepoly;
    }
    //======================calculate=====================
    poly Add(poly pl1,poly pl2){
        poly pl;
        InitPoly(&amp;pl);    
        term *q1=pl1-&gt;next,*q2=pl2-&gt;next,*q=pl;
        while(q1!=NULL &amp;&amp; q2!=NULL){
            if(q1-&gt;e&gt;q2-&gt;e){
                q-&gt;next=MakeTerm(q1-&gt;c,q1-&gt;e);
                q1=q1-&gt;next;
            } 
            else if(q1-&gt;e&lt;q2-&gt;e){
                q-&gt;next=MakeTerm(q2-&gt;c,q2-&gt;e);
                q2=q2-&gt;next;
            }
            else{
                if(fabs(q1-&gt;c+q2-&gt;c)&gt;1e-6) q-&gt;next=MakeTerm(q1-&gt;c+q2-&gt;c,q1-&gt;e);//不被抵消才加入 
                q1=q1-&gt;next;
                q2=q2-&gt;next; 
            }
            if(q-&gt;next!=NULL) q=q-&gt;next; //如果已经创建了下一项才后移 
        }
        while(q1!=NULL){
            q-&gt;next=MakeTerm(q1-&gt;c,q1-&gt;e);
            q1=q1-&gt;next;
            q=q-&gt;next; 
        } 
        while(q2!=NULL){
            q-&gt;next=MakeTerm(q2-&gt;c,q2-&gt;e);
            q2=q2-&gt;next;
            q=q-&gt;next; 
        } 
        return pl;    
    } 
    poly Subtract(poly pl1,poly pl2){
        poly pl;
        InitPoly(&amp;pl);    
        term *q1=pl1-&gt;next,*q2=pl2-&gt;next,*q=pl;
        while(q1!=NULL){
            term *tq1=MakeTerm(q1-&gt;c,q1-&gt;e);
            InsertTermToPolyInOrder(pl,tq1);
            q1=q1-&gt;next;
        }
        while(q2!=NULL){
            term *tq2=MakeTerm(-q2-&gt;c,q2-&gt;e);
            InsertTermToPolyInOrder(pl,tq2);
            q2=q2-&gt;next;
        }
        return pl;
    }
    poly Multiply(poly pl1,poly pl2){
        poly pl;
        InitPoly(&amp;pl);    
        term *q1=pl1-&gt;next,*q2=pl2-&gt;next,*q=pl;
        while(q1!=NULL){
            while(q2!=NULL){
                term *tq=MakeTerm(q1-&gt;c*q2-&gt;c,q1-&gt;e+q2-&gt;e);
                InsertTermToPolyInOrder(pl,tq);
                q2=q2-&gt;next;
            }
            q1=q1-&gt;next;
            q2=pl2-&gt;next;
        }
        return pl;    
    } 
    Status GetHighestE(poly pl,double *c,int *e){//取最高次的次数和系数 
        term *q=pl;
        if(q-&gt;next==NULL){
            *c=0;
            *e=0;
            return OK;
        }
        q=q-&gt;next;    
        *c=q-&gt;c;
        *e=q-&gt;e;
        return OK;
    }
    Status CopyPoly(poly *pl1,poly *pl2){//2to1
        InitPoly(pl1);
        term *q2=(*pl2)-&gt;next,*q1=*pl1;
        while(q2!=NULL){
            q1-&gt;next=MakeTerm(q2-&gt;c,q2-&gt;e);
            q2=q2-&gt;next;
            q1=q1-&gt;next;
        } 
        return OK;
    }
    Status Divide(poly pl1,poly pl2,poly *res,poly *left){//res,left传递指向poly类型的指针 
        CopyPoly(left,&amp;pl1);
        poly xnpl;
        InitPoly(&amp;xnpl);
        InitPoly(res);
        int de,e1,e2;
        double c1,c2;
        GetHighestE(pl2,&amp;c2,&amp;e2);
        GetHighestE(*left,&amp;c1,&amp;e1);    
        de=e1-e2;
        while(de&gt;=0 &amp;&amp; (*left)-&gt;next!=NULL){//余数与除数最高次之差大于0 且余式不为0 
            term *xn=MakeTerm(c1/c2,de);
            xnpl-&gt;next=xn;
            poly tmp=Multiply(pl2,xnpl);
            poly tmpleft=Subtract(*left,tmp);
            DestoryPoly(left);
            CopyPoly(left,&amp;tmpleft);
            DestoryPoly(&amp;tmpleft);
            InsertTermToPolyInOrder(*res,xn);
            GetHighestE(*left,&amp;c1,&amp;e1);    
            de=e1-e2;
        }
        return OK; 
    } 
    poly Calculate(poly pl1,poly pl2,int op){
        switch(op){
            case 1: return Add(pl1,pl2);
            case 2: return Subtract(pl1,pl2);
            case 3: return Multiply(pl1,pl2);
        }
    }
    double Value(poly pl,double x){//求值 
        term *q=pl-&gt;next;
        double sum=0;
        while(q!=NULL){
            sum+=q-&gt;c*pow(x,q-&gt;e);
            q=q-&gt;next; 
        }
        return sum;
    }
    poly Dfx(poly pl1){ //求导 
        poly pl;
        InitPoly(&amp;pl);    
        term *q1=pl1-&gt;next,*q=pl;
        while(q1!=NULL){
            if(q1-&gt;e){//非常数项 
                q-&gt;next=MakeTerm(q1-&gt;c*q1-&gt;e,q1-&gt;e-1);
                q=q-&gt;next;
            }
            q1=q1-&gt;next; 
        }
        return pl;    
    } 
    //======================menu=====================
    int Menu_Add(){
        double c;int e;
        system(&quot;cls&quot;);
        PrintTitle(&quot;添加&quot;);
        printf(&quot;依次输入每项的系数和指数，空格隔开，ctrl+z结束:\n&quot;);
        poly pl;
        InitPoly(&amp;pl);
        while(scanf(&quot;%lf&quot;,&amp;c)!=EOF){
            if(scanf(&quot;%d&quot;,&amp;e)==EOF){
                DestoryPoly(&amp;pl);
                return 1;
            } 
            if(fabs(c)&lt;1e-6) continue;
            term *t=MakeTerm(c,e);
            InsertTermToPolyInOrder(pl,t);
        }
        AddPolyToList(list,pl);
        return 0;
    }
    int Menu_Delete(){
        int s;
        system(&quot;cls&quot;);
        PrintTitle(&quot;管理&quot;);
        if(NumOfPoly==0) return 1;
        else ShowAllPoly(list);
        printf(&quot;\n选择一个多项式删除。输入序号数字(输入0返回): &quot;);
        scanf(&quot;%d&quot;,&amp;s);
        if(s&gt;0){
            if(DeletePolyFromListById(list,s)==ERROR) return 2;
            else return 0;
        }
        return -1;
    }
    int Menu_Calculate(){
        int s1,s2,op;
        system(&quot;cls&quot;);
        PrintTitle(&quot;计算&quot;);
        if(NumOfPoly==0) return 1;
        else ShowAllPoly(list);
        printf(&quot;\n选择两个多项式和一种运算符[ (1)+ (2)- (3)* (4)/ ]。\n依次输入多项式和运算符序号(空格隔开,回车结束,输入0返回): &quot;);
        scanf(&quot;%d&quot;,&amp;s1);
        if(s1==0) return 0; 
        scanf(&quot;%d&quot;,&amp;s2);
        if(s1&lt;0 || s2&lt;0 || s1&gt;NumOfPoly || s2&gt;NumOfPoly) return 2;
        scanf(&quot;%d&quot;,&amp;op);
        if(op&lt;=0 || op&gt;4) return 2;
        printf(&quot;\n===================================运算结果===================================\n&quot;);
        poly pl1=LocatePolyById(list,s1);
        poly pl2=LocatePolyById(list,s2);
        poly pl;
        poly left;
        if(op==4){
            if(pl2-&gt;next==NULL) return 3;
            Divide(pl1,pl2,&amp;pl,&amp;left);
        }
        else{
            pl=Calculate(pl1,pl2,op);
        }
        ShowPoly(pl1);
        printf(&quot;%c\n&quot;,opt[op]);
        ShowPoly(pl2);
        printf(&quot;=\n&quot;);
        ShowPoly(pl);
        if(op==4){
            printf(&quot;...\n&quot;);
            ShowPoly(left);
        }
        DestoryPoly(&amp;pl);
        if(op==4) DestoryPoly(&amp;left);
        printf(&quot;==============================================================================\n&quot;);
        system(&quot;pause&quot;)    ;
        return -1;    
    }
    int Menu_Value(){
        int s;
        double x; 
        system(&quot;cls&quot;);
        PrintTitle(&quot;求值&quot;);
        if(NumOfPoly==0) return 1;
        else ShowAllPoly(list);
        printf(&quot;\n选择一个多项式求值。\n依次输入多项式序号和X值(空格隔开,回车结束,输入0返回): &quot;);
        scanf(&quot;%d&quot;,&amp;s);
        if(s==0) return 0; 
        if(s&lt;0 || s&gt;NumOfPoly) return 2;
        scanf(&quot;%lf&quot;,&amp;x); 
        printf(&quot;\n===================================运算结果===================================\n&quot;);
        poly pl=LocatePolyById(list,s);
        ShowPoly(pl);
        printf(&quot;在 X = %lf 处的值为:\n%lf\n&quot;,x,Value(pl,x));    
        printf(&quot;==============================================================================\n&quot;);
        system(&quot;pause&quot;)    ;
        return -1;        
    }
    int Menu_Dfx(){ 
        int s,n;
        system(&quot;cls&quot;);
        PrintTitle(&quot;求导&quot;);
        if(NumOfPoly==0) return 1;
        else ShowAllPoly(list);
        printf(&quot;\n选择一个多项式求导。\n输入多项式序号和求导次数n(空格隔开,回车结束,输入0返回): &quot;);
        scanf(&quot;%d&quot;,&amp;s);
        if(s==0) return 0; 
        scanf(&quot;%d&quot;,&amp;n);
        if(n&lt;1 ||s&lt;0 || s&gt;NumOfPoly) return 2; 
        printf(&quot;\n===================================运算结果===================================\n&quot;);
        poly pl=LocatePolyById(list,s);
        printf(&quot;F(X)=&quot;);
        ShowPoly(pl);
        int i;
        poly tmp1,tmp2;
        CopyPoly(&amp;tmp2,&amp;pl);
        for(i=1;i&lt;=n;i++){
            printf(&quot;F(X)^(%d)=&quot;,i);
            tmp1=Dfx(tmp2);
            DestoryPoly(&amp;tmp2);
            CopyPoly(&amp;tmp2,&amp;tmp1);
            DestoryPoly(&amp;tmp1);
            ShowPoly(tmp2);
        }
        DestoryPoly(&amp;tmp2);
        printf(&quot;==============================================================================\n&quot;);
        system(&quot;pause&quot;)    ;
        return -1;
    }
    int About(){
        system(&quot;cls&quot;);
        printf(&quot;┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n&quot;);
        printf(&quot;┃                          About                           ┃\n&quot;);
        printf(&quot;┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫\n&quot;);
        printf(&quot;┃                PolynomeCalculator V1.1                   ┃\n&quot;);
        printf(&quot;┃                 Made by LX  2017.10.06                   ┃\n&quot;);
        printf(&quot;┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n&quot;);
        system(&quot;pause&quot;);
        return 0;
    }
    int main(){
        list=(polynode *)malloc(sizeof(polynode));
        list-&gt;next=NULL;
        ShowMenu();
        printf(&quot;请选择：&quot;);
        //printf(&quot;abcdefg\b\b\b12&quot;);
        scanf(&quot;%d&quot;,&amp;Menu_Selected);
        while(Menu_Selected){
            int status;
            switch(Menu_Selected){
                case 1: if(Menu_Add()==1) 
                            SendMessage(&quot;输入有误!系数个数与指数个数不匹配！&quot;);
                        else{
                            SendMessage(&quot;添加成功！&quot;);    
                        } 
                        break;
                case 2: status=Menu_Delete();
                        if(status==1) 
                            SendMessage(&quot;这里空空如也...&quot;);
                        else if(status==2){
                            SendMessage(&quot;输入的序号有误！&quot;);
                        }
                        else if(status==0){
                            SendMessage(&quot;删除成功&quot;);
                        }
                        break;    
                case 3:    status=Menu_Calculate();
                        if(status==1){
                            SendMessage(&quot;你需要先添加多项式~&quot;);
                        }         
                        else if(status==2){
                            SendMessage(&quot;输入的序号有误！&quot;);
                        }
                        else if(status==3){
                            SendMessage(&quot;0不能为除数！&quot;);
                        }
                        break;
                case 4: status=Menu_Value(); 
                        if(status==1){
                            SendMessage(&quot;你需要先添加多项式~&quot;);
                        }         
                        else if(status==2){
                            SendMessage(&quot;输入的序号和X值有误！&quot;);
                        }
                        break;    
                case 5: status=Menu_Dfx(); 
                        if(status==1){
                            SendMessage(&quot;你需要先添加多项式~&quot;);
                        }         
                        else if(status==2){
                            SendMessage(&quot;输入的序号和n值有误！&quot;);
                        }
                        break;    
                case 6: About();
                        break;
            }            
            ShowMenu();
            printf(&quot;请选择：&quot;);
            scanf(&quot;%d&quot;,&amp;Menu_Selected);
        }    
        return 0;
    }
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DS/">DS</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2019 Lyncien
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>