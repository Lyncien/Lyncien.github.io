<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="Lyncien">


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="Lyncien&#39;s homepage">
<meta property="og:url" content="https://l-x.me/page/2/index.html">
<meta property="og:site_name" content="Lyncien&#39;s homepage">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lyncien&#39;s homepage">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Lyncien&#39;s homepage" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Lyncien&#39;s homepage</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<script src="/js/head-pic.js" ></script> <!-- head-pic-flash by Lyncien -->
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic" id="head-pic"> <!-- head-pic-flash by Lyncien -->
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Lyncien</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:Lyncien@126.com" title="Email"></a>
                            
                                <a class="fa Leetcode" href="https://leetcode-cn.com/lyncien/" title="Leetcode"></a>
                            
                                <a class="fa GitHub" href="https://github.com/Lyncien" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/COD/">COD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Compiler/">Compiler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DS/">DS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hackergame2018/">Hackergame2018</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MCPS/">MCPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PC/">PC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Verilog/">Verilog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/感想/">感想</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Lyncien</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic" id="head-pic-mobile"> <!-- head-pic-flash by Lyncien -->
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Lyncien</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:Lyncien@126.com" title="Email"></a>
                            
                                <a class="fa Leetcode" target="_blank" href="https://leetcode-cn.com/lyncien/" title="Leetcode"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/Lyncien" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我">
</nav>
      <div class="body-wrap">
  
    <article id="post-alg/lab2" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/11/18/alg/lab2/" class="article-date">
      <time datetime="2018-11-17T16:00:00.000Z" itemprop="datePublished">2018-11-18</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/18/alg/lab2/">算法基础上机实验二 红黑树维护算法及其区间树应用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>红黑树维护算法及其区间树应用</p>
<h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><h4 id="（一）红黑树"><a href="#（一）红黑树" class="headerlink" title="（一）红黑树"></a>（一）红黑树</h4><p>红黑树是一棵二叉搜索树，是众多平衡二叉树中的一种，它可以保证在最坏情况下基本操作的时间复杂度为O(lgn)</p>
<p>红黑树的每个结点包含5个属性：color、key、left、right、parent，分别表示颜色、关键字、左孩子、右孩子、父亲。</p>
<p><img src="//l-x.me/2018/11/18/alg/lab2/clip_image002.jpg" alt="img"></p>
<p>红黑树有以下性质：</p>
<p>① 每个节点必须为红色或黑色； </p>
<p>② 根为黑色； </p>
<p>③ 树中的nil叶子为黑； </p>
<p>④ 若节点为红，则其两个孩子必为黑；</p>
<p>⑤ 每节点到其后代叶子的所有路径含有同样多的黑节点； </p>
<p>红黑树的基本操作：</p>
<h5 id="（1）左旋-右旋"><a href="#（1）左旋-右旋" class="headerlink" title="（1）左旋/右旋"></a>（1）左旋/右旋</h5><p>这是一种能保持二叉搜索树性质的局部操作。</p>
<p><img src="//l-x.me/2018/11/18/alg/lab2/clip_image004.jpg" alt="img"></p>
<p>以左旋为例，操作顺序如下：</p>
<p>① y←right[x] //记录指向y节点的指针</p>
<p>② right[x]←left[y], p[left[y]]←x //β连到x右</p>
<p>③ parent[y]←parent[x], parent[x]的左或右指针指向y //y连到p[x]</p>
<p>④ left[y]←x, parent[x]←y// x连到y左</p>
<p><img src="//l-x.me/2018/11/18/alg/lab2/clip_image006.jpg" alt="img"></p>
<p>​                      该操作的时间复杂度T(n)=O(1)</p>
<h5 id="（2）插入"><a href="#（2）插入" class="headerlink" title="（2）插入"></a>（2）插入</h5><p>这个操作是在二叉搜索树的插入操作上略作修改，分为三步：</p>
<p>①将z节点按BST树规则插入红黑树中，z是叶子节点；</p>
<p>②将z涂红；</p>
<p>③调整使其满足红黑树的性质；</p>
<p>调整过程分析如下：</p>
<p>Z插入之后，为红色结点，其两个孩子为黑色NIL，满足性质1，3，5，可能违反性质2，4，即z是（红色）根或者z的父亲是红色。</p>
<p>调整方案：通过旋转和改变颜色，自下而上调整（z进行上溯），使树满足红黑树性质。</p>
<p>(1)若z为根，将其涂黑；</p>
<p>(2)若z为非根，则p[z]存在</p>
<p>①若p[z]为黑，无需调整</p>
<p>②若p[z]为红，违反性质4，则需调整</p>
<p>具体来说分为6种情况：</p>
<p>case1~3为z的双亲p[z]是其祖父p[p[z]]的左孩子，*</p>
<p>case4~6为z的双亲p[z]是其祖父p[p[z]]的右孩子（与case1~3对称）。*</p>
<ul>
<li>Case1: z的叔叔y是红色，这时通过调整叔叔、父亲和祖父的颜色，将违反性质的结点上移，调整最多至根。若红色传播到根，将根涂黑，则树的黑高增1</li>
</ul>
<p><img src="//l-x.me/2018/11/18/alg/lab2/clip_image008.jpg" alt="img"></p>
<ul>
<li><p>Case 2：当z的叔叔y是黑色，且z是双亲p[z]的右孩子，这种情况通过左旋变换为Case3.</p>
</li>
<li><p>Case 3：当z的叔叔y是黑色，且z是双亲p[z]的左孩子</p>
</li>
</ul>
<p><img src="//l-x.me/2018/11/18/alg/lab2/clip_image010.jpg" alt="img"></p>
<p>调整算法的时间：O(logn)</p>
<p>整个插入算法的时间：O(logn)</p>
<h5 id="（3）删除"><a href="#（3）删除" class="headerlink" title="（3）删除"></a>（3）删除</h5><p>这个操作将树上的一个结点z删除，然后进行z的孩子的调整，使之满足二叉搜索树的性质，最后，然后红黑树性质被破坏，则需要进行颜色的调整。</p>
<p>首先是对删除结点z进行分类讨论，有3种情况：</p>
<ul>
<li><p>Case 1：z为叶子；</p>
</li>
<li><p>Case 2：z只有一个孩子(非空)</p>
</li>
</ul>
<p>case 1是case 2的特例，处理模式是一样</p>
<p>处理方式：删除z，连接x。这里x是z的中序后继；</p>
<p><img src="//l-x.me/2018/11/18/alg/lab2/clip_image012.jpg" alt="img"></p>
<ul>
<li>Case 3：z的两个孩子均非空；</li>
</ul>
<p>处理方式：</p>
<p>(1)找z的中序后继即找z的右子树中最左下节点y；</p>
<p>(2)删除y，将y的内容copy到z，再将y的右子连到p[y]左下。</p>
<p><img src="//l-x.me/2018/11/18/alg/lab2/clip_image014.jpg" alt="img"></p>
<p>最后分析颜色的调整：</p>
<p>删红点不影响，删黑点需要调整。</p>
<p>对于结点x，或是y的唯一孩子，或是哨兵nil[T]。</p>
<p>可以想象将y的黑色涂到x上，于是</p>
<p>①    若x是根，且原为黑，直接移去多余一层黑色(树黑高减1)，终止；</p>
<p>②    若x原为红，将y的黑色涂到x上，终止；</p>
<p>③    若x非根节点，且原为黑色，则x为双黑。通过变色、旋转使多余黑色向上传播，直到某个红色节点或传到根；</p>
<p>具体来说，分为8种情况，</p>
<p>case 1~4为x是p[x]的左子；*</p>
<p>case 5~8为x是p[x]的右子（对称地）*</p>
<p>以case1~4为例</p>
<ul>
<li>Case 1：x的兄弟w是红色（w是红，则 p[x]必黑）</li>
</ul>
<p>处理方式如图，目标是将情况变成Case2,3,4处理</p>
<p><img src="//l-x.me/2018/11/18/alg/lab2/clip_image016.jpg" alt="img"></p>
<ul>
<li>Case 2：x的黑兄弟w的两个孩子均为黑</li>
</ul>
<p>处理方式如图，目标是将 x上移到B，通过A和D的黑色上移</p>
<p><img src="//l-x.me/2018/11/18/alg/lab2/clip_image018.jpg" alt="img"></p>
<ul>
<li>Case 3：x的黑兄弟w的右子为黑且左子为红</li>
</ul>
<p>处理方式如图，目标是将case3转为case4</p>
<p><img src="//l-x.me/2018/11/18/alg/lab2/clip_image020.jpg" alt="img"></p>
<ul>
<li>Case 4：x的黑兄弟w的右子为红(左子为黑或红)</li>
</ul>
<p>x的黑色上移给B，B的原色下移给D，D将黑色下移给C和E，通过旋转解决矛盾点C</p>
<p><img src="//l-x.me/2018/11/18/alg/lab2/clip_image022.jpg" alt="img"></p>
<h4 id="（二）区间树"><a href="#（二）区间树" class="headerlink" title="（二）区间树"></a>（二）区间树</h4><p>区间树是对红黑树的扩张，其每个结点存储一个区间，包括low和high两个值，其中low作为红黑树的key。</p>
<p>为了实现重叠区间的查找，还需要为每个结点添加一个max域，其值为以该结点为根的子树的所有区间的最大端点。</p>
<p>（1）max值的计算：该节点的区间右端点、左子树max值、右子树max值三者中的最大值。</p>
<p>max值的维护：需要在旋转、插入和删除时进行调整。</p>
<p>①左旋后，y的max更新为x原来的max，x的max重新按上面的方法计算，时间复杂度为O(1)。</p>
<p><img src="//l-x.me/2018/11/18/alg/lab2/clip_image023.jpg" alt="img"></p>
<p>②插入z时，z的max值设为自己区间的右端点，然后对于从根到插入位置的每个结点，如果其max值小于z的max值，则更新为z的max值。时间复杂度为O(logn)。</p>
<p>③删除z时，如果z只有一个孩子或者没有孩子，则直接从z的父亲开始向上到根结点，依次重新计算max值。如z有左右孩子，在找到z的中序遍历后继y后，从y的父亲开始向上至根结点，依次计算max值。时间复杂度为O(logn)。</p>
<p>（2）重叠区间的查找：x从根结点开始，如果x为nil或待查找的区间与其重叠，则返回x。否则，x更新，如果x左孩子不为nil且max值大于待查找区间的左端点，则x更新为x的左孩子，反之更新为x的右孩子。</p>
<p>时间复杂度为O(logn)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
enum Color{
    RED,
    BLACK
};
typedef struct RBTreeNode{
    struct RBTreeNode *parent;
    struct RBTreeNode *left;
    struct RBTreeNode *right;
    Color color;
    int key;//low
    int high;//high
    int maxep;//子树中区间最大端点
}node;
class RBTree{
   public:
    RBTree();
    ~RBTree();
    struct RBTreeNode *root;
    struct RBTreeNode *nil;
    void Insert(node *z);
    void Delete(node *z);
    node* Search(int key);
    node* IntervalSearch(int low,int high);
    void Print();
    bool Overlap(int alow,int ahigh,int blow,int bhigh);
    void pn(node *x);
   private:
    void Updatemaxep(node *x);
    void Updatemaxep2(node *x);
    void _Print(node *x,int depth);
    void LRotate(node *x);
    void RRotate(node *x);
    void Insert_fixup(node *z);
    void Transplant(node *u,node *v);
    node *Minimum(node *x);
    void Delete_fixup(node *x);
};
int max(int a,int b){
    if(a &gt; b) return a;
    else return b;
}
RBTree::RBTree(){
    this-&gt;nil = new node;
    this-&gt;nil-&gt;color = BLACK;
    this-&gt;nil-&gt;left = NULL;
    this-&gt;nil-&gt;right = NULL;
    this-&gt;nil-&gt;parent = NULL;
    this-&gt;nil-&gt;key = -1;
    this-&gt;nil-&gt;high = -1;
    this-&gt;nil-&gt;maxep = -1;
    this-&gt;root = this-&gt;nil;
}
RBTree::~RBTree(){
    delete this-&gt;nil;
}
void RBTree::Updatemaxep(node *x){
    x-&gt;maxep = max(x-&gt;high,max(x-&gt;left-&gt;maxep,x-&gt;right-&gt;maxep));
}
void RBTree::LRotate(node *x){//左旋
    node *y = x-&gt;right;
    x-&gt;right = y-&gt;left;
    if(y-&gt;left != this-&gt;nil)
        y-&gt;left-&gt;parent = x;
    y-&gt;parent = x-&gt;parent;
    if(x-&gt;parent == this-&gt;nil)
        this-&gt;root = y;
    else if(x == x-&gt;parent-&gt;left)
        x-&gt;parent-&gt;left = y;
    else
        x-&gt;parent-&gt;right = y;
    y-&gt;left = x;
    x-&gt;parent = y;
    y-&gt;maxep = x-&gt;maxep;//区间树维护maxep
    Updatemaxep(x);//区间树维护maxep
}
void RBTree::RRotate(node *x){//右旋
    node *y = x-&gt;left;
    x-&gt;left = y-&gt;right;
    if(y-&gt;right != this-&gt;nil)
        y-&gt;right-&gt;parent = x;
    y-&gt;parent = x-&gt;parent;
    if(x-&gt;parent == this-&gt;nil)
        this-&gt;root = y;
    else if(x == x-&gt;parent-&gt;right)
        x-&gt;parent-&gt;right = y;
    else
        x-&gt;parent-&gt;left = y;
    y-&gt;right = x;
    x-&gt;parent = y;
    y-&gt;maxep = x-&gt;maxep;//区间树维护maxep
    Updatemaxep(x);//区间树维护maxep
}
void RBTree::Insert_fixup(node *z){//插入后为保存红黑树性质而作的调整
    while(z-&gt;parent-&gt;color == RED){ //父亲是黑则无需调整，父亲是红也保证了父亲存在（不是nil）,并且祖父存在
        if(z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left){//父亲是祖父的左孩子
            node *y = z-&gt;parent-&gt;parent-&gt;right;//记录叔节点
            if(y-&gt;color == RED){//叔是红
                z-&gt;parent-&gt;color = BLACK;//父亲变黑
                y-&gt;color = BLACK;//叔变黑
                z-&gt;parent-&gt;parent-&gt;color = RED;//祖父变红
                z = z-&gt;parent-&gt;parent;//问题向上转移两层
            }
            else if(z == z-&gt;parent-&gt;right){//叔是黑
                //z是父亲的右孩子，则对z父亲左旋，并且新的z是原来z的父亲，且是原来z的左孩子，统一按下面的情况处理
                    z = z-&gt;parent;
                    LRotate(z);
            }
            else{
                z-&gt;parent-&gt;color = BLACK;//父变黑
                z-&gt;parent-&gt;parent-&gt;color = RED;//祖变红
                RRotate(z-&gt;parent-&gt;parent);//把黑色父亲旋转到祖父的位置，此时红左孩还是左孩，红祖父变成右孩子
            }
        }
        else{//对称情况，父亲是祖父的右孩子
            node *y = z-&gt;parent-&gt;parent-&gt;left;//记录叔节点
            if(y-&gt;color == RED){//叔是红
                z-&gt;parent-&gt;color = BLACK;//父亲变黑
                y-&gt;color = BLACK;//叔变黑
                z-&gt;parent-&gt;parent-&gt;color = RED;//祖父变红
                z = z-&gt;parent-&gt;parent;//问题向上转移两层
            }
            else if(z == z-&gt;parent-&gt;left){//z是父亲的左孩子，则对z父亲右旋，并且新的z是原来z的父亲，且是原来z的右孩子，统一按下面的情况处理
                    z = z-&gt;parent;
                    RRotate(z);
            }
            else{
                z-&gt;parent-&gt;color = BLACK;//父变黑
                z-&gt;parent-&gt;parent-&gt;color = RED;//祖变红
                LRotate(z-&gt;parent-&gt;parent);//把黑色父亲旋转到祖父的位置，此时红右孩还是右孩，红祖父变成左孩子
            }
        }
    }
    this-&gt;root-&gt;color = BLACK;
}
void RBTree::Insert(node *z){//插入
    node *y = this-&gt;nil;
    node *x = this-&gt;root;
    z-&gt;left = this-&gt;nil;
    z-&gt;right = this-&gt;nil;
    z-&gt;color = RED;
    z-&gt;maxep = z-&gt;high;//区间树维护maxep
    while(x != this-&gt;nil){
        x-&gt;maxep = max(x-&gt;maxep,z-&gt;maxep);//区间树维护maxep,从根到z的路径上的节点更新maxep
        y = x;
        if(z-&gt;key &lt; x-&gt;key)
            x = x-&gt;left;
        else
            x = x-&gt;right;
    }
    z-&gt;parent = y;
    if(y == this-&gt;nil)
        this-&gt;root = z;
    else if(z-&gt;key &lt; y-&gt;key)
        y-&gt;left = z;
    else
        y-&gt;right = z;
    Insert_fixup(z);
}
node* RBTree::Minimum(node *x){//以x为根的子树中的最小key的节点
    while(x-&gt;left != this-&gt;nil)
        x = x-&gt;left;
    return x;
}
void RBTree::Transplant(node *u,node *v){//以v代替u，这里没有处理u和v的孩子,注意：u/v各自的指向结点并没有改变
    if(u-&gt;parent == this-&gt;nil)//u是根
        this-&gt;root = v;
    else if(u == u-&gt;parent-&gt;left)
        u-&gt;parent-&gt;left = v;
    else
        u-&gt;parent-&gt;right = v;
    v-&gt;parent = u-&gt;parent;
}
void RBTree::pn(node *x){
    printf(&quot;[%d,%d]|%d(%s)\n&quot;,x-&gt;key,x-&gt;high,x-&gt;maxep,x-&gt;color==RED?&quot;R&quot;:&quot;B&quot;);
}
void RBTree::Delete_fixup(node *x){
    while(x != this-&gt;root &amp;&amp; x-&gt;color == BLACK){
        if(x == x-&gt;parent-&gt;left){
            node *w = x-&gt;parent-&gt;right;
            if(w-&gt;color == RED){
                w-&gt;color = BLACK;
                x-&gt;parent-&gt;color = RED;
                LRotate(x-&gt;parent);
                w = x-&gt;parent-&gt;right;
            }
            if(w-&gt;left-&gt;color == BLACK &amp;&amp; w-&gt;right-&gt;color == BLACK){
                w-&gt;color = RED;
                x = x-&gt;parent;
            }
            else{
                if(w-&gt;right-&gt;color == BLACK){
                    w-&gt;left-&gt;color = BLACK;
                    w-&gt;color = RED;
                    RRotate(w);
                    w = x-&gt;parent-&gt;right;
                }
                w-&gt;color = x-&gt;parent-&gt;color;
                x-&gt;parent-&gt;color = BLACK;
                w-&gt;right-&gt;color = BLACK;
                LRotate(x-&gt;parent);
                x = this-&gt;root;

            }
        }
        else{//x == x-&gt;parent-&gt;right
            node *w = x-&gt;parent-&gt;left;
            if(w-&gt;color == RED){
                w-&gt;color = BLACK;
                x-&gt;parent-&gt;color = RED;
                RRotate(x-&gt;parent);
                w = x-&gt;parent-&gt;left;
            }
            if(w-&gt;right-&gt;color == BLACK &amp;&amp; w-&gt;left-&gt;color == BLACK){
                w-&gt;color = RED;
                x = x-&gt;parent;
            }
            else{
                if(w-&gt;left-&gt;color == BLACK){
                    w-&gt;right-&gt;color = BLACK;
                    w-&gt;color = RED;
                    LRotate(w);
                    w = x-&gt;parent-&gt;left;
                }
                w-&gt;color = x-&gt;parent-&gt;color;
                x-&gt;parent-&gt;color = BLACK;
                w-&gt;left-&gt;color = BLACK;
                RRotate(x-&gt;parent);
                x = this-&gt;root;
            }
        }
    }
    x-&gt;color = BLACK;
}
void RBTree::Updatemaxep2(node *x){
    while(x != this-&gt;nil){
        Updatemaxep(x);
        x=x-&gt;parent;
    }
}

void RBTree::Delete(node *z){
    node *x;
    node *y = z;
    Color y_original_color = y-&gt;color;
    if(z-&gt;left == this-&gt;nil){//没有左孩子或者没有孩子
        x = z-&gt;right;//可能是空
        Transplant(z,z-&gt;right);
        Updatemaxep2(z-&gt;parent);

    }
    else if(z-&gt;right == this-&gt;nil){//没有右孩子但有左孩子
        x = z-&gt;left;
        Transplant(z,z-&gt;left);
        Updatemaxep2(z-&gt;parent);

    }//上面两种情况，直接删除z,以z的一个孩子代替z
    else{//有左右孩子
        y = Minimum(z-&gt;right);//寻找z在中序遍历中的下一个结点，以此为新的y，并且y没有左孩子
        y_original_color = y-&gt;color;
        node *g = y-&gt;parent;
        x = y-&gt;right;
        if(y-&gt;parent == z){//y的父亲是z，则y就是z的右孩子
            x-&gt;parent = y;
        }
        else{//y是z的右子树中最小者，但不是z的右孩子
            //if(y-&gt;right != this-&gt;nil)
            Transplant(y,y-&gt;right);
            y-&gt;right = z-&gt;right;
            y-&gt;right-&gt;parent = y;
        }
        Transplant(z,y);//用y代替z
        y-&gt;left = z-&gt;left;
        y-&gt;left-&gt;parent = y;
        y-&gt;color = z-&gt;color;
        Updatemaxep2(g);
    }
    if(y_original_color == BLACK)
        Delete_fixup(x);
}

void RBTree::_Print(node *x,int depth){
    if(x != this-&gt;nil){
        _Print(x-&gt;right,depth+1);
        for(int i = 0;i &lt; depth - 1;i++){
            printf(&quot;          &quot;);
        }
        printf(&quot;[%d,%d]|%d(%s)\n&quot;,x-&gt;key,x-&gt;high,x-&gt;maxep,x-&gt;color==RED?&quot;R&quot;:&quot;B&quot;);
        _Print(x-&gt;left,depth+1);
    }
}
void RBTree::Print(){
    node *p = this-&gt;root;
    printf(&quot;------------------------------------------------------------------------------------\n&quot;);
    _Print(this-&gt;root,1);
    printf(&quot;------------------------------------------------------------------------------------\n&quot;);
}
node* RBTree::Search(int key){
    node *x =this-&gt;root;
    while(x != this-&gt;nil &amp;&amp; key != x-&gt;key)
        if(key &lt; x-&gt;key)
            x = x-&gt;left;
        else
            x = x-&gt;right;
    return x;
}
bool RBTree::Overlap(int alow,int ahigh,int blow,int bhigh){
    if(ahigh &lt; blow || alow &gt; bhigh)     // a &amp; b do not overlap
        return 0;
    return 1;
}
node* RBTree::IntervalSearch(int low,int high){
    node *x=this-&gt;root;
    while(x != this-&gt;nil &amp;&amp; !Overlap(low,high,x-&gt;key,x-&gt;high))
    {
        if(x-&gt;left != this-&gt;nil &amp;&amp; x-&gt;left-&gt;maxep &gt;= low)
            x = x-&gt;left;
        else
            x = x-&gt;right;
        }
    return x;
}

int main(){
    int sel;
    int i,n;
    char path[128] = &quot;in2.txt&quot;;
    int low,high;
    node *tmpnode;
    RBTree *T = new RBTree();
    while(1){
        printf(&quot;MENU:\n1-File\n2-Insert\n3-Delete\n4-Find\n5-Print\n6-Exit\nSel:&quot;);
        scanf(&quot;%d&quot;,&amp;sel);
        switch(sel){
            case 1:{
                //printf(&quot;Input file path:&quot;);
                //scanf(&quot;%s&quot;,path);
                FILE *fp=fopen(path,&quot;r&quot;);
                fscanf(fp,&quot;%d&quot;,&amp;n);
                for(i=1;i&lt;=n;i++){
                    node *p = new node;
                    fscanf(fp,&quot;%d %d&quot;,&amp;(p-&gt;key),&amp;(p-&gt;high));
                    T-&gt;Insert(p);
                    T-&gt;Print();
                }
                fclose(fp);
                break;
            }
            case 2:{
                printf(&quot;Input low and high:&quot;);
                scanf(&quot;%d%d&quot;,&amp;low,&amp;high);
                node *p = new node;
                p-&gt;key = low;
                p-&gt;high = high;
                T-&gt;Insert(p);
                T-&gt;Print();
                break;
            }
            case 3:{
                printf(&quot;Input low:&quot;);
                scanf(&quot;%d&quot;,&amp;low);
                if((tmpnode = T-&gt;Search(low)) == T-&gt;nil){
                    printf(&quot;can&#39;t find this node.\n&quot;);
                    break;
                }
                //printf(&quot;%d,%d,%d&quot;,tmpnode-&gt;key,tmpnode-&gt;high,tmpnode-&gt;maxep);
                T-&gt;Delete(tmpnode);
                T-&gt;Print();
                break;
            }
            case 4:{
                printf(&quot;Input low and high:&quot;);
                scanf(&quot;%d%d&quot;,&amp;low,&amp;high);
                if((tmpnode = T-&gt;IntervalSearch(low,high)) == T-&gt;nil)
                    printf(&quot;can&#39;t find.\n&quot;);
                else printf(&quot;[%d,%d]\n&quot;,tmpnode-&gt;key,tmpnode-&gt;high);
                break;
            }
            case 5:{
                T-&gt;Print();
                break;
            }
            case 6:{
                return 0;
            }
        }
    }
    delete T;
    return 0;
}

</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这次实验让我比较深入地了解了红黑树的性质和操作及其应用。红黑树是高级数据结构，它可以保证在最坏情况下基本操作的时间复杂度为O(lgn)，但编写的代码较为复杂，需要分清楚每种情况及其对应的处理，课本种对情况的分类十分精炼，有的情况不是并列的，不同的情况可能是相互转换的关系，需要仔细思考。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-mcps/lab1" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/11/12/mcps/lab1/" class="article-date">
      <time datetime="2018-11-11T16:00:00.000Z" itemprop="datePublished">2018-11-12</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/12/mcps/lab1/">汇编上机题1</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>把1~36的自然数按行顺序存入一个6*6的二维数组中，然后打印出该数组的左下半三角</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="assembly">.MODEL SMALL 

.DATA
    D136 DB 36 DUP (0)   

.CODE   

PROC PRINT_N ;打印换行符 
    PUSH AX  
    PUSH DX  
    MOV AH,2
    MOV DL,0Dh
    INT 21h  
    MOV DL,0Ah
    INT 21h   
    POP DX 
    POP AX      
    RET
ENDP
PROC PRINTC ;打印DL的字符
    PUSH AX 
    MOV AH,2
    INT 21h
    POP AX     
    RET
ENDP

.STARTUP  
;初始化数据
    MOV CX,36
    MOV BX,36
INIT_LOOP:
    DEC BX
    MOV D136[BX],CL
    LOOP INIT_LOOP

    MOV CX,0 
MAIN:
    MOV AL,6 ;AL=6
    MUL CH   ;AL=6*CH
    ADD AL,CL;AL=AL+CL AL为要打印的数的下标
    MOV BX,AX
    MOV AL,D136[BX] ;AL为要打印的数 
    MOV DL,10
    DIV DL ;AL/10,商在AL,余数在AH
    MOV DL,AL ;十位
    ADD DL,30H ;转为字符
    CALL PRINTC
    MOV DL,AH ;个位
    ADD DL,30H ;转为字符
    CALL PRINTC    
    CMP CH,CL
    JZ NEXTLINE ;行结束，进行判断
    MOV DL,32 ;否则打印空格
    CALL PRINTC
    INC CL
    JMP MAIN

NEXTLINE:
    CALL PRINT_N
    MOV CL,0 ;列=0
    INC CH   ;行++
    CMP CH,6 ;CH&lt;6则继续下一行 
    JNZ MAIN

.EXIT 

END
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MCPS/">MCPS</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-alg/lab1" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/11/11/alg/lab1/" class="article-date">
      <time datetime="2018-11-10T16:00:00.000Z" itemprop="datePublished">2018-11-11</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/11/alg/lab1/">算法基础上机实验一 求平面上n个顶点的最近点对问题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>求平面上n个顶点的最近点对问题</p>
<h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p><strong>分治法</strong></p>
<h5 id="1．先考虑一维的情形，即线段上最近点对。"><a href="#1．先考虑一维的情形，即线段上最近点对。" class="headerlink" title="1．先考虑一维的情形，即线段上最近点对。"></a>1．先考虑一维的情形，即线段上最近点对。</h5><p>用x轴上某个点m将S划分为2个子集S1和S2，使得S1={x∈S|x≤m}；S2={x∈S|x&gt;m}，S1∪S2=S ，S1∩S2=Φ，则线段上最近点对为以下三者中的距离最小者：</p>
<p>（1）左半边S1的最近点对</p>
<p>（2）右半边S2的最近点对</p>
<p>（3）跨越分点m的最近点对</p>
<p><img src="//l-x.me/2018/11/11/alg/lab1/clip_image002.png" alt="img"></p>
<p>左半边S1的最近点对和右半边S2的最近点对的求解可以递归地调用该过程。而跨越分点m的最近点对，我们可以将S1中的一点与S2中的每一点计算距离，但这将花费O(n^2)。</p>
<p>事实上，通过求解左右两个子问题，我们已经得到一个当前最近点对的距离δ，在S1中，任何一个宽度为δ的区间内只分布着一个点，否则，存在两点距离小于δ，同理，S2中也是。因此，我们只需要考虑[m-δ,m+δ]区间内的点对距离，在[m-δ,m]如果有点，只能有一个点，这个点就是S1中距离m最近的点。区间[m,m+δ]同理。如果这两个点都存在，则计算距离，并与δ比较，因此，只需要O(n)时间完成问题的合并。</p>
<p>m点的选取问题：任意选取分割点m，有可能造成划分出的子集S1和S2的不平衡，最坏情况下有递归式：</p>
<p>T(n) = T(n-1) + O(n)</p>
<p>其解为T(n)=O(n^2)</p>
<p>如果我们恰当地选取m，是S1和S2中点的数量基本相同，则有递归式：</p>
<p>T(n) = 2T(n/2) + O(n)</p>
<p>其解为T(n)=O(nlogn)</p>
<p>为了选取m，我们可以事先对这些点排序，取m为下标中位数的点的坐标。</p>
<h5 id="2-考虑二维的情况，即本次实验求解的问题。"><a href="#2-考虑二维的情况，即本次实验求解的问题。" class="headerlink" title="2. 考虑二维的情况，即本次实验求解的问题。"></a>2. 考虑二维的情况，即本次实验求解的问题。</h5><p>类似一维情况，将平面分为两个半平面，使两边各分布约一半的点，为了确定分割线x = m，先对所有点按x坐标进行排序，取m为下标中位数附近两个点的x的坐标的平均值。</p>
<p>递归地在S1和S2上解最接近点对问题，我们分别得到S1和S2中的最近点对的距离δ1和δ2。现设δ = min(δ1, δ2)。</p>
<p>现在考虑两个点分别在S1和S2中的情况。类似一维的情况，我们只需要考虑条带区域[m-δ,m]和[m,m+δ]中点对的距离，记这两个区域为P1和P2。</p>
<p><img src="//l-x.me/2018/11/11/alg/lab1/clip_image004.jpg" alt="img"></p>
<p>在一维的时候，距分割点距离为δ的2个区间P1[m-δ,m]和P2 [m,m+δ]中最多各有S中一个点，因而这两个点成为唯一的未检查过的最接近点对候选者。但在二维情况下，P1 [m-δ,m]中可能存在多个点，并且他们的距离大于δ，P2 [m,m+δ]同理。因此，最坏情况下，S1中的点可能都在P1 [m-δ,m]中，S2中的点可能都在P2 [m,m+δ]中，这样就需要花费O(n^2)来合并问题（检查跨越P1、P2的所有点对）。</p>
<p>事实上，我们不必检查如此多的点对，考虑P1中任意一点p,它若与P2中的点q构成最接近点对的候选者，则必有d(p,q)&lt; δ。显然，这样的点只会分布在一个δ×2δ的矩形R中，如下图。</p>
<p><img src="//l-x.me/2018/11/11/alg/lab1/clip_image006.jpg" alt="img"></p>
<p> 由δ的意义可知P2中任何2个S中的点的距离都不小于δ。我们可以将矩形R的长为2δ的边3等分，将它的长为δ的边2等分，形成6个（δ/2）×（2δ/3）的矩形。</p>
<p><img src="//l-x.me/2018/11/11/alg/lab1/clip_image008.jpg" alt="img"></p>
<p>若矩形R中有多于6个S中的点，则由抽屉原理易知至少有一个（δ/2）×（2δ/3）的小矩形中有2个以上S中的点。设a,b是这样2个点，它们位于同一小矩形中，则d(a,b)≤sqrt((δ/2)^2+(2δ/3)^2) &lt;δ ，这与δ的意义相矛盾。</p>
<p>由此可以推出矩形R中最多只有6个S中的点，极端情形如下图。</p>
<p><img src="//l-x.me/2018/11/11/alg/lab1/clip_image010.jpg" alt="img"></p>
<p>因此，在分治法的合并步骤中，我们最多只需要检查6×n/2=3n对候选者，而不是O(n^2)对候选者。但这不意味着我们可以在O(n)时间内完成分治法的合并步骤。因为我们并不确切地知道要检查哪6个点。</p>
<p>为了解决这个问题，我们需要将P1和P2中的点分别按其y坐标排序，则对P1中每一点最多只要检查P2中排好序的相继6个点。排序花费的时间为O(nlogn)。这样得到递归式</p>
<p>T(n) = 2T(n/2) + O(nlogn)</p>
<p>其解为T(n) = O(nlognlogn)</p>
<p>一种改进的方法是，在最开始的时候，在按x排序后，然后确定完m的坐标后，对所有点按y坐标排序，这样就不用在递归函数中使用排序，合并问题的时间取决于检查跨P1、P2点对的时间O(n)，有递归式</p>
<p>T(n) = 2T(n/2) + O(n)</p>
<p>其解为T(n) = O(nlogn)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;algorithm&gt;
#define INF 99999999
#define MAX_DOT_NUM 100000
using namespace std;
typedef struct _dot{
    double x;
    double y;
}dot;
typedef struct _dpair{
    double dis;
    dot dota;
    dot dotb;
}dpair;
int n;
dot *dots=new dot[MAX_DOT_NUM+1];
dpair dpairmin(dpair dp1,dpair dp2){
    return dp1.dis&lt;dp2.dis?dp1:dp2;
}
double distance(const dot &amp;a,const dot &amp;b){
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
double cmp(const dot &amp;a,const dot &amp;b){
    return a.x&lt;b.x || a.x==b.x &amp;&amp; a.y&lt;b.y;
}
double cmpy(const dot &amp;a,const dot &amp;b){
    return a.y&lt;b.y;
}
dpair minDistance(int l,int h){
    dpair tmpdp;
    if(l==h){
        tmpdp.dis=INF;
        return tmpdp;
    }
    if(l==h-1){
        tmpdp.dis=distance(dots[l],dots[h]);
        tmpdp.dota=dots[l];
        tmpdp.dotb=dots[h];
        return tmpdp;
    }
    int m=(l+h)/2;
    dpair dp1=minDistance(l,m);
    dpair dp2=minDistance(m+1,h);
    dpair dp=dpairmin(dp1,dp2);
    dot *ldots=new dot[MAX_DOT_NUM/2+2];
    dot *rdots=new dot[MAX_DOT_NUM/2+2];
    double xm=(dots[m].x+dots[m+1].x)/2;
    int k,i,nl,nr;
    for(k=m;k&gt;=l;k--){
        if(dots[k].x&gt;=xm-dp.dis)
            ldots[m-k+1]=dots[k];
        else
            break;
    }
    nl=m-k;
    sort(ldots+1,ldots+nl+1,cmpy);
    for(i=m+1;i&lt;=h;i++){
        if(dots[i].x&lt;=xm+dp.dis)
            rdots[i-m]=dots[i];
        else
            break;
    }
    nr=i-m-1;
    sort(rdots+1,rdots+nr+1,cmpy);
    int istart=1;
    for(k=1;k&lt;=nl;k++){
        for(i=istart;i&lt;=nr;i++){
            if(rdots[i].y-ldots[k].y&lt;=dp.dis){
                tmpdp.dis=distance(ldots[k],rdots[i]);
                tmpdp.dota=ldots[k];
                tmpdp.dotb=rdots[i];
                dp=dpairmin(dp,tmpdp);
            }
            else{
                istart=i-6&lt;1?1:i-6;
                break;
            }
        }
    }
    delete []ldots;
    delete []rdots;
    return dp;
}

int main(){
    int sel;
    int i;
    char path[128];
    srand(time(NULL));
    printf(&quot;MENU:\n1-INPUT\n2-FILE\n3-RANDOM\n&quot;);
    scanf(&quot;%d&quot;,&amp;sel);
    switch(sel){
        case 1:{
            printf(&quot;Input dots, the num of dots &#39;n&#39; in first line, the next n lines are &#39;x&#39; and &#39;y&#39; for each dots.\n&quot;);
            scanf(&quot;%d&quot;,&amp;n);
            for(i=1;i&lt;=n;i++)
                scanf(&quot;%lf %lf&quot;,&amp;(dots[i].x),&amp;(dots[i].y));
            break;
        }
        case 2:{
            printf(&quot;Input file path, the data format is same as 1-INPUT.\nFile path:&quot;);
            scanf(&quot;%s&quot;,path);
            FILE *fp=fopen(path,&quot;r&quot;);
            fscanf(fp,&quot;%d&quot;,&amp;n);
            for(i=1;i&lt;=n;i++)
                fscanf(fp,&quot;%lf %lf&quot;,&amp;(dots[i].x),&amp;(dots[i].y));
            fclose(fp);
            break;
        }
        case 3:{
            printf(&quot;Input n, the program will generate n dots randomly.\nn:&quot;);
            scanf(&quot;%d&quot;,&amp;n);
            for(i=1;i&lt;=n;i++){
                dots[i].x=rand()%100;
                dots[i].y=rand()%100;
            }
            break;
        }
    }
    sort(dots+1,dots+n+1,cmp);
    dpair dp=minDistance(1,n);
    printf(&quot;(%lf,%lf) and (%lf,%lf) is dot pair with the min distance: %lf.&quot;,dp.dota.x,dp.dota.y,dp.dotb.x,dp.dotb.y,dp.dis);
    return 0;
}

</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-article/learning_and_forgetting" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/10/27/article/learning_and_forgetting/" class="article-date">
      <time datetime="2018-10-26T16:00:00.000Z" itemprop="datePublished">2018-10-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/27/article/learning_and_forgetting/">学习与遗忘</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h4><p>之前一位大一的学弟问我微积分作业，我发现当时觉得还算简单的题，现在竟然已经不会做了。</p>
<p>而且每当考试前我都会发现，平时努力记下的知识，大部分已经生疏了。</p>
<p>我一直在想，如果所有的知识都将被遗忘，那么学习的意义在哪呢？</p>
<h4 id="学习？记忆"><a href="#学习？记忆" class="headerlink" title="学习？记忆?"></a>学习？记忆?</h4><p>学习多年，我相信大部分人和我一样，在认知上认为记忆只是学习的一步，但行动上记忆几乎成为学习的全部，无论是记笔记或是所谓的错题本，都是强行以记忆代替学习。</p>
<p>这些方法固然有效，在信息量小的时候增加强化次数以永久记忆，但在信息爆炸的现在，如何？</p>
<p>曾经我和同学探讨这个问题。</p>
<blockquote>
<p>“你们是如何记住那些复杂的公式呢？”</p>
<p>“记不住，马上推导的。”</p>
<p>“如果过程很繁杂，一时推导不出来呢？”</p>
<p>“那么就稍微思考下，查些资料。”</p>
<p>“如何记得推导过程？”</p>
<p>“学会了就记住了呀”</p>
</blockquote>
<p>这似乎陷入了死循环，如果很难记住一件事，那就需要记住这件事的前因后果。</p>
<h4 id="遗忘"><a href="#遗忘" class="headerlink" title="遗忘"></a>遗忘</h4><p>遗忘是我们最为讨厌的事情，我们憎恨因为遗忘让我们误了多少重要的事件，但有些痛苦的记忆却也因为始终不能遗忘而如附骨之蛆，让我们长期沉浸在痛苦中。所以，遗忘的所有这些究竟是因为什么呢？</p>
<p>百度百科给出的定义</p>
<blockquote>
<p>遗忘是对识记过的材料不能再认与回忆，或者错误的再认与回忆，是一种记忆的丧失。遗忘分为暂时性遗忘和永久性遗忘，前者指在适宜条件下还可能恢复记忆的遗忘；后者指不经重新学习就不可能恢复记忆的遗忘。</p>
</blockquote>
<p>Wikipedia给出的定义</p>
<blockquote>
<p><strong>Forgetting</strong> or <strong>disremembering</strong> is the apparent loss or modification of information already encoded and stored in an individual’s long-term memory.</p>
</blockquote>
<p>如此，遗忘是大脑的本能，它有助于调和新旧知识。</p>
<p>知识会被遗忘，技能也会生疏，他们是<code>强化次数</code>和<code>时间</code>的函数。</p>
<h4 id="临界点"><a href="#临界点" class="headerlink" title="临界点"></a>临界点</h4><p>回忆过去，会发现那些小时候背诵的诗文始终不会忘记，即使有些生疏，只要有些许提示或刺激，你就能很快记忆起来，这就是上面提到的<code>暂时性遗忘</code>，因为强化次数已经足够多。相反，对于那些考前恶补的知识，只有一次强化，不久之后便迅速忘记，这就是<code>永久性遗忘</code>。如果想要重新回忆起，几乎就是重新学习了。</p>
<p>那么，恰当地选择多个时间点进行强化，能事半功倍，艾宾浩斯遗忘曲线给出了一些似乎可行的时间点。</p>
<h4 id="学习的意义"><a href="#学习的意义" class="headerlink" title="学习的意义"></a>学习的意义</h4><p>关于记忆的问题，目前没有太多定论。这是自然规律，无法抗拒。这里不作太多讨论了。</p>
<p>我们学习总是有目的，或是记住各种知识点，获取各种技能提高自己的能力，亦或是显摆？…</p>
<p>但是时间有限，要考虑性价比问题。</p>
<p>我们总是习惯于学习各种花哨的， 包装了的， 需要大量机械记忆的知识，比如某些现成工具的各种参数，某些标准的具体细节。或许这些东西对我们当前的工作特别重要，稍微的输入就能带来一时的快感。</p>
<p>那么，长久呢？未来还会有更多的工具，更多的标准。</p>
<p>我有时也会陷入这种短期的，低思考密度的诱惑陷阱。</p>
<p>所以，我以后学习应该学习更加基础，原理性的东西。</p>
<p>当然，有人会说，如果你学习使用那些现成的部分，那么真的需要用时，还是要花时间的。</p>
<p>是啊，这时候就需要快速学习能力了。</p>
<p>这和核心知识的积淀一样重要。</p>
<p>我想这就是一个人的核心竞争力所在吧。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/感想/">感想</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-article/USTC_Hackergame2018_18" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/10/15/article/USTC_Hackergame2018_18/" class="article-date">
      <time datetime="2018-10-14T16:00:00.000Z" itemprop="datePublished">2018-10-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/15/article/USTC_Hackergame2018_18/">USTC Hackergame2018 之 “加密解密算法”</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="USTCHackergame2018之“加密解密算法”"><a href="#USTCHackergame2018之“加密解密算法”" class="headerlink" title="USTCHackergame2018之“加密解密算法”"></a>USTCHackergame2018之“加密解密算法”</h1><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<h4 id="加密算法和解密算法"><a href="#加密算法和解密算法" class="headerlink" title="加密算法和解密算法"></a>加密算法和解密算法</h4><p>提示：本题中使用的 base64 编码，采用已被广泛应用于各种场合的 RFC 4648 §5 标准。</p>
<p>小赵听到自己成为了信息安全大赛的创始人后感到非常吃惊：“我一个少院学生会的干事，怎么就成信息安全大赛的创始人了呢？”这也难怪，毕竟小赵后来成为了物理学院的学生。物理和信息安全，通常情况下可都是八杆子打不着的呢。</p>
<p>当然了，小赵作为物理学院的学生，和其他物理学院的学生一样，身上的浮躁劲儿可一点都不少，常常因为一点小成就而沾沾自喜。这不，因为个人安全上的不重视，小赵的某个学弟小郑，很快从小赵暗恋的女孩子手里拿到了小赵和她交流的加密算法的程序。小赵在得知此事后反而没有尽可能地息事宁人，反而公开宣称，由于解密算法目前没有公开，所以拿到了加密算法也没有什么用。看来小赵对于现代密码学，根本没什么全面深入的了解啊。</p>
<p>不过，即使小赵使用的是对称加密算法，分析出解密算法也并非易事——小赵对程序进行了混淆，而混淆的方法是使用 BrainFuck 虚拟机——这也正是小赵的底气所在。现在的任务是分析并读懂一段 BrainFuck 程序，从而将一段密文还原。小郑拿到的密文是：</p>
<pre><code class="JzRVPiVpqo4iDM8celyueIs4ff4DKeG3EMKihzuH">JzRVPiVpqo4iDM8celyueIs4ff4DKeG3EMKihzuH
</code></pre>
<p>现在小郑将这一任务交给了跃跃欲试的你。快来挖掘小赵的黑历史吧！</p>
<h4 id="FLAG-格式"><a href="#FLAG-格式" class="headerlink" title="FLAG 格式"></a>FLAG 格式</h4><p>以下是两条示例原文和密文：</p>
<blockquote>
<pre><code>QUICK_BROWN_FOXES_JUMP_OVER_THE_LAZY_DOG =&gt; aMRKoll07lcf49SIuPrNg8v5bMctTkfrQmchaEkF
quick-brown-foxes-jump-over-the-lazy-dog =&gt; p9dJ4Jsrj3oDy_KxMJ1N750NvUBtXVUGNPVALq5l
</code></pre></blockquote>
<ul>
<li>假设密文是 <code>p9dJ4Jsrj3oDy_KxMJ1N750NvUBtXVUGNPVALq5l</code></li>
<li>最后解得原文是 <code>quick-brown-foxes-jump-over-the-lazy-dog</code></li>
<li>则 FLAG 格式为 <code>flag{quick-brown-foxes-jump-over-the-lazy-dog}</code></li>
</ul>
<p>下面的输入输出框可以帮助测试原文是否已成功匹配加密过的 FLAG：</p>
<table>
<thead>
<tr>
<th>输入（合法）</th>
<th>输出（匹配）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>JzRVPiVpqo4iDM8celyueIs4ff4DKeG3EMKihzuH</code></td>
</tr>
</tbody>
</table>
<h4 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h4><p>本题使用的 BrainFuck 解释器所使用的内存空间可视为长度无限，每一个 Cell 的大小为 256，同时加减是循环的（即 255 加一为 0，反之 0 减一为 255），此外所有合法的八个程序字符外的字符将会被忽略。原文需要编码转换为输入 BrainFuck 解释器的格式，解释器的输出同样需要解码转换才能输出密文。下面以<code>QUICK_BROWN_FOXES_JUMP_OVER_THE_LAZY_DOG</code>为例。</p>
<p>编码过程如下：</p>
<ul>
<li>将原文分为四段，每段长度为十： <code>[QUICK_BROW, N_FOXES_JU, MP_OVER_TH, E_LAZY_DOG]</code></li>
<li>每一段按 Base64 的顺序映射到 0 和 63 之间的数字：<ul>
<li>第一段映射后结果为： <code>[16, 20, 8, 2, 10, 63, 1, 17, 14, 22]</code></li>
<li>第二段映射后结果为： <code>[13, 63, 5, 14, 23, 4, 18, 63, 9, 20]</code></li>
<li>依此类推</li>
</ul>
</li>
<li>将十个为一组的数字输入 BrainFuck 解释器</li>
</ul>
<p>解码过程如下：</p>
<ul>
<li>BrainFuck 解释器一次输出十个数字：<ul>
<li>第一段输出后结果为： <code>[154, 76, 209, 202, 232, 37, 165, 180, 251, 165]</code></li>
<li>第二段输出后结果为： <code>[28, 159, 248, 253, 146, 136, 174, 207, 171, 141]</code></li>
<li>依此类推</li>
</ul>
</li>
<li>每一段的每一个数字对 64 取模：<ul>
<li>第一段取模后结果为： <code>[26, 12, 17, 10, 40, 37, 37, 52, 59, 37]</code></li>
<li>第二段取模后结果为： <code>[28, 31, 56, 61, 18, 8, 46, 15, 43, 13]</code></li>
<li>依此类推</li>
</ul>
</li>
<li>每一段按 Base64 的顺序映射后拼接在一起： <code>[aMRKoll07l, cf49SIuPrN, g8v5bMctTk, frQmchaEkF]</code></li>
<li>将四段拼接后得到密文</li>
</ul>
<p>本题目内置了一个使用 JavaScript 编写的 BrainFuck 解释器（当然了，性能堪忧，不过一次加密还是很快的）。相关的文件位于<a href="bf.js"><code>bf.js</code></a>中。BrainFuck 源代码位于<a href="encrypt.bf"><code>encrypt.bf</code></a>中。</p>
</blockquote>
<p>encrypt.bf的BrainFuck代码如下</p>
<pre><code>/* author: @ustc_zzzz */ call(`,[-&gt;&gt;+++++++&gt;&gt;+++++&gt;&gt;+++&gt;&gt;++&gt;&gt;++++&gt;++++++&lt;&lt;+++&lt;&lt;+++++++++&lt;&lt;++++++++&lt;&lt;
++++++&lt;&lt;++++++++&lt;]&gt;[-&gt;&gt;+++++&gt;&gt;+++++++++&gt;&gt;+++++++++&gt;&gt;++&gt;&gt;++++&lt;+++++++++&lt;&lt;++++&lt;&lt;++++&lt;&lt;++&lt;&lt;++&lt;]&lt;,[-&gt;&gt;++
+++&gt;&gt;++++++++&gt;&gt;++++++&gt;&gt;+++++++&gt;&gt;+++++++&gt;++++++&lt;&lt;++++++&lt;&lt;++++++++&lt;&lt;+++&lt;&lt;+++&lt;&lt;++++++++&lt;]&gt;[-&gt;&gt;++++++++&gt;
&gt;+++&gt;&gt;+++++++&gt;&gt;++++&gt;&gt;+++++++++&lt;++++++&lt;&lt;+++++++++&lt;&lt;++&lt;&lt;+++++++++&lt;&lt;++++++++&lt;]&lt;,[-&gt;&gt;++++++++&gt;&gt;+++++++&gt;&gt;
++&gt;&gt;++&gt;&gt;+++++++++&gt;+++&lt;&lt;++++&lt;&lt;+++&lt;&lt;+++++&lt;&lt;++++++++&lt;&lt;++++++++&lt;]&gt;[-&gt;&gt;++++&gt;&gt;++++++++&gt;&gt;++++++&gt;&gt;++++++&gt;&gt;++
+++&lt;++++&lt;&lt;+++++++++&lt;&lt;++++++++&lt;&lt;+++++++&lt;&lt;++++&lt;]&lt;,[-&gt;&gt;+++++&gt;&gt;+++++++++&gt;&gt;+++&gt;&gt;++++&gt;&gt;++++&gt;+++&lt;&lt;++++++++&lt;
&lt;++++++&lt;&lt;+++++&lt;&lt;++++++&lt;&lt;++++++++&lt;]&gt;[-&gt;&gt;++++++&gt;&gt;++++++&gt;&gt;+++++&gt;&gt;++++++++&gt;&gt;+++++++&lt;++++++++&lt;&lt;++++++&lt;&lt;++
+++&lt;&lt;+++&lt;&lt;+++++++&lt;]&lt;,[-&gt;&gt;+++++++&gt;&gt;++++&gt;&gt;++++&gt;&gt;+++&gt;&gt;+++++++&gt;+++++++&lt;&lt;+++++++++&lt;&lt;+++++&lt;&lt;+++++&lt;&lt;+++++++
&lt;&lt;++++++++&lt;]&gt;[-&gt;&gt;+++&gt;&gt;++++&gt;&gt;++++&gt;&gt;+++++&gt;&gt;++++++&lt;++++&lt;&lt;+++&lt;&lt;++++++++&lt;&lt;+++++++&lt;&lt;+++++&lt;]&lt;,[-&gt;&gt;+++++&gt;&gt;++
&gt;&gt;++++&gt;&gt;+++&gt;&gt;++++++&gt;++&lt;&lt;+++++++&lt;&lt;++++&lt;&lt;+++++++++&lt;&lt;+++++++&lt;&lt;++++++++&lt;]&gt;[-&gt;&gt;++&gt;&gt;+++++++++&gt;&gt;+++++&gt;&gt;++++
++++&gt;&gt;+++++++++&lt;+++++++&lt;&lt;++&lt;&lt;++++&lt;&lt;+++&lt;&lt;++&lt;]&lt;,[-&gt;&gt;++++++&gt;&gt;+++++++&gt;&gt;+++&gt;&gt;++++++&gt;&gt;++++++++&gt;++&lt;&lt;++++&lt;&lt;+
++&lt;&lt;++++++++&lt;&lt;++++++&lt;&lt;++++++++&lt;]&gt;[-&gt;&gt;++++++&gt;&gt;++&gt;&gt;+++++++++&gt;&gt;++++&gt;&gt;++++++&lt;+++++&lt;&lt;++++&lt;&lt;++++++++&lt;&lt;++++
&lt;&lt;+++++++&lt;]&lt;,[-&gt;&gt;+++++++++&gt;&gt;++++++++&gt;&gt;++++++&gt;&gt;+++++++&gt;&gt;+++++++++&gt;++&lt;&lt;++++++++&lt;&lt;+++++&lt;&lt;+++++&lt;&lt;+++&lt;&lt;++
++++++&lt;]&gt;[-&gt;&gt;+++++++++&gt;&gt;+++++++&gt;&gt;+++++++++&gt;&gt;++++&gt;&gt;++&lt;+++++++&lt;&lt;+++++++++&lt;&lt;++&lt;&lt;+++&lt;&lt;++++++++&lt;]&lt;,[-&gt;&gt;++
&gt;&gt;++++++++&gt;&gt;++&gt;&gt;++++++&gt;&gt;+++++&gt;++++&lt;&lt;++++&lt;&lt;+++++++&lt;&lt;+++++++&lt;&lt;++++++++&lt;&lt;++++++++&lt;]&gt;[-&gt;&gt;+++++++&gt;&gt;++&gt;&gt;++
++++++&gt;&gt;+++++++&gt;&gt;++++&lt;++&lt;&lt;+++&lt;&lt;+++++++&lt;&lt;+++++&lt;&lt;++&lt;]&lt;,[-&gt;&gt;+++++++++&gt;&gt;+++++++&gt;&gt;+++++&gt;&gt;++++&gt;&gt;++&gt;+++++&lt;&lt;
+++++&lt;&lt;++&lt;&lt;++&lt;&lt;+++++&lt;&lt;++++++++&lt;]&gt;[-&gt;&gt;++++++++&gt;&gt;++++++&gt;&gt;++&gt;&gt;+++++&gt;&gt;+++++++++&lt;++++++++&lt;&lt;++++++++&lt;&lt;++++
&lt;&lt;++++&lt;&lt;+++++++++&lt;]&gt;++.&gt;++++++.&gt;++++++++.&gt;++++++++.&gt;+++.&gt;+++++.&gt;+++++.&gt;+++++++.&gt;++++.&gt;+++++++++.`)
</code></pre><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>学习一下BrainFuck语法</p>
<blockquote>
<p>Brainfuck是一种极小化的计算机语言，它是由Urban Müller在1993年创建的。由于fuck在英语中是脏话，这种语言有时被称为brainf*ck或brainf**k，甚至被简称为BF。</p>
</blockquote>
<blockquote>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;</td>
<td>指针加一</td>
</tr>
<tr>
<td>&lt;</td>
<td>指针减一</td>
</tr>
<tr>
<td>+</td>
<td>指针指向的字节的值加一</td>
</tr>
<tr>
<td>-</td>
<td>指针指向的字节的值减一</td>
</tr>
<tr>
<td>.</td>
<td>输出指针指向的单元内容（ASCⅡ码）</td>
</tr>
<tr>
<td>,</td>
<td>输入内容到指针指向的单元（ASCⅡ码）</td>
</tr>
<tr>
<td>[</td>
<td>如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处</td>
</tr>
<tr>
<td>]</td>
<td>如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处</td>
</tr>
</tbody>
</table>
</blockquote>
<blockquote>
<p>Brainfuck程序可以用下面的替换方法翻译成<a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">C语言</a>（假设ptr是char*类型）：</p>
<table>
<thead>
<tr>
<th>Brainfuck</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;</td>
<td>++ptr;</td>
</tr>
<tr>
<td>&lt;</td>
<td>–ptr;</td>
</tr>
<tr>
<td>+</td>
<td>++*ptr;</td>
</tr>
<tr>
<td>-</td>
<td>–*ptr;</td>
</tr>
<tr>
<td>.</td>
<td><a href="https://baike.baidu.com/item/putchar/4747878" target="_blank" rel="noopener">putchar</a>(*ptr);</td>
</tr>
<tr>
<td>,</td>
<td>*ptr =getch();</td>
</tr>
<tr>
<td>[</td>
<td>while (*ptr) {</td>
</tr>
<tr>
<td>]</td>
<td>}</td>
</tr>
</tbody>
</table>
<p><strong>当前位置清零</strong></p>
<p>[-] 将当前指针的值归零</p>
<p><strong>之前位置清零</strong></p>
<p>[[-]&lt;] 将当前指针以及之前的指针归零</p>
<p><strong>字符I/O</strong></p>
<p>,. 从键盘读取一个字符并输出到屏幕上。</p>
<p><strong>简单的循环</strong></p>
<p>,[.,] 这是一个连续从键盘读取字符并<a href="https://baike.baidu.com/item/%E5%9B%9E%E6%98%BE" target="_blank" rel="noopener">回显</a>到屏幕上的循环。注意，这里假定0表示输入结束，事实上有些系统并非如此。以-1和”未改变”作为判断依据的程序代码分别是”,+[-.,+]”和”,[.[-],]”。</p>
<p><strong>指针维护</strong></p>
<p>>,[.&gt;,] 通过移动指针保存所有的输入，供后面的程序使用。</p>
<p><strong>加法</strong></p>
<p>[-&gt;+&lt;]</p>
<p>把当前位置的值加到后面的单元中（破坏性的加，它导致左边的单元被归零）。</p>
</blockquote>
<p>观察原来的代码，发现是很多个循环</p>
<p>分行一下比较清楚，对第一个循环注释一下</p>
<pre><code class="C">, 
//a[0]=k;
[-&gt;&gt;+++++++&gt;&gt;+++++&gt;&gt;+++&gt;&gt;++&gt;&gt;++++&gt;++++++&lt;&lt;+++&lt;&lt;+++++++++&lt;&lt;++++++++&lt;&lt;++++++&lt;&lt;++++++++&lt;] 
//a[0]--; a[2]=7; a[4]=5; a[6]=3; a[8]=2; a[10]=4; a[11]=6; a[9]=3; a[7]=9; a[5]=8; a[3]=6; a[1]=8;
//a[0-11]*k
&gt;
[-&gt;&gt;+++++&gt;&gt;+++++++++&gt;&gt;+++++++++&gt;&gt;++&gt;&gt;++++&lt;+++++++++&lt;&lt;++++&lt;&lt;++++&lt;&lt;++&lt;&lt;++&lt;]
//a[1]--; 
&lt;
,
[-&gt;&gt;+++++&gt;&gt;++++++++&gt;&gt;++++++&gt;&gt;+++++++&gt;&gt;+++++++&gt;++++++&lt;&lt;++++++&lt;&lt;++++++++&lt;&lt;+++&lt;&lt;+++&lt;&lt;++++++++&lt;]
&gt;
[-&gt;&gt;++++++++&gt;&gt;+++&gt;&gt;+++++++&gt;&gt;++++&gt;&gt;+++++++++&lt;++++++&lt;&lt;+++++++++&lt;&lt;++&lt;&lt;+++++++++&lt;&lt;++++++++&lt;]
&lt;
,
[-&gt;&gt;++++++++&gt;&gt;+++++++&gt;&gt;++&gt;&gt;++&gt;&gt;+++++++++&gt;+++&lt;&lt;++++&lt;&lt;+++&lt;&lt;+++++&lt;&lt;++++++++&lt;&lt;++++++++&lt;]
&gt;
[-&gt;&gt;++++&gt;&gt;++++++++&gt;&gt;++++++&gt;&gt;++++++&gt;&gt;+++++&lt;++++&lt;&lt;+++++++++&lt;&lt;++++++++&lt;&lt;+++++++&lt;&lt;++++&lt;]
&lt;
,
[-&gt;&gt;+++++&gt;&gt;+++++++++&gt;&gt;+++&gt;&gt;++++&gt;&gt;++++&gt;+++&lt;&lt;++++++++&lt;&lt;++++++&lt;&lt;+++++&lt;&lt;++++++&lt;&lt;++++++++&lt;]
&gt;
[-&gt;&gt;++++++&gt;&gt;++++++&gt;&gt;+++++&gt;&gt;++++++++&gt;&gt;+++++++&lt;++++++++&lt;&lt;++++++&lt;&lt;+++++&lt;&lt;+++&lt;&lt;+++++++&lt;]
&lt;
,
[-&gt;&gt;+++++++&gt;&gt;++++&gt;&gt;++++&gt;&gt;+++&gt;&gt;+++++++&gt;+++++++&lt;&lt;+++++++++&lt;&lt;+++++&lt;&lt;+++++&lt;&lt;+++++++&lt;&lt;++++++++&lt;]
&gt;
[-&gt;&gt;+++&gt;&gt;++++&gt;&gt;++++&gt;&gt;+++++&gt;&gt;++++++&lt;++++&lt;&lt;+++&lt;&lt;++++++++&lt;&lt;+++++++&lt;&lt;+++++&lt;]
&lt;
,
[-&gt;&gt;+++++&gt;&gt;++&gt;&gt;++++&gt;&gt;+++&gt;&gt;++++++&gt;++&lt;&lt;+++++++&lt;&lt;++++&lt;&lt;+++++++++&lt;&lt;+++++++&lt;&lt;++++++++&lt;]
&gt;
[-&gt;&gt;++&gt;&gt;+++++++++&gt;&gt;+++++&gt;&gt;++++++++&gt;&gt;+++++++++&lt;+++++++&lt;&lt;++&lt;&lt;++++&lt;&lt;+++&lt;&lt;++&lt;]
&lt;
,
[-&gt;&gt;++++++&gt;&gt;+++++++&gt;&gt;+++&gt;&gt;++++++&gt;&gt;++++++++&gt;++&lt;&lt;++++&lt;&lt;+++&lt;&lt;++++++++&lt;&lt;++++++&lt;&lt;++++++++&lt;]
&gt;
[-&gt;&gt;++++++&gt;&gt;++&gt;&gt;+++++++++&gt;&gt;++++&gt;&gt;++++++&lt;+++++&lt;&lt;++++&lt;&lt;++++++++&lt;&lt;++++&lt;&lt;+++++++&lt;]
&lt;
,
[-&gt;&gt;+++++++++&gt;&gt;++++++++&gt;&gt;++++++&gt;&gt;+++++++&gt;&gt;+++++++++&gt;++&lt;&lt;++++++++&lt;&lt;+++++&lt;&lt;+++++&lt;&lt;+++&lt;&lt;++++++++&lt;]
&gt;
[-&gt;&gt;+++++++++&gt;&gt;+++++++&gt;&gt;+++++++++&gt;&gt;++++&gt;&gt;++&lt;+++++++&lt;&lt;+++++++++&lt;&lt;++&lt;&lt;+++&lt;&lt;++++++++&lt;]
&lt;
,
[-&gt;&gt;++&gt;&gt;++++++++&gt;&gt;++&gt;&gt;++++++&gt;&gt;+++++&gt;++++&lt;&lt;++++&lt;&lt;+++++++&lt;&lt;+++++++&lt;&lt;++++++++&lt;&lt;++++++++&lt;]
&gt;
[-&gt;&gt;+++++++&gt;&gt;++&gt;&gt;++++++++&gt;&gt;+++++++&gt;&gt;++++&lt;++&lt;&lt;+++&lt;&lt;+++++++&lt;&lt;+++++&lt;&lt;++&lt;]
&lt;
,
[-&gt;&gt;+++++++++&gt;&gt;+++++++&gt;&gt;+++++&gt;&gt;++++&gt;&gt;++&gt;+++++&lt;&lt;+++++&lt;&lt;++&lt;&lt;++&lt;&lt;+++++&lt;&lt;++++++++&lt;]
&gt;
[-&gt;&gt;++++++++&gt;&gt;++++++&gt;&gt;++&gt;&gt;+++++&gt;&gt;+++++++++&lt;++++++++&lt;&lt;++++++++&lt;&lt;++++&lt;&lt;++++&lt;&lt;+++++++++&lt;]
&gt;
++.&gt;++++++.&gt;++++++++.&gt;++++++++.&gt;+++.&gt;+++++.&gt;+++++.&gt;+++++++.&gt;++++.&gt;+++++++++.
</code></pre>
<p>每组都是两个循环，先输入a[0]，</p>
<p>进行a[0]次循环，每次循环给a[1-11]各加一个定值（等于加号个数），其中a[1]+=8，</p>
<p>然后进行a[1]=8*a[0]次循环，每次循环给a[2-11]各加一个定值</p>
<p>用C语言有针对性地把上面代码转为伪代码，并获得每个加号的个数</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
int tmp1[10];

void pflist(){
    printf(&quot;{&quot;);
    for(int i=0;i&lt;10;i++) printf(&quot;%d,&quot;,tmp1[i]);
    printf(&quot;\b}\n&quot;);
    memset(tmp1,0,sizeof(tmp1));
}

int main(){
    FILE *fp=fopen(&quot;encrypt.bf&quot;,&quot;r&quot;);
    char ch;
    int p=0;
    int a[20];
    int in_while;
    int in_add;
    int add_times=0;
    while((ch=fgetc(fp))!=EOF){
        //printf(&quot;%c&quot;,ch);
        if(ch!=&#39;+&#39; &amp;&amp; in_add){in_add=0;if(p&gt;=2){tmp1[p-2]+=add_times;};printf(&quot;%d\n&quot;,add_times);add_times=0;}
        switch(ch){
            case (int)&#39;&gt;&#39;: {p++;break;}
            case (int)&#39;&lt;&#39;: {p--;break;}
            case (int)&#39;[&#39;: {in_while=1;printf(&quot;while(a[%d]){\n&quot;,p);break;}
            case (int)&#39;]&#39;: {in_while=0;pflist();printf(&quot;}\n&quot;);break;}
            case (int)&#39;+&#39;: {if(!in_add){in_add=1;add_times++;printf(&quot;a[%d]+=&quot;,p);}else{add_times++;}break;}
            case (int)&#39;,&#39;: {printf(&quot;a[%d]=in()\n&quot;,p);break;}
            case (int)&#39;.&#39;: {printf(&quot;out(a[%d])\n&quot;,p);break;}
            default: {break;}
        }

    }
    return 0;
}

</code></pre>
<p>得到每个循环中的各个定值，原BrainFuck编写的加密程序可等效地转为如下C代码</p>
<pre><code class="c">#include &lt;stdio.h&gt;
int arr[10]={};
int a[10][10]={{7,6,5,8,3,9,2,3,4,6},{5,3,8,3,6,8,7,6,7,6},{8,8,7,5,2,3,2,4,9,3},{5,6,9,5,3,6,4,8,4,3},{7,7,4,5,4,5,3,9,7,7},{5,7,2,9,4,4,3,7,6,2},{6,6,7,8,3,3,6,4,8,2},{9,3,8,5,6,5,7,8,9,2},{2,8,8,7,2,7,6,4,5,4},{9,5,7,2,5,2,4,5,2,5}};
int b[10][10]={{2,5,2,9,4,9,4,2,9,4},{8,8,9,3,2,7,9,4,6,9},{4,4,7,8,8,6,9,6,4,5},{7,6,3,6,5,5,6,8,8,7},{5,3,7,4,8,4,3,5,4,6},{2,2,3,9,4,5,2,8,7,9},{7,6,4,2,8,9,4,4,5,6},{8,9,3,7,2,9,9,4,7,2},{2,7,5,2,7,8,3,7,2,4},{9,8,4,6,4,2,8,5,8,9}};
int c[10]={2,6,8,8,3,5,5,7,4,9};
int main(){
    int t;
    for(int i=0;i&lt;10;i++){
        scanf(&quot;%d&quot;,&amp;t);
        //printf(&quot;%d\n&quot;,t);
        for(int j=0;j&lt;10;j++){
            arr[j]+=(a[i][j]*t);
            arr[j]+=(b[i][j]*8*t);
        }
    }
    for(int j=0;j&lt;10;j++) printf(&quot;%d &quot;,(arr[j]+c[j])%256);
    return 0;
}
</code></pre>
<p>题目给的是base64映射后的字符串<code>JzRVPiVpqo4iDM8celyueIs4ff4DKeG3EMKihzuH</code></p>
<p>写如下Python代码转换回去</p>
<pre><code class="python">bmap=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_&quot;
def encode(l):
    s=&quot;&quot;
    for i in l:
        s=s+bmap[i]
    return s

def decode(s):
    l=[]
    for ch in s:
        for i in range(64):
            if bmap[i]==ch:
                l.append(i)
    return l

#print(decode(&quot;QUICK_BROWN_FOXES_JUMP_OVER_THE_LAZY_DOG&quot;))
s=&quot;JzRVPiVpqo4iDM8celyueIs4ff4DKeG3EMKihzuH&quot;
print(decode(s))
</code></pre>
<p>输出如下</p>
<pre><code>[9, 51, 17, 21, 15, 34, 21, 41, 42, 40, 56, 34, 3, 12, 60, 28, 30, 37, 50, 46, 30, 8, 44, 56, 31, 31, 56, 3, 10, 30, 6, 55, 4, 12, 10, 34, 33, 51, 46, 7]
</code></pre><p>分为4组</p>
<pre><code>[9, 51, 17, 21, 15, 34, 21, 41, 42, 40]
[56, 34, 3, 12, 60, 28, 30, 37, 50, 46]
[30, 8, 44, 56, 31, 31, 56, 3, 10, 30]
[6, 55, 4, 12, 10, 34, 33, 51, 46, 7]
</code></pre><p>这4组就是原4组数列经过加密程序所得到的，现在就是要求原来的数列，相当于解方程组，当然是在模64情况下（加密过程是模256的，但输出序列要进过base64之前又被模64了），</p>
<p>用Mathematica写如下代码</p>
<pre><code>a={{7,6,5,8,3,9,2,3,4,6},{5,3,8,3,6,8,7,6,7,6},{8,8,7,5,2,3,2,4,9,3},{5,6,9,5,3,6,4,8,4,3},{7,7,4,5,4,5,3,9,7,7},{5,7,2,9,4,4,3,7,6,2},{6,6,7,8,3,3,6,4,8,2},{9,3,8,5,6,5,7,8,9,2},{2,8,8,7,2,7,6,4,5,4},{9,5,7,2,5,2,4,5,2,5}}
b={{2,5,2,9,4,9,4,2,9,4},{8,8,9,3,2,7,9,4,6,9},{4,4,7,8,8,6,9,6,4,5},{7,6,3,6,5,5,6,8,8,7},{5,3,7,4,8,4,3,5,4,6},{2,2,3,9,4,5,2,8,7,9},{7,6,4,2,8,9,4,4,5,6},{8,9,3,7,2,9,9,4,7,2},{2,7,5,2,7,8,3,7,2,4},{9,8,4,6,4,2,8,5,8,9}}
c={2,6,8,8,3,5,5,7,4,9}
d=a+8*b


s={9, 51, 17, 21, 15, 34, 21, 41, 42, 40}
x={x1,x2,x3,x4,x5,x6,x7,x8,x9,x10}

NSolve[Mod[Dot[x,d]+c,64]==s,x,Integers]
</code></pre><p>对于第一组，可得</p>
<pre><code>{{x1 -> ConditionalExpression[
    33 + 64 C[1], (C[1] | C[2] | C[3] | C[4] | C[5] | C[6] | C[7] | 
       C[8] | C[9] | C[10]) \[Element] Integers], 
  x2 -> ConditionalExpression[
    53 + 64 C[2], (C[1] | C[2] | C[3] | C[4] | C[5] | C[6] | C[7] | 
       C[8] | C[9] | C[10]) \[Element] Integers], 
  x3 -> ConditionalExpression[
    37 + 64 C[3], (C[1] | C[2] | C[3] | C[4] | C[5] | C[6] | C[7] | 
       C[8] | C[9] | C[10]) \[Element] Integers], 
  x4 -> ConditionalExpression[
    37 + 64 C[4], (C[1] | C[2] | C[3] | C[4] | C[5] | C[6] | C[7] | 
       C[8] | C[9] | C[10]) \[Element] Integers], 
  x5 -> ConditionalExpression[
    62 + 64 C[5], (C[1] | C[2] | C[3] | C[4] | C[5] | C[6] | C[7] | 
       C[8] | C[9] | C[10]) \[Element] Integers], 
  x6 -> ConditionalExpression[
    28 + 64 C[6], (C[1] | C[2] | C[3] | C[4] | C[5] | C[6] | C[7] | 
       C[8] | C[9] | C[10]) \[Element] Integers], 
  x7 -> ConditionalExpression[
    53 + 64 C[7], (C[1] | C[2] | C[3] | C[4] | C[5] | C[6] | C[7] | 
       C[8] | C[9] | C[10]) \[Element] Integers], 
  x8 -> ConditionalExpression[
    41 + 64 C[8], (C[1] | C[2] | C[3] | C[4] | C[5] | C[6] | C[7] | 
       C[8] | C[9] | C[10]) \[Element] Integers], 
  x9 -> ConditionalExpression[
    33 + 64 C[9], (C[1] | C[2] | C[3] | C[4] | C[5] | C[6] | C[7] | 
       C[8] | C[9] | C[10]) \[Element] Integers], 
  x10 -> ConditionalExpression[
    55 + 64 C[10], (C[1] | C[2] | C[3] | C[4] | C[5] | C[6] | C[7] | 
       C[8] | C[9] | C[10]) \[Element] Integers]}}
</code></pre><p>直接取</p>
<pre><code>33,53,37,37,62,28,53,41,33,55
</code></pre><p>类似地对其他3组用Mathematica求解，然后利用上面的Python代码进行base64映射</p>
<pre><code>print(encode([33,53,37,37,62,28,53,41,33,55]))
print(encode([43,62,48,53,45,33,62,53,52,49]))
print(encode([53,52,62,43,55,47,55,43,44,53]))
print(encode([27,37,55,62,38,26,45,43,53,49]))
</code></pre><p>得</p>
<pre><code>h1ll-c1ph3
r-w1th-10x
10-r3v3rs1
bl3-matr1x
</code></pre><p>则有<code>flag{h1ll-c1ph3r-w1th-10x10-r3v3rs1bl3-matr1x}</code></p>
<p>答案正确！</p>
<p><img src="//l-x.me/2018/10/15/article/USTC_Hackergame2018_18/BaiduShurufa_2018-10-15_20-19-38.png" alt="BaiduShurufa_2018-10-15_20-19-38"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hackergame2018/">Hackergame2018</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-article/USTC_Hackergame2018_8" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/10/12/article/USTC_Hackergame2018_8/" class="article-date">
      <time datetime="2018-10-11T16:00:00.000Z" itemprop="datePublished">2018-10-12</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/12/article/USTC_Hackergame2018_8/">USTCHackergame2018之&#34;我是谁&#34;</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="USTCHackergame2018之”我是谁”"><a href="#USTCHackergame2018之”我是谁”" class="headerlink" title="USTCHackergame2018之”我是谁”"></a>USTCHackergame2018之”我是谁”</h1><p> 第一次参加这种夺旗赛，以前没接触过，马上上网查查资料，也只能做简单的题，花了两天，战果如下。</p>
<p><img src="//l-x.me/2018/10/12/article/USTC_Hackergame2018_8/BaiduShurufa_2018-10-12_15-59-22.png" alt=""></p>
<p>做出来的都是不需要很多知识的体力题，也是通过人数最多的那些。</p>
<p>“我是谁”这题好多人做出来，我是两天后才做出来。。</p>
<h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><hr>
<p>访问<a href="http://202.38.95.46:12005" target="_blank" rel="noopener">http://202.38.95.46:12005</a></p>
<p>显示</p>
<blockquote>
<p>Who am I?<br>「我是谁？」</p>
<p>「我从哪里来？」</p>
<p>「将到哪里去？」</p>
<p>据说有这样三个有趣的哲学问题。</p>
<p>现在，请帮我回答第一个问题吧。</p>
<h4 id="Can-you-tell-me-who-I-am"><a href="#Can-you-tell-me-who-I-am" class="headerlink" title="Can you tell me who I am?"></a>Can you tell me who I am?</h4><p>submit</p>
</blockquote>
<p>让提交一个字符串<br>如果随便填，会跳转到<br><a href="http://202.38.95.46:12005/identity" target="_blank" rel="noopener">http://202.38.95.46:12005/identity</a></p>
<p>显示</p>
<blockquote>
<p>I am not really sure whether your answer is right.</p>
<p>You should probably try again.</p>
</blockquote>
<p>之前一直以为信息在这个网页。。</p>
<p>User-Agent，Server，Cookie都试过了，不是</p>
<p>其实在原网页按F12查看Network<br>就可发现</p>
<blockquote>
<p>Status Code:418 I’M A TEAPOT</p>
</blockquote>
<p>填入 <code>TEAPOT</code> 提交，正确！！</p>
<p>显示</p>
<blockquote>
<p>Yes, I finally realized that I am a teapot!</p>
<p>This is my gift for you:</p>
<p>flag{i_canN0t_BReW_c0ffEE!}</p>
<p>Come to This Link, help me brew some tea, and you can get the 2nd FLAG!</p>
</blockquote>
<p>得到第一个Flag</p>
<p><code>flag{i_canN0t_BReW_c0ffEE!}</code></p>
<p>点This Link进入</p>
<p><a href="http://202.38.95.46:12005/the_super_great_hidden_url_for_brewing_tea" target="_blank" rel="noopener">http://202.38.95.46:12005/the_super_great_hidden_url_for_brewing_tea</a></p>
<p>显示</p>
<blockquote>
<p>Brewing tea is not so easy.</p>
<p>Try using other <em>methods</em> to request this page.</p>
</blockquote>
<p>http请求的method包括get post head等</p>
<p>用python写代码</p>
<pre><code class="python">import requests as re
response=re.request(&quot;post&quot;,&quot;http://202.38.95.46:12005/the_super_great_hidden_url_for_brewing_tea/&quot;)
print(response.status_code)
print(response.text)
print(response.headers)
</code></pre>
<p>输出了</p>
<blockquote>
<p>200</p>
<pre><code>    &lt;p&gt;The method &quot;POST&quot; is deprecated.&lt;/p&gt;
    &lt;p&gt;See RFC-7168 for more information.&lt;/p&gt;
</code></pre><p>{‘Content-Type’: ‘text/html; charset=utf-8’, ‘Content-Length’: ‘107’, ‘Server’: ‘Werkzeug/0.14.1 Python/3.6.6’, ‘Date’: ‘Fri, 12 Oct 2018 06:46:43 GMT’}<br>418</p>
</blockquote>
<p>上网搜索RFC-7168，官网为<a href="https://tools.ietf.org/html/rfc7168" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7168</a></p>
<p>发现是一个恶搞的协议，茶壶协议</p>
<pre><code>The Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances (HTCPCP-TEA)
</code></pre><p>类似的一个协议是RFC-2324，咖啡壶协议</p>
<pre><code>Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)
</code></pre><p>HTCPCP继承了HTTP，</p>
<p>但新增了method</p>
<blockquote>
<p>2.1.  BREW and POST Methods</p>
<p>   Control of a TEA-capable pot is performed, as described in the base<br>   HTCPCP specification, through the sending of BREW requests.  POST<br>   requests are treated equivalently, but they remain deprecated.  Tea<br>   production differs from coffee, however, in that a choice of teas is<br>   often provided for client selection before the tea is brewed.  To<br>   this end, a TEA-capable pot that receives a BREW message of content<br>   type “message/teapot” MUST respond in accordance with the URI<br>   requested, as below.</p>
</blockquote>
<p>并且</p>
<blockquote>
<ol>
<li><p>The “message/coffeepot” media type</p>
<p>The entity body of a POST or BREW request MUST be of Content-Type<br>“message/coffeepot”. Since most of the information for controlling<br>the coffee pot is conveyed by the additional headers, the content of<br>“message/coffeepot” contains only a coffee-message-body:</p>
<p>coffee-message-body = “start” | “stop”</p>
</li>
</ol>
</blockquote>
<p>header需要加<code>Content-Type = &quot;message/coffeepot&quot;</code></p>
<p>修改python代码</p>
<pre><code class="python">import requests as re
headers={&#39;Content-Type&#39;:&#39;message/teapot&#39;}
response=re.request(&quot;brew&quot;,&quot;http://202.38.95.46:12005/the_super_great_hidden_url_for_brewing_tea/black_tea&quot;,headers=headers)
print(response.status_code)
print(response.text)
print(response.headers)
</code></pre>
<p>输出了</p>
<blockquote>
<p>300<br>Supported tea type:<br>{‘Content-Type’: ‘text/html; charset=utf-8’, ‘Content-Length’: ‘19’, ‘Alternates’: ‘{“/the_super_great_hidden_url_for_brewing_tea/black_tea” {type message/teapot}}’, ‘Server’: ‘Werkzeug/0.14.1 Python/3.6.6’, ‘Date’: ‘Fri, 12 Oct 2018 07:56:21 GMT’}</p>
</blockquote>
<p>修改python代码，路径添加<code>black_tea</code></p>
<pre><code class="python">import requests as re
headers={&#39;Content-Type&#39;:&#39;message/teapot&#39;}
response=re.request(&quot;brew&quot;,&quot;http://202.38.95.46:12005/the_super_great_hidden_url_for_brewing_tea/black_tea&quot;,headers=headers)
print(response.status_code)
print(response.text)
print(response.headers)
</code></pre>
<p>输出了</p>
<blockquote>
<p>200<br>Here is your tea: flag{delivering_tea_to_DaLa0}<br>{‘Content-Type’: ‘text/html; charset=utf-8’, ‘Content-Length’: ‘47’, ‘Server’: ‘Werkzeug/0.14.1 Python/3.6.6’, ‘Date’: ‘Fri, 12 Oct 2018 07:33:46 GMT’}</p>
</blockquote>
<p>得到第二个Flag</p>
<p><code>flag{delivering_tea_to_DaLa0}</code></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hackergame2018/">Hackergame2018</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-cod/lab7_Pipeline-CPU" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/14/cod/lab7_Pipeline-CPU/" class="article-date">
      <time datetime="2018-06-13T16:00:00.000Z" itemprop="datePublished">2018-06-14</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/14/cod/lab7_Pipeline-CPU/">计算机组成原理上机实验7 流水线CPU</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><h3 id="设计一个MIPS指令集的CPU，"><a href="#设计一个MIPS指令集的CPU，" class="headerlink" title="设计一个MIPS指令集的CPU，"></a>设计一个MIPS指令集的CPU，</h3><h4 id="1、-基本要求："><a href="#1、-基本要求：" class="headerlink" title="1、    基本要求："></a>1、    基本要求：</h4><pre><code>a)    多周期
b)    包含16条指令
    i.    add addi addu sub subu 
    ii.    and andi or nor xor
    iii. bgtz bne j jr
    iv.    lw sw
</code></pre><h4 id="2、-扩展要求"><a href="#2、-扩展要求" class="headerlink" title="2、    扩展要求"></a>2、    扩展要求</h4><pre><code>a)    在16条的基础上，增加其他指令
b)    实现中断功能
c)    实现流水
d)    实现下载
</code></pre><h2 id="实验平台"><a href="#实验平台" class="headerlink" title="实验平台"></a>实验平台</h2><h4 id="EDA工具为ISE14-7，开发板型号为Digilent的Nexys3，FPGA型号为Spartan-6-XC6SLX16-CS324。"><a href="#EDA工具为ISE14-7，开发板型号为Digilent的Nexys3，FPGA型号为Spartan-6-XC6SLX16-CS324。" class="headerlink" title="EDA工具为ISE14.7，开发板型号为Digilent的Nexys3，FPGA型号为Spartan-6 XC6SLX16-CS324。"></a>EDA工具为ISE14.7，开发板型号为Digilent的Nexys3，FPGA型号为Spartan-6 XC6SLX16-CS324。</h4><h2 id="使用部件"><a href="#使用部件" class="headerlink" title="使用部件"></a>使用部件</h2><h4 id="开发板上的开关，7段数码管和按钮。"><a href="#开发板上的开关，7段数码管和按钮。" class="headerlink" title="开发板上的开关，7段数码管和按钮。"></a>开发板上的开关，7段数码管和按钮。</h4><h2 id="最终实现功能"><a href="#最终实现功能" class="headerlink" title="最终实现功能"></a>最终实现功能</h2><h4 id="1、实现五段流水线"><a href="#1、实现五段流水线" class="headerlink" title="1、实现五段流水线"></a>1、实现五段流水线</h4><h4 id="2、实现完全转发和冒险检测"><a href="#2、实现完全转发和冒险检测" class="headerlink" title="2、实现完全转发和冒险检测"></a>2、实现完全转发和冒险检测</h4><h4 id="3、实现36条指令"><a href="#3、实现36条指令" class="headerlink" title="3、实现36条指令"></a>3、实现36条指令</h4><h4 id="4、实现下载并在数码管上动态显示内存"><a href="#4、实现下载并在数码管上动态显示内存" class="headerlink" title="4、实现下载并在数码管上动态显示内存"></a>4、实现下载并在数码管上动态显示内存</h4><h2 id="详细设计过程"><a href="#详细设计过程" class="headerlink" title="详细设计过程"></a>详细设计过程</h2><h3 id="1、-MIPS指令格式"><a href="#1、-MIPS指令格式" class="headerlink" title="1、    MIPS指令格式"></a>1、    MIPS指令格式</h3><p>MIPS-IV指令集标准下的指令长度为32位，分为R型、I型和J型指令</p>
<p><img src="//l-x.me/2018/06/14/cod/lab7_Pipeline-CPU/pic1.png" alt=""><br>R-Tpye<br><img src="//l-x.me/2018/06/14/cod/lab7_Pipeline-CPU/pic2.png" alt=""><br>I-Tpye<br><img src="//l-x.me/2018/06/14/cod/lab7_Pipeline-CPU/pic3.png" alt=""><br>J-Tpye</p>
<p>它们的共同部分是26-31位的Op码，用来区分不同的指令，其中</p>
<p>（1）R-Type的指令Op=000000，再根据0-5位的Funct部分区分不同指令</p>
<p>（2）I-Type的指令0-15位为立即数，位扩展后用于直接计算或者访存和跳转偏移地址。Op=000001的I-Type指令，根据Rt的不同来区分。</p>
<p>（3）J-Type的指令除了Op之外，0-25位为立即数，位扩展后作为跳转地址偏移。<br>本次实现的36条指令，详细格式如下表</p>
<table>
<thead>
<tr>
<th><strong>Instr</strong></th>
<th><strong>31-26</strong></th>
<th><strong>25-21</strong></th>
<th><strong>20-16</strong></th>
<th><strong>15-11</strong></th>
<th><strong>10-6</strong></th>
<th><strong>5-0</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>op</strong></td>
<td><strong>rs</strong></td>
<td><strong>rt</strong></td>
<td><strong>rd</strong></td>
<td><strong>shamt</strong></td>
<td><strong>func</strong></td>
</tr>
<tr>
<td>SLL</td>
<td>000000</td>
<td>-</td>
<td><code>$2</code></td>
<td><code>$1</code></td>
<td>shamt</td>
<td>000000</td>
<td><code>$1</code>=<code>$2</code>&lt;&lt;shamt</td>
</tr>
<tr>
<td>SRL</td>
<td>-</td>
<td><code>$2</code></td>
<td><code>$1</code></td>
<td>shamt</td>
<td>000010</td>
<td><code>$1</code>=<code>$2</code>&gt;&gt;shamt</td>
</tr>
<tr>
<td>SRA</td>
<td>-</td>
<td><code>$2</code></td>
<td><code>$1</code></td>
<td>shamt</td>
<td>000011</td>
<td><code>$1</code>=<code>$2</code>&gt;&gt;&gt;shamt</td>
</tr>
<tr>
<td>SLLV</td>
<td><code>$3</code></td>
<td><code>$2</code></td>
<td><code>$1</code></td>
<td>-</td>
<td>000100</td>
<td><code>$1</code>=<code>$2</code>&lt;&lt;<code>$3</code></td>
</tr>
<tr>
<td>SRLV</td>
<td><code>$3</code></td>
<td><code>$2</code></td>
<td><code>$1</code></td>
<td>-</td>
<td>000110</td>
<td><code>$1</code>=<code>$2</code>&gt;&gt;<code>$3</code></td>
</tr>
<tr>
<td>SRAV</td>
<td><code>$3</code></td>
<td><code>$2</code></td>
<td><code>$1</code></td>
<td>-</td>
<td>000111</td>
<td><code>$1</code>=<code>$2</code>&gt;&gt;&gt;<code>$3</code></td>
</tr>
<tr>
<td>JR</td>
<td><code>$1</code></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>001000</td>
<td>PC=<code>$1</code></td>
</tr>
<tr>
<td>MOVZ</td>
<td><code>$3</code></td>
<td><code>$2</code></td>
<td><code>$1</code></td>
<td></td>
<td>001010</td>
<td>Set <code>$t1</code> = <code>$t2</code> if <code>$t3</code> is zero</td>
</tr>
<tr>
<td>MOVN</td>
<td><code>$3</code></td>
<td><code>$2</code></td>
<td><code>$1</code></td>
<td></td>
<td>001011</td>
<td>Set <code>$t1</code> = <code>$t2</code> if <code>$t3</code> is not zero</td>
</tr>
<tr>
<td>ADD</td>
<td><code>$2</code></td>
<td><code>$3</code></td>
<td><code>$1</code></td>
<td>-</td>
<td>100000</td>
<td><code>$1</code>=<code>$2</code>+<code>$3</code></td>
</tr>
<tr>
<td>ADDU</td>
<td><code>$2</code></td>
<td><code>$3</code></td>
<td><code>$1</code></td>
<td>-</td>
<td>100001</td>
<td><code>$1</code>=<code>$2</code>+<code>$3</code>(unsigned)</td>
</tr>
<tr>
<td>SUB</td>
<td><code>$2</code></td>
<td><code>$3</code></td>
<td><code>$1</code></td>
<td>-</td>
<td>100010</td>
<td><code>$1</code>=<code>$2</code>-<code>$3</code></td>
</tr>
<tr>
<td>SUBU</td>
<td><code>$2</code></td>
<td><code>$3</code></td>
<td><code>$1</code></td>
<td>-</td>
<td>100011</td>
<td><code>$1</code>=<code>$2</code>-<code>$3</code>(unsigned)</td>
</tr>
<tr>
<td>AND</td>
<td><code>$2</code></td>
<td><code>$3</code></td>
<td><code>$1</code></td>
<td>-</td>
<td>100100</td>
<td><code>$1</code>=<code>$2</code> and <code>$3</code></td>
</tr>
<tr>
<td>OR</td>
<td><code>$2</code></td>
<td><code>$3</code></td>
<td><code>$1</code></td>
<td>-</td>
<td>100101</td>
<td><code>$1</code>=<code>$2</code> or <code>$3</code></td>
</tr>
<tr>
<td>XOR</td>
<td><code>$2</code></td>
<td><code>$3</code></td>
<td><code>$1</code></td>
<td>-</td>
<td>100110</td>
<td><code>$1</code>=<code>$2</code> xor <code>$3</code></td>
</tr>
<tr>
<td>NOR</td>
<td><code>$2</code></td>
<td><code>$3</code></td>
<td><code>$1</code></td>
<td>-</td>
<td>100111</td>
<td><code>$1</code>=<code>$2</code> nor <code>$3</code></td>
</tr>
<tr>
<td>SLT</td>
<td><code>$2</code></td>
<td><code>$3</code></td>
<td><code>$1</code></td>
<td>-</td>
<td>101010</td>
<td>if(<code>$2</code>&lt;<code>$3</code>) <code>$1</code>=1 else <code>$1</code>=0</td>
</tr>
<tr>
<td>SLTU</td>
<td><code>$2</code></td>
<td><code>$3</code></td>
<td><code>$1</code></td>
<td>-</td>
<td>101011</td>
<td>if(<code>$2</code>&lt;<code>$3</code>) <code>$1</code>=1 else <code>$1</code>=0(unsigned)</td>
</tr>
<tr>
<td>BLTZ</td>
<td>000001</td>
<td><code>$1</code></td>
<td>00000</td>
<td>offset</td>
<td>if(<code>$1</code>&lt;0) PC=PC+4+(sign-extend)offset&lt;&lt;2</td>
</tr>
<tr>
<td>BGEZ</td>
<td><code>$1</code></td>
<td>00001</td>
<td>offset</td>
<td>if(<code>$1</code>&gt;=0) PC=PC+4+(sign-extend)offset&lt;&lt;2</td>
</tr>
<tr>
<td>J</td>
<td>000010</td>
<td>immediate</td>
<td>PC=PC[31:28]+immediate&lt;&lt;2</td>
</tr>
<tr>
<td>BEQ</td>
<td>000100</td>
<td><code>$1</code></td>
<td><code>$2</code></td>
<td>offset</td>
<td>if(<code>$1</code>==<code>$2</code>) PC=PC+4+(sign-extend)offset&lt;&lt;2</td>
</tr>
<tr>
<td>BNE</td>
<td>000101</td>
<td><code>$1</code></td>
<td><code>$2</code></td>
<td>offset</td>
<td>if(<code>$1</code>!=<code>$2</code>) PC=PC+4+(sign-extend)offset&lt;&lt;2</td>
</tr>
<tr>
<td>BLEZ</td>
<td>000110</td>
<td><code>$1</code></td>
<td>-</td>
<td>offset</td>
<td>if(<code>$1</code>&lt;=0) PC=PC+4+(sign-extend)offset&lt;&lt;2</td>
</tr>
<tr>
<td>BGTZ</td>
<td>000111</td>
<td><code>$1</code></td>
<td>-</td>
<td>offset</td>
<td>if(<code>$1</code>&gt;0) PC=PC+4+(sign-extend)offset&lt;&lt;2</td>
</tr>
<tr>
<td>ADDI</td>
<td>001000</td>
<td><code>$2</code></td>
<td><code>$1</code></td>
<td>immediate</td>
<td><code>$1</code>=<code>$2</code>+(sign-extend)immediate</td>
</tr>
<tr>
<td>ADDIU</td>
<td>001001</td>
<td><code>$2</code></td>
<td><code>$1</code></td>
<td>immediate</td>
<td><code>$1</code>(unsigned)=<code>$2</code>+(sign-extend)immediate</td>
</tr>
<tr>
<td>SLTI</td>
<td>001010</td>
<td><code>$2</code></td>
<td><code>$1</code></td>
<td>immediate</td>
<td>if(<code>$2</code>&lt;(sign-extend)immediate) <code>$1</code>=1 else <code>$1</code>=0</td>
</tr>
<tr>
<td>SLTIU</td>
<td>001011</td>
<td><code>$2</code></td>
<td><code>$1</code></td>
<td>immediate</td>
<td>if(<code>$2</code>&lt;(sign-extend)immediate) <code>$1</code>=1 else <code>$1</code>=0</td>
</tr>
<tr>
<td>ANDI</td>
<td>001100</td>
<td><code>$2</code></td>
<td><code>$1</code></td>
<td>immediate</td>
<td><code>$1</code>=<code>$2</code> and (zero-extend)immediate</td>
</tr>
<tr>
<td>ORI</td>
<td>001101</td>
<td><code>$2</code></td>
<td><code>$1</code></td>
<td>immediate</td>
<td><code>$1</code>=<code>$2</code> or (zero-extend)immediate</td>
</tr>
<tr>
<td>XORI</td>
<td>001110</td>
<td><code>$2</code></td>
<td><code>$1</code></td>
<td>immediate</td>
<td><code>$1</code>=<code>$2</code> xor (zero-extend)immediate</td>
</tr>
<tr>
<td>LUI</td>
<td>001111</td>
<td>-</td>
<td><code>$1</code></td>
<td>immediate</td>
<td><code>$1</code>=immediate*65536</td>
</tr>
<tr>
<td>LW</td>
<td>100011</td>
<td><code>$2</code></td>
<td><code>$1</code></td>
<td>immediate</td>
<td><code>$1</code>=memory[<code>$2</code>+10]</td>
</tr>
<tr>
<td>SW</td>
<td>101011</td>
<td><code>$2</code></td>
<td><code>$1</code></td>
<td>immediate</td>
<td>memory[<code>$2</code>+10]=<code>$1</code></td>
</tr>
</tbody>
</table>
<h3 id="2、-整体设计"><a href="#2、-整体设计" class="headerlink" title="2、    整体设计"></a>2、    整体设计</h3><h4 id="1-分为五个流水段IF、ID、EX、MEM、WB。"><a href="#1-分为五个流水段IF、ID、EX、MEM、WB。" class="headerlink" title="(1)    分为五个流水段IF、ID、EX、MEM、WB。"></a>(1)    分为五个流水段IF、ID、EX、MEM、WB。</h4><h4 id="2-clk上升沿为每段的开始，每段长度为一个clk。"><a href="#2-clk上升沿为每段的开始，每段长度为一个clk。" class="headerlink" title="(2)    clk上升沿为每段的开始，每段长度为一个clk。"></a>(2)    clk上升沿为每段的开始，每段长度为一个clk。</h4><h4 id="3-每段的相关模块可以和clk上升沿同步也可以与clk下降沿同步。"><a href="#3-每段的相关模块可以和clk上升沿同步也可以与clk下降沿同步。" class="headerlink" title="(3)    每段的相关模块可以和clk上升沿同步也可以与clk下降沿同步。"></a>(3)    每段的相关模块可以和clk上升沿同步也可以与clk下降沿同步。</h4><h4 id="4-甘特图如下"><a href="#4-甘特图如下" class="headerlink" title="(4)    甘特图如下"></a>(4)    甘特图如下</h4><p><img src="//l-x.me/2018/06/14/cod/lab7_Pipeline-CPU/pic4.png" alt=""></p>
<h4 id="5-详细数据通路图如下"><a href="#5-详细数据通路图如下" class="headerlink" title="(5)详细数据通路图如下"></a>(5)详细数据通路图如下</h4><p><img src="//l-x.me/2018/06/14/cod/lab7_Pipeline-CPU/pic5.jpg" alt=""></p>
<h3 id="3、-各模块设计，主要有以下几个模块"><a href="#3、-各模块设计，主要有以下几个模块" class="headerlink" title="3、    各模块设计，主要有以下几个模块"></a>3、    各模块设计，主要有以下几个模块</h3><h4 id="a-alu模块——算术逻辑单元"><a href="#a-alu模块——算术逻辑单元" class="headerlink" title="a)    alu模块——算术逻辑单元"></a>a)    alu模块——算术逻辑单元</h4><table>
<thead>
<tr>
<th>alu.v</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>输入/输出</td>
<td>宽度</td>
<td>信号名</td>
<td>说明</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>alu_a</td>
<td>无符号型的操作数a，如果有负数，是以补码存储</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>alu_b,</td>
<td>无符号型的操作数b，如果有负数，是以补码存储</td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>alu_op,</td>
<td>运算类型</td>
</tr>
<tr>
<td>output</td>
<td>[31:0]</td>
<td>alu_out</td>
<td>无符号型的运算结果，如果有负数，是以补码存储</td>
</tr>
</tbody>
</table>
<p>alu模块完成大部分R型指令的计算，case判断alu_op的值，使用使用verilog语言中的各运算符完成运算。</p>
<p> 这里应该注意的是add和addu的实现是一样的，这是因为当操作数都是补码表示时，符号可以直接参与运算，两条指令的区别在于，add视结果为有符号，因此如果要实现中断功能，就需要判断是否溢出。具体方法是alu_a与alu_b符号同号时，alu_out与它们异号，则表示溢出。</p>
<p> 另外，还需要注意slt的实现，比较大小时，不能使用alu_a-alu_b&gt;0，因为它们都是无符号数，相减结果认为无符号数，而无符号数&gt;0是恒成立的。</p>
<h4 id="b-regfile模块——寄存器文件"><a href="#b-regfile模块——寄存器文件" class="headerlink" title="b) regfile模块——寄存器文件"></a>b) regfile模块——寄存器文件</h4><table>
<thead>
<tr>
<th>regfile.v</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>输入/输出</td>
<td>宽度</td>
<td>信号名</td>
<td>说明</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>clk</td>
<td>时钟沿</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>rst_n</td>
<td>复位信号，低电平有效</td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>rAddr1</td>
<td>读地址1</td>
</tr>
<tr>
<td>output</td>
<td>[31:0]</td>
<td>rDout1</td>
<td>读数据1</td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>rAddr2</td>
<td>读地址2</td>
</tr>
<tr>
<td>output</td>
<td>[31:0]</td>
<td>rDout2</td>
<td>读数据2</td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>wAddr</td>
<td>写地址</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>wDin</td>
<td>写数据</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>wEna</td>
<td>写使能，高电平有效</td>
</tr>
</tbody>
</table>
<p>这个模块实现了一个32个32位宽的寄存器组，有两个读端口，一个写端口，读取数据为异步读，写入数据在时钟上升沿且写使能有效，使用非阻塞赋值。</p>
<h4 id="c-mux模块和mux4模块——2路和4路选择器"><a href="#c-mux模块和mux4模块——2路和4路选择器" class="headerlink" title="c) mux模块和mux4模块——2路和4路选择器"></a>c) mux模块和mux4模块——2路和4路选择器</h4><table>
<thead>
<tr>
<th>mux.v</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>输入/输出</td>
<td>宽度</td>
<td>信号名</td>
<td>说明</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>sel</td>
<td>选择信号</td>
</tr>
<tr>
<td>input</td>
<td>[WIDTH-1:0]</td>
<td>d0</td>
<td>选择数据1</td>
</tr>
<tr>
<td>input</td>
<td>[WIDTH-1:0]</td>
<td>d1</td>
<td>选择数据2</td>
</tr>
<tr>
<td>output</td>
<td>[WIDTH-1:0]</td>
<td>out</td>
<td>输出</td>
</tr>
</tbody>
</table>
<h4 id="d-IP核生成的DMem模块和IMem模块——存放数据段和代码段"><a href="#d-IP核生成的DMem模块和IMem模块——存放数据段和代码段" class="headerlink" title="d) IP核生成的DMem模块和IMem模块——存放数据段和代码段"></a>d) IP核生成的DMem模块和IMem模块——存放数据段和代码段</h4><p>Mem是同步读，同步写，且由指定coe文件初始化，coe文件的内容是16进制文本，由Mars编译汇编代码生成。</p>
<h4 id="e-IFID模块——IF段和ID段之间的寄存器"><a href="#e-IFID模块——IF段和ID段之间的寄存器" class="headerlink" title="e) IFID模块——IF段和ID段之间的寄存器"></a>e) IFID模块——IF段和ID段之间的寄存器</h4><table>
<thead>
<tr>
<th>IFID.v</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>输入/输出</td>
<td>宽度</td>
<td>信号名</td>
<td>说明</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>clk</td>
<td>时钟沿</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>en</td>
<td>使能信号，高电平有效</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>flush</td>
<td>清空信号，高电平有效</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>PCPlus_in</td>
<td>IF段的PC+4</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>IMemout_in</td>
<td>IF段的Imem输出</td>
</tr>
<tr>
<td>output</td>
<td>[31:0]</td>
<td>PCPlus_out</td>
<td>ID段的PC+4</td>
</tr>
<tr>
<td>output</td>
<td>[31:0]</td>
<td>IMemout_out</td>
<td>ID段的Imem输出</td>
</tr>
</tbody>
</table>
<h4 id="f-IDEX模块——ID段和EX段之间的寄存器"><a href="#f-IDEX模块——ID段和EX段之间的寄存器" class="headerlink" title="f) IDEX模块——ID段和EX段之间的寄存器"></a>f) IDEX模块——ID段和EX段之间的寄存器</h4><table>
<thead>
<tr>
<th>IDEX.v</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>输入/输出</td>
<td>宽度</td>
<td>信号名</td>
<td>说明</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>clk</td>
<td>时钟沿</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>en</td>
<td>使能信号高电平有效</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>flush</td>
<td>清空信号高电平有效</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>PCPlus_in</td>
<td>ID段的PCPlus</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>RegRdout1_in</td>
<td>ID段的RegRdout1</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>RegRdout2_in</td>
<td>ID段的RegRdout2</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>IMMSignExtended_in</td>
<td>ID段的IMMSignExtended</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>IMMZeroExtended_in</td>
<td>ID段的IMMZeroExtended</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>ShamtZeroExtended_in</td>
<td>ID段的ShamtZeroExtended</td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>Rs_in</td>
<td>ID段的Rs</td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>Rt_in</td>
<td>ID段的Rt</td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>RegWtaddr_in</td>
<td>ID段的RegWtaddr</td>
</tr>
<tr>
<td>output</td>
<td>[31:0]</td>
<td>PCPlus_out</td>
<td>EX段的PCPlus</td>
</tr>
<tr>
<td>output</td>
<td>[31:0]</td>
<td>RegRdout1_out</td>
<td>EX段的RegRdout1</td>
</tr>
<tr>
<td>output</td>
<td>[31:0]</td>
<td>RegRdout2_out</td>
<td>EX段的RegRdout2</td>
</tr>
<tr>
<td>output</td>
<td>[31:0]</td>
<td>IMMSignExtended_out</td>
<td>EX段的IMMSignExtended</td>
</tr>
<tr>
<td>output</td>
<td>[31:0]</td>
<td>IMMZeroExtended_out</td>
<td>EX段的IMMZeroExtended</td>
</tr>
<tr>
<td>output</td>
<td>[31:0]</td>
<td>ShamtZeroExtended_out</td>
<td>EX段的ShamtZeroExtended</td>
</tr>
<tr>
<td>output</td>
<td>[4:0]</td>
<td>Rs_out</td>
<td>EX段的Rs</td>
</tr>
<tr>
<td>output</td>
<td>[4:0]</td>
<td>Rt_out</td>
<td>EX段的Rt</td>
</tr>
<tr>
<td>output</td>
<td>[4:0]</td>
<td>RegWtaddr_out</td>
<td>EX段的RegWtaddr</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>RegDst_in</td>
<td>ID段的RegDst</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>ALUSrcASel_in</td>
<td>ID段的ALUSrcASel</td>
</tr>
<tr>
<td>input</td>
<td>[1:0]</td>
<td>ALUSrcBSel_in</td>
<td>ID段的ALUSrcBSel</td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>ALUControl_in</td>
<td>ID段的ALUControl</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>DMemRead_in</td>
<td>ID段的DMemRead</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>DMemWrite_in</td>
<td>ID段的DMemWrite</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>DMemtoReg_in</td>
<td>ID段的DMemtoReg</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>RegWrite_in</td>
<td>ID段的RegWrite</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>RegDst_out</td>
<td>EX段的RegDst</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>ALUSrcASel_out</td>
<td>EX段的ALUSrcASel</td>
</tr>
<tr>
<td>output</td>
<td>[1:0]</td>
<td>ALUSrcBSel_out</td>
<td>EX段的ALUSrcBSel</td>
</tr>
<tr>
<td>output</td>
<td>[4:0]</td>
<td>ALUControl_out</td>
<td>EX段的ALUControl</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>DMemRead_out</td>
<td>EX段的DMemRead</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>DMemWrite_out</td>
<td>EX段的DMemWrite</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>DMemtoReg_out</td>
<td>EX段的DMemtoReg</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>RegWrite_out</td>
<td>EX段的RegWrite</td>
</tr>
</tbody>
</table>
<h4 id="g-EXMEM模块——EX段和MEM段之间的寄存器"><a href="#g-EXMEM模块——EX段和MEM段之间的寄存器" class="headerlink" title="g) EXMEM模块——EX段和MEM段之间的寄存器"></a>g) EXMEM模块——EX段和MEM段之间的寄存器</h4><table>
<thead>
<tr>
<th>EXMEM.v</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>输入/输出</td>
<td>宽度</td>
<td>信号名</td>
<td>说明</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>clk</td>
<td>时钟沿</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>en</td>
<td>使能信号高电平有效</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>flush</td>
<td>清空信号高电平有效</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>ALUResult_in</td>
<td>EX段的ALUResult</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>DMemin_in</td>
<td>EX的Dmemin</td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>RegWtaddr_in</td>
<td>EX的RegWtaddr</td>
</tr>
<tr>
<td>output</td>
<td>[31:0]</td>
<td>ALUResult_out</td>
<td>MEM段的ALUResult</td>
</tr>
<tr>
<td>output</td>
<td>[31:0]</td>
<td>DMemin_out</td>
<td>MEM的Dmemin</td>
</tr>
<tr>
<td>output</td>
<td>[4:0]</td>
<td>RegWtaddr_out</td>
<td>MEM的RegWtaddr</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>DMemRead_in</td>
<td>EX段的DMemRead</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>DMemWrite_in</td>
<td>EX段的DMemWrite</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>DMemtoReg_in</td>
<td>EX段的DMemtoReg</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>RegWrite_in</td>
<td>EX段的RegWrite</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>DMemRead_out</td>
<td>MEM段的DMemRead</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>DMemWrite_out</td>
<td>MEM段的DMemWrite</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>DMemtoReg_out</td>
<td>MEM段的DMemtoReg</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>RegWrite_out</td>
<td>MEM段的RegWrite</td>
</tr>
</tbody>
</table>
<h4 id="h-MEMWB模块——MEM段和WB段之间的寄存器"><a href="#h-MEMWB模块——MEM段和WB段之间的寄存器" class="headerlink" title="h) MEMWB模块——MEM段和WB段之间的寄存器"></a>h) MEMWB模块——MEM段和WB段之间的寄存器</h4><table>
<thead>
<tr>
<th>MEMWB.v</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>输入/输出</td>
<td>宽度</td>
<td>信号名</td>
<td>说明</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>clk</td>
<td>时钟沿</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>en</td>
<td>使能信号高电平有效</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>flush</td>
<td>清空信号高电平有效</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>ALUResult_in</td>
<td>MEM段的ALUResult</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>DMemout_in</td>
<td>MEM段的Dmemout</td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>RegWtaddr_in</td>
<td>MEM段的RegWtaddr</td>
</tr>
<tr>
<td>output</td>
<td>[31:0]</td>
<td>ALUResult_out</td>
<td>WB段的ALUResult</td>
</tr>
<tr>
<td>output</td>
<td>[31:0]</td>
<td>DMemout_out</td>
<td>WB段的DMemout</td>
</tr>
<tr>
<td>output</td>
<td>[4:0]</td>
<td>RegWtaddr_out</td>
<td>WB段的RegWtaddr</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>DMemtoReg_in</td>
<td>MEM段的DMemtoReg</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>RegWrite_in</td>
<td>MEM段的RegWrite</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>DMemtoReg_out</td>
<td>WB段的DMemtoReg</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>RegWrite_out</td>
<td>WB段的RegWrite</td>
</tr>
</tbody>
</table>
<h4 id="i-dff模块——D触发器，用于各个段寄存器"><a href="#i-dff模块——D触发器，用于各个段寄存器" class="headerlink" title="i) dff模块——D触发器，用于各个段寄存器"></a>i) dff模块——D触发器，用于各个段寄存器</h4><table>
<thead>
<tr>
<th>dff.v</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>输入/输出</td>
<td>宽度</td>
<td>信号名</td>
<td>说明</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>clk</td>
<td>时钟沿</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>en</td>
<td>使能信号高电平有效</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>rst</td>
<td>复位信号高电平有效</td>
</tr>
<tr>
<td>input</td>
<td>[WIDTH-1:0]</td>
<td>datain</td>
<td>输入数据</td>
</tr>
<tr>
<td>output</td>
<td>[WIDTH-1:0]</td>
<td>dataout</td>
<td>输出数据</td>
</tr>
</tbody>
</table>
<p> 这是一个通用的D触发器，位数作为参数可根据需要变化，用一个always在时钟沿触发来实现非阻塞赋值。</p>
<h4 id="j-compare模块——用于分支信号的判断"><a href="#j-compare模块——用于分支信号的判断" class="headerlink" title="j) compare模块——用于分支信号的判断"></a>j) compare模块——用于分支信号的判断</h4><table>
<thead>
<tr>
<th>dff.v</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>输入/输出</td>
<td>宽度</td>
<td>信号名</td>
<td>说明</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>a,</td>
<td>有符号数a，需加前缀signed</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>b,</td>
<td>有符号数b，需加前缀signed</td>
</tr>
<tr>
<td>output</td>
<td>[1:0]</td>
<td>res</td>
<td>比较结果</td>
</tr>
</tbody>
</table>
<p>a等于b返回2’b01，a小于b返回2’b00，a大于b返回2’b10，比较均是基于有符号数。</p>
<h4 id="k-SignExtended模块——立即数符号扩展"><a href="#k-SignExtended模块——立即数符号扩展" class="headerlink" title="k) SignExtended模块——立即数符号扩展"></a>k) SignExtended模块——立即数符号扩展</h4><p>过于简单，直接在top中实现了。</p>
<h4 id="l-ZeroExtended模块——立即数无符号扩展"><a href="#l-ZeroExtended模块——立即数无符号扩展" class="headerlink" title="l) ZeroExtended模块——立即数无符号扩展"></a>l) ZeroExtended模块——立即数无符号扩展</h4><p>过于简单，直接在top中实现了。</p>
<h4 id="m-forward模块——旁路前推模块，实现转发"><a href="#m-forward模块——旁路前推模块，实现转发" class="headerlink" title="m) forward模块——旁路前推模块，实现转发"></a>m) forward模块——旁路前推模块，实现转发</h4><table>
<thead>
<tr>
<th>forward.v</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>输入/输出</td>
<td>宽度</td>
<td>信号名</td>
<td>说明</td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>Rs_EX</td>
<td>EX段的Rs</td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>Rt_EX</td>
<td>EX段的Rt</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>RegWrite_MEM</td>
<td>MEM段的RegWrite</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>RegWrite_WB</td>
<td>WB段的RegWrite</td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>RegWtaddr_MEM</td>
<td>MEM段的RegWtaddr</td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>RegWtaddr_WB</td>
<td>WB段的RegWtaddr</td>
</tr>
<tr>
<td>output</td>
<td>[1:0]</td>
<td>RegRdout1Sel_Forward_EX</td>
<td>EX段的RegRdout1Sel_Forward</td>
</tr>
<tr>
<td>output</td>
<td>[1:0]</td>
<td>RegRdout2Sel_Forward_EX</td>
<td>EX段的RegRdout2Sel_Forward</td>
</tr>
</tbody>
</table>
<p>这个模块实现从DMem输出到ALU输入以及ALU输出到ALU输入的转发。</p>
<p><img src="//l-x.me/2018/06/14/cod/lab7_Pipeline-CPU/pic6.png" alt=""></p>
<p><img src="//l-x.me/2018/06/14/cod/lab7_Pipeline-CPU/pic7.png" alt=""></p>
<h4 id="n-hazard模块——冒险检测模块，实现插入气泡"><a href="#n-hazard模块——冒险检测模块，实现插入气泡" class="headerlink" title="n) hazard模块——冒险检测模块，实现插入气泡"></a>n) hazard模块——冒险检测模块，实现插入气泡</h4><table>
<thead>
<tr>
<th>hazard.v</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>输入/输出</td>
<td>宽度</td>
<td>信号名</td>
<td>说明</td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>Rs_ID</td>
<td>ID段的Rs</td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>Rt_ID</td>
<td>ID段的Rt</td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>RegWtaddr_EX</td>
<td>EX段的RegWtaddr</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>DMemRead_EX</td>
<td>EX段的DMemRead</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>PCEn</td>
<td>允许PC更新，高电平有效</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>IF_ID_En</td>
<td>允许IFID更新，高电平有效</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>ID_EX_Flush</td>
<td>IDEX清空，高电平有效</td>
</tr>
</tbody>
</table>
<p> lw之后R-Type需要使用访存结果，这在时间上是倒流的，不可能，只能插入一个气泡，清空IDEX寄存器，不更新IFID寄存器，不更新PC。</p>
<p><img src="//l-x.me/2018/06/14/cod/lab7_Pipeline-CPU/pic8.png" alt=""></p>
<h4 id="o-control模块——产生控制信号"><a href="#o-control模块——产生控制信号" class="headerlink" title="o) control模块——产生控制信号"></a>o) control模块——产生控制信号</h4><table>
<thead>
<tr>
<th>control.v</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>输入/输出</td>
<td>宽度</td>
<td>信号名</td>
<td>说明</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>clk</td>
<td>时钟沿</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>rst</td>
<td>复位信号高电平有效</td>
</tr>
<tr>
<td>input</td>
<td>[5:0]</td>
<td>Op</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[4:0]</td>
<td>Rt</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[5:0]</td>
<td>Funct</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[1:0]</td>
<td>RsCMPRt</td>
<td>Rs和Rt寄存器比较结果</td>
</tr>
<tr>
<td>input</td>
<td>[1:0]</td>
<td>RsCMPZero</td>
<td>Rs寄存器和0比较结果</td>
</tr>
<tr>
<td>output</td>
<td>[1:0]</td>
<td>PCSrc</td>
<td>0:+4，1:Branch，2:J，3:JR</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>RegDst</td>
<td>0:RegWtaddr=rt，1:RegWtaddr=rd</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>ALUSrcASel</td>
<td>0:RegRdout1，1:ShamtZeroExtended</td>
</tr>
<tr>
<td>output</td>
<td>[1:0]</td>
<td>ALUSrcBSel</td>
<td>0:RegRdout2，1:IMMSignExtended，2:IMMZeroExtended</td>
</tr>
<tr>
<td>output</td>
<td>[4:0]</td>
<td>ALUControl</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>DMemRead</td>
<td>1:En</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>DMemWrite</td>
<td>1:En</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>DMemtoReg</td>
<td>0:Aluout，1:DMemout</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>RegWrite</td>
<td>1:En</td>
</tr>
</tbody>
</table>
<p>根据输入信号，判断指令类型，输出对应控制信号的取值。</p>
<h4 id="p-debounce模块——去抖动"><a href="#p-debounce模块——去抖动" class="headerlink" title="p) debounce模块——去抖动"></a>p) debounce模块——去抖动</h4><table>
<thead>
<tr>
<th>debounce.v</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>输入/输出</td>
<td>宽度</td>
<td>信号名</td>
<td>说明</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>clk</td>
<td>时钟沿</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>in</td>
<td>输入信号，可能有抖动</td>
</tr>
<tr>
<td>output</td>
<td>[0:0]</td>
<td>out</td>
<td>输出信号，输入稳定后才变化</td>
</tr>
</tbody>
</table>
<h4 id="q-seg模块——7段数码管"><a href="#q-seg模块——7段数码管" class="headerlink" title="q) seg模块——7段数码管"></a>q) seg模块——7段数码管</h4><table>
<thead>
<tr>
<th>seg.v</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>输入/输出</td>
<td>宽度</td>
<td>信号名</td>
<td>说明</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>clk</td>
<td>时钟沿</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>rst_n</td>
<td>复位信号，低电平有效</td>
</tr>
<tr>
<td>input</td>
<td>[31:0]</td>
<td>data32</td>
<td>要显示的数据</td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>sel</td>
<td>选择当前显示位，低电平有效</td>
</tr>
<tr>
<td>output</td>
<td>[6:0]</td>
<td>segments</td>
<td>选择显示的数码管，高电平有效</td>
</tr>
</tbody>
</table>
<h4 id="r-top模块——实例化以上模块，连接各个信号"><a href="#r-top模块——实例化以上模块，连接各个信号" class="headerlink" title="r) top模块——实例化以上模块，连接各个信号"></a>r) top模块——实例化以上模块，连接各个信号</h4><table>
<thead>
<tr>
<th>top.v</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>输入/输出</td>
<td>宽度</td>
<td>信号名</td>
<td>说明</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>clk</td>
<td>时钟沿</td>
</tr>
<tr>
<td>input</td>
<td>[7:0]</td>
<td>sw</td>
<td>开关选择</td>
</tr>
<tr>
<td>output</td>
<td>[6:0]</td>
<td>seg7</td>
<td>7段数码管选择</td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>an</td>
<td>7段数码管位选择</td>
</tr>
<tr>
<td>input</td>
<td>[0:0]</td>
<td>btns</td>
<td>按钮中间，按下复位</td>
</tr>
</tbody>
</table>
<h3 id="4、-信号命名规则"><a href="#4、-信号命名规则" class="headerlink" title="4、    信号命名规则"></a>4、    信号命名规则</h3><h4 id="（1）-信号名称由几个单词（或其简写）构成，每个单词首字母大写"><a href="#（1）-信号名称由几个单词（或其简写）构成，每个单词首字母大写" class="headerlink" title="（1）    信号名称由几个单词（或其简写）构成，每个单词首字母大写"></a>（1）    信号名称由几个单词（或其简写）构成，每个单词首字母大写</h4><h4 id="（2）-一般先写该信号对应的部件名，然后紧跟操作或接口名。"><a href="#（2）-一般先写该信号对应的部件名，然后紧跟操作或接口名。" class="headerlink" title="（2）    一般先写该信号对应的部件名，然后紧跟操作或接口名。"></a>（2）    一般先写该信号对应的部件名，然后紧跟操作或接口名。</h4><h4 id="（3）-如果该信号是另外一个信号的选择信号，则加上Sel后缀。"><a href="#（3）-如果该信号是另外一个信号的选择信号，则加上Sel后缀。" class="headerlink" title="（3）    如果该信号是另外一个信号的选择信号，则加上Sel后缀。"></a>（3）    如果该信号是另外一个信号的选择信号，则加上Sel后缀。</h4><h4 id="（4）-如果该信号涉及在不同段之间传递，则在对应段的信号后加上所在段的名称。"><a href="#（4）-如果该信号涉及在不同段之间传递，则在对应段的信号后加上所在段的名称。" class="headerlink" title="（4）    如果该信号涉及在不同段之间传递，则在对应段的信号后加上所在段的名称。"></a>（4）    如果该信号涉及在不同段之间传递，则在对应段的信号后加上所在段的名称。</h4><h4 id="（5）-以上面方法命名基本不会引起混淆。"><a href="#（5）-以上面方法命名基本不会引起混淆。" class="headerlink" title="（5）    以上面方法命名基本不会引起混淆。"></a>（5）    以上面方法命名基本不会引起混淆。</h4><ul>
<li>比如：RegRdout1_EX表示寄存器文件读端口1读出的数据传递到EX段的信号。</li>
</ul>
<h3 id="5、-DMem和IMem的初始化"><a href="#5、-DMem和IMem的初始化" class="headerlink" title="5、    DMem和IMem的初始化"></a>5、    DMem和IMem的初始化</h3><p>IP核选择Block Memory，设置为Single Port RAM，</p>
<p><img src="//l-x.me/2018/06/14/cod/lab7_Pipeline-CPU/pic9.png" alt=""> </p>
<p>宽度为32，深度为256</p>
<p><img src="//l-x.me/2018/06/14/cod/lab7_Pipeline-CPU/pic10.png" alt="">  </p>
<p>选中Load Init File设置，选择初始化coe文件的路径，</p>
<p><img src="//l-x.me/2018/06/14/cod/lab7_Pipeline-CPU/pic11.png" alt="">  </p>
<p>其中IMem_init_test.coe文件内容为</p>
<pre><code>    memory_initialization_radix = 16;
    memory_initialization_vector =
    20110008
    01d17020
    21ceffff
    11c00001
    02200008
    20100001
    200f2000
    20080010
    00084040
    00084082
    ade80000
    21ef0004
    8de9fffc
    01295004
    3c090001
    ade90000
    21ef0004
    adea0000
    21ef0004
    01505022
    adea0000
    21ef0004
    010a4025
    01004024
    01084027
    ade80000
    21ef0004
    01485826
    000b5843
    020b5807
    adeb0000
    21ef0004
    000b5842
    020b5806
    000b5dc0
    016b5821
    adeb0000
    21ef0004
    01685823
    adeb0000
    21ef0004
    256b0001
    adeb0000
    21ef0004
    356b0001
    316b0003
    390b0001
    adeb0000
    21ef0004
    020b602a
    adec0000
    21ef0004
    020b602b
    adec0000
    21ef0004
    296c0001
    adec0000
    21ef0004
    2d6c0001
    adec0000
    21ef0004
    018c680a
    aded0000
    21ef0004
    0210680b
    aded0000
    21ef0004
    200e0000
    08000062
    08000066
    21ce0001
    adee0000
    21ef0004
    1560fffb
    21ce0001
    adee0000
    21ef0004
    1000fff8
    21ce0001
    adee0000
    21ef0004
    1800fff8
    21ce0001
    adee0000
    21ef0004
    0560fff8
    21ce0001
    adee0000
    21ef0004
    0401fff8
    21ce0001
    adee0000
    21ef0004
    1e00fff8
    21ce0001
    adee0000
    21ef0004
    1560fff8
    21ce0001
    adee0000
    21ef0004
    116bfff8
    21ce0001
    adee0000
    08000068;
</code></pre><p>DMem的初始化类似该过程，其coe文件初始全为0。</p>
<h3 id="6、-测试的汇编代码"><a href="#6、-测试的汇编代码" class="headerlink" title="6、    测试的汇编代码"></a>6、    测试的汇编代码</h3><pre><code class="assembly">.text
    addi $17, $0, 8 #const $17=8
    add $14, $14, $17 #$14=8
    addi $14, $14, -1 #$14--
    beq $14, $0, begin
    jr $17 #jump to IMemAddr 8
begin:
    addi $16, $0, 1 #const 1
    addi $15, $0, 8192 #MemAddr
    addi $8, $0, 16 #$8=16
    sll $8, $8, 1 #$8=32
    srl $8, $8, 2 #$8=8
    sw $8, 0($15) #-------Save Value: 8------
    addi $15, $15, 4 #MemAddr++ 
    lw $9, -4($15) #$9=8(32&#39;b00000000_00000001_00000000_00001000)
    sllv $10, $9, $9 #$10=2048(32&#39;b00000000_00000000_00001000_00000000)
    lui $9, 1 #$9=32&#39;b00000000_00000001_00000000_00000000
    sw $9, 0($15) #-------Save Value: 32&#39;b00000000_00000001_00000000_00001000------
    addi $15, $15, 4 #MemAddr++ 
    sw $10, 0($15) #-------Save Value: 2048------
    addi $15, $15, 4 #MemAddr++
    sub $10, $10, $16 #$10=2047(32&#39;b00000000_00000000_00000111_11111111)
    sw $10, 0($15) #-------Save Value: 2047------
    addi $15, $15, 4 #MemAddr++
    or $8, $8, $10 #$8=2047(32&#39;b111_11111111)
    and $8, $8, $0 #$8=0
    nor $8, $8, $8 #$8=2^32-1
    sw $8, 0($15) #-------Save Value: 2^32-1------
    addi $15, $15, 4 #MemAddr++ 
    xor $11, $10, $8 #$11=32&#39;b11111111_11111111_11111000_00000000
    sra $11, $11, 1 #$11=32&#39;b11111111_11111111_11111100_00000000
    srav $11, $11, $16 #$11=32&#39;b11111111_11111111_11111110_00000000
    sw $11, 0($15) #-------Save Value: 32&#39;b11111111_11111111_11111110_00000000------
    addi $15, $15, 4 #MemAddr++ 
    srl $11, $11, 1 #$11=32&#39;b01111111_11111111_11111111_00000000
    srlv $11, $11, $16 #$11=32&#39;b00111111_11111111_11111111_10000000
    sll $11, $11, 23 #$11=32&#39;b01000000_00000000_00000000_00000000
    addu $11, $11, $11 #$11=32&#39;b10000000_00000000_00000000_00000000
    sw $11, 0($15) #-------Save Value: 32&#39;b10000000_00000000_00000000_00000000------
    addi $15, $15, 4 #MemAddr++     
    subu $11, $11, $8 #$11=32&#39;b10000000_00000000_00000000_00000001
    sw $11, 0($15) #-------Save Value: 32&#39;b10000000_00000000_00000000_00000001------
    addi $15, $15, 4 #MemAddr++ 
    addiu $11, $11, 1 #$11=32&#39;b10000000_00000000_00000000_00000010
    sw $11, 0($15) #-------Save Value: 32&#39;b10000000_00000000_00000000_00000010------
    addi $15, $15, 4 #MemAddr++ 
    ori $11, $11, 1 #$11=32&#39;b10000000_00000000_00000000_00000011
    andi $11, $11, 3 #$11=32&#39;b00000000_00000000_00000000_00000011
    xori $11, $8, 1 #$11=32&#39;b11111111_11111111_11111111_11111110
    sw $11, 0($15) #-------Save Value: 32&#39;b11111111_11111111_11111111_11111100------
    addi $15, $15, 4 #MemAddr++ 
    slt $12, $16, $11 #$12=0
    sw $12, 0($15) #-------Save Value: 0------
    addi $15, $15, 4 #MemAddr++ 
    sltu $12, $16, $11 #$12=1
    sw $12, 0($15) #-------Save Value: 1------
    addi $15, $15, 4 #MemAddr++ 
    slti $12, $11, 1 #$12=1
    sw $12, 0($15) #-------Save Value: 1------
    addi $15, $15, 4 #MemAddr++ 
    sltiu $12, $11, 1 #$12=0
    sw $12, 0($15) #-------Save Value: 0------
    addi $15, $15, 4 #MemAddr++     
    movz $13, $12, $12 #because $12=0, set $13=$12,
    sw $13, 0($15) #-------Save Value: 0------
    addi $15, $15, 4 #MemAddr++         
    movn $13, $16, $16 #because $16=1(!=0), set $13=$16,
    sw $13, 0($15) #-------Save Value: 1------
    addi $15, $15, 4 #MemAddr++
    addi $14, $0, 0 #count
    j a
i:  j end
h:  addi $14, $14, 1 #count++
    sw $14, 0($15) #-------Save Value: $14------
    addi $15, $15, 4 #MemAddr++     
    bne $11, $0, i #to i    
g:  addi $14, $14, 1 #count++
    sw $14, 0($15) #-------Save Value: $14------
    addi $15, $15, 4 #MemAddr++     
    beq $0, $0, h #to h 
f:  addi $14, $14, 1 #count++
    sw $14, 0($15) #-------Save Value: $14------
    addi $15, $15, 4 #MemAddr++     
    blez $0, g #to g
e:  addi $14, $14, 1 #count++
    sw $14, 0($15) #-------Save Value: $14------
    addi $15, $15, 4 #MemAddr++     
    bltz $11, f #to f
d:  addi $14, $14, 1 #count++
    sw $14, 0($15) #-------Save Value: $14------
    addi $15, $15, 4 #MemAddr++     
    bgez $0, e #to e
c:  addi $14, $14, 1 #count++
    sw $14, 0($15) #-------Save Value: $14------
    addi $15, $15, 4 #MemAddr++     
    bgtz $16, d #to d
b:  addi $14, $14, 1 #count++
    sw $14, 0($15) #-------Save Value: $14------
    addi $15, $15, 4 #MemAddr++     
    bne $11,$0, c #to c
a:  addi $14, $14, 1 #count++
    sw $14, 0($15) #-------Save Value: $14------
    addi $15, $15, 4 #MemAddr++     
    beq $11, $11, b #to b
end:addi $14, $14, 1 #count++
    sw $14, 0($15) #-------Save Value: $14------
out:j out
</code></pre>
<p>完整汇编代码如上，36条指令均测试到了，每条语句的执行结果在该语句后面给出了注释，每测试几条指令就将结果写入内存，方便查看，并且3种相关有包括在上面的代码中。<br>​     </p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="（1）仿真结果"><a href="#（1）仿真结果" class="headerlink" title="（1）仿真结果"></a>（1）仿真结果</h3><p>汇编代码在Mars编译运行得到Data段为</p>
<p><img src="//l-x.me/2018/06/14/cod/lab7_Pipeline-CPU/pic12.png" alt=""> </p>
<p>而ISE仿真结果显示DMem为</p>
<p><img src="//l-x.me/2018/06/14/cod/lab7_Pipeline-CPU/pic13.png" alt="">  </p>
<p>汇编代码在Mars编译运行得到结束时寄存器数据和仿真结果的regfile数据     </p>
<p><img src="//l-x.me/2018/06/14/cod/lab7_Pipeline-CPU/pic14.png" alt="">     </p>
<p><img src="//l-x.me/2018/06/14/cod/lab7_Pipeline-CPU/pic15.png" alt="">             </p>
<p>可见测试程序在编写的MIPS CPU上运行结果与Mars运行结果一致，并且符合上面注释的的预期结果。</p>
<h3 id="（2）下载结果"><a href="#（2）下载结果" class="headerlink" title="（2）下载结果"></a>（2）下载结果</h3><p>按下按钮中键复位，拨动开关选择地址，数码管显示对应地址内存。</p>
<p><img src="//l-x.me/2018/06/14/cod/lab7_Pipeline-CPU/pic16.png" alt="">     </p>
<p>由于数据为32位，4个数码管只能显示16位，为此还实现了动态显示，数字会向左移动循环显示。</p>
<p><img src="//l-x.me/2018/06/14/cod/lab7_Pipeline-CPU/pic17.png" alt=""> </p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h2><h3 id="一、-编写过程中遇到问题和一些发现"><a href="#一、-编写过程中遇到问题和一些发现" class="headerlink" title="一、    编写过程中遇到问题和一些发现"></a>一、    编写过程中遇到问题和一些发现</h3><h4 id="1、如果位拼接作为左值，单个变量也要花括号，如"><a href="#1、如果位拼接作为左值，单个变量也要花括号，如" class="headerlink" title="1、如果位拼接作为左值，单个变量也要花括号，如"></a>1、如果位拼接作为左值，单个变量也要花括号，如</h4><pre><code>{{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9&#39;b100100100;
</code></pre><h4 id="2、”-”会严格匹配每一位，比如module内5位数字比较（一个常量，一个input），但外部传入的是3位的，高位自动拓展好像是x，就导致“-”不成立，这是一个不好发现的问题。"><a href="#2、”-”会严格匹配每一位，比如module内5位数字比较（一个常量，一个input），但外部传入的是3位的，高位自动拓展好像是x，就导致“-”不成立，这是一个不好发现的问题。" class="headerlink" title="2、”==”会严格匹配每一位，比如module内5位数字比较（一个常量，一个input），但外部传入的是3位的，高位自动拓展好像是x，就导致“==”不成立，这是一个不好发现的问题。"></a>2、”==”会严格匹配每一位，比如module内5位数字比较（一个常量，一个input），但外部传入的是3位的，高位自动拓展好像是x，就导致“==”不成立，这是一个不好发现的问题。</h4><h4 id="3、仿真遇到高阻态，多半是这个信号不存在，经常是拼写错了，有时候ise检查不出来。"><a href="#3、仿真遇到高阻态，多半是这个信号不存在，经常是拼写错了，有时候ise检查不出来。" class="headerlink" title="3、仿真遇到高阻态，多半是这个信号不存在，经常是拼写错了，有时候ise检查不出来。"></a>3、仿真遇到高阻态，多半是这个信号不存在，经常是拼写错了，有时候ise检查不出来。</h4><h4 id="4、在top里的wire信号，如果通过control模块（或其他模块）进行控制，那么这个信号不能直接在top里赋初值，要到仿真模块里赋值，不然control里改变这个信号的值时，会变成不确定。"><a href="#4、在top里的wire信号，如果通过control模块（或其他模块）进行控制，那么这个信号不能直接在top里赋初值，要到仿真模块里赋值，不然control里改变这个信号的值时，会变成不确定。" class="headerlink" title="4、在top里的wire信号，如果通过control模块（或其他模块）进行控制，那么这个信号不能直接在top里赋初值，要到仿真模块里赋值，不然control里改变这个信号的值时，会变成不确定。"></a>4、在top里的wire信号，如果通过control模块（或其他模块）进行控制，那么这个信号不能直接在top里赋初值，要到仿真模块里赋值，不然control里改变这个信号的值时，会变成不确定。</h4><h4 id="5、在clk边缘用-lt-对某信号进行赋值时，如果同时刻需要对该信号进行判断（如状态机，根据状态以完成对应操作），则判断时信号的值是本次改变前的。（非阻塞赋值的特性体现）"><a href="#5、在clk边缘用-lt-对某信号进行赋值时，如果同时刻需要对该信号进行判断（如状态机，根据状态以完成对应操作），则判断时信号的值是本次改变前的。（非阻塞赋值的特性体现）" class="headerlink" title="5、在clk边缘用&lt;=对某信号进行赋值时，如果同时刻需要对该信号进行判断（如状态机，根据状态以完成对应操作），则判断时信号的值是本次改变前的。（非阻塞赋值的特性体现）"></a>5、在clk边缘用&lt;=对某信号进行赋值时，如果同时刻需要对该信号进行判断（如状态机，根据状态以完成对应操作），则判断时信号的值是本次改变前的。（非阻塞赋值的特性体现）</h4><h4 id="6、-srl是逻辑右移，高位直接补零，而sra是算术右移，高位补符号，在Verilog中，既可以自行实现，也可以这样实现"><a href="#6、-srl是逻辑右移，高位直接补零，而sra是算术右移，高位补符号，在Verilog中，既可以自行实现，也可以这样实现" class="headerlink" title="6、 srl是逻辑右移，高位直接补零，而sra是算术右移，高位补符号，在Verilog中，既可以自行实现，也可以这样实现"></a>6、 srl是逻辑右移，高位直接补零，而sra是算术右移，高位补符号，在Verilog中，既可以自行实现，也可以这样实现</h4><pre><code>`$signed(alu_a) &gt;&gt;&gt; alu_b`
</code></pre><h4 id="应该注意，-gt-gt-gt-是算术右移，但对于无符号数，高位仍然补0，所以需要用-signed-转为有符号数"><a href="#应该注意，-gt-gt-gt-是算术右移，但对于无符号数，高位仍然补0，所以需要用-signed-转为有符号数" class="headerlink" title="应该注意， &gt;&gt;&gt; 是算术右移，但对于无符号数，高位仍然补0，所以需要用$signed()转为有符号数"></a>应该注意， &gt;&gt;&gt; 是算术右移，但对于无符号数，高位仍然补0，所以需要用<code>$signed()</code>转为有符号数</h4><pre><code>`$signed(alu_a) &gt;&gt; alu_b `
</code></pre><h4 id="这样写也不行，-gt-gt-不具有算术右移的功能"><a href="#这样写也不行，-gt-gt-不具有算术右移的功能" class="headerlink" title="这样写也不行，&gt;&gt;不具有算术右移的功能"></a>这样写也不行，&gt;&gt;不具有算术右移的功能</h4><h4 id="7、reset的时候应该把各段寄存器的各信号置0，否则将导致forward，hazard模块输出的值不确定进而使相关的选择信号不确定（比如PCEn不确定，这样一开始就不能更新PC）。"><a href="#7、reset的时候应该把各段寄存器的各信号置0，否则将导致forward，hazard模块输出的值不确定进而使相关的选择信号不确定（比如PCEn不确定，这样一开始就不能更新PC）。" class="headerlink" title="7、reset的时候应该把各段寄存器的各信号置0，否则将导致forward，hazard模块输出的值不确定进而使相关的选择信号不确定（比如PCEn不确定，这样一开始就不能更新PC）。"></a>7、reset的时候应该把各段寄存器的各信号置0，否则将导致forward，hazard模块输出的值不确定进而使相关的选择信号不确定（比如PCEn不确定，这样一开始就不能更新PC）。</h4><h3 id="二、-模块源代码"><a href="#二、-模块源代码" class="headerlink" title="二、    模块源代码"></a>二、    模块源代码</h3><h4 id="top-v"><a href="#top-v" class="headerlink" title="top.v"></a>top.v</h4><pre><code class="verilog">module top(
    input clk,
    input [7:0] sw,
    output [6:0] seg7,
    output [3:0] an,
    input btnr,btnl,btns,btnd,btnu
    );
    //_后缀表示该信号所在的流水段
    wire ALUSrcASel_ID;
    wire ALUSrcASel_EX;
    wire [1:0] ALUSrcBSel_ID;//alu B在regout2和imm之间选择
    wire [1:0] ALUSrcBSel_EX;
    wire [31:0] ALUSrcA_EX;
    wire [31:0] ALUSrcB_EX;
    wire [4:0] ALUControl_ID;
    wire [4:0] ALUControl_EX;
    wire [31:0] ALUResult_EX;
    wire [31:0] ALUResult_MEM;
    wire [31:0] ALUResult_WB;
    wire [1:0] RsCMPZero;
    wire [1:0] RsCMPRt;
    wire [31:0] IMMSignExtended_ID;
    wire [31:0] IMMSignExtended_EX;
    wire [31:0] IMMZeroExtended_ID;
    wire [31:0] IMMZeroExtended_EX;
    wire [31:0] ShamtZeroExtended_ID;
    wire [31:0] ShamtZeroExtended_EX;
    wire [1:0] RegRdout1Sel_Forward_EX;//旁路单元产生的选择信号
    wire [1:0] RegRdout2Sel_Forward_EX;
    wire [31:0] RegRdout1_Forward_EX;//旁路数据
    wire [31:0] RegRdout2_Forward_EX;
    wire [4:0] RegRdaddr1_ID;
    wire [31:0] RegRdout1_ID;
    wire [31:0] RegRdout1_EX;
    wire [4:0] RegRdaddr2_ID;
    wire [31:0] RegRdout2_ID;
    wire [31:0] RegRdout2_EX;
    wire [4:0] RegWtaddr_ID;
    wire [4:0] RegWtaddr_EX;    
    wire [4:0] RegWtaddr_MEM;
    wire [4:0] RegWtaddr_WB;
    wire [31:0] RegWtin_WB;
    wire RegWrite_ID;
    wire RegWrite_EX;
    wire RegWrite_MEM;
    wire RegWrite_WB;
    wire RegDst_ID;
    wire [31:0] IMemaddr;
    wire [31:0] IMemout;
    wire [31:0] DMemaddr_MEM;
    wire [31:0] DMemin_MEM;
    wire DMemRead_MEM;
    wire [31:0] DMemout_MEM;
    wire [31:0] DMemout_WB;
    wire DMemWrite_MEM;
    wire DMemtoReg_EX;
    wire DMemtoReg_MEM;
    wire DMemtoReg_WB;
    wire [31:0] PC;
    wire [31:0] PCPlus_IF;
    wire [31:0] PCPlus_ID;
    wire [31:0] PCPlus_EX;
    wire [31:0] EPC;
    wire [31:0] nextPC;
    wire PCEn;
    wire [1:0] PCSrc_ID;//Control输出的，0:+4,1:Branch,2:J,3:JR
    wire IF_ID_En;
    wire IF_ID_Flush;
    wire ID_EX_Flush;
    wire [31:0] PCJump_ID;
    wire [31:0] PCJR_ID;
    wire [31:0] PCBranch_ID;
    wire [31:0] Instr;  
    wire [5:0] Funct;
    wire [4:0] Shamt;
    wire [15:0] IMM16;
    wire [4:0] Rd;
    wire [4:0] Rt;
    wire [4:0] Rs;
    wire [5:0] Op;
    wire [4:0] Rt_EX;//为了旁路判断
    wire [4:0] Rs_EX;//为了旁路判断
    wire [25:0] JumpIMM;
    wire [31:0] IMMSignExtendedShiftLeft2;
    wire btns_d;
    debounce debounce(clk,btns,btns_d);//中键去抖动
    reg rst;
    assign Led = rst;
    always @(posedge btns_d) rst=~rst;
    //--------------regfile_copy_DMem是DMem的一份复制--------------
    wire [4:0] addr_show;
    wire [31:0] out_show;
    assign addr_show = sw;//开关输输入要显示的地址
    seg seg1(clk,1&#39;b1,out_show,an,seg7);//显示数据
    regfile_copy_DMem regfile_copy_DMem(clk,~rst,addr_show,out_show,DMemaddr_MEM &gt;&gt; 2,DMemin_MEM,DMemWrite_MEM);
    //---------------方便显示内存-------------------------
    //=======================IF========================
    mux4 MUXPC(
        .sel(PCSrc_ID),
        .d0(PCPlus_IF),//+4直接用IF的
        .d1(PCBranch_ID),
        .d2(PCJump_ID),
        .d3(PCJR_ID),
        .out(nextPC)
    );
    dff DFFPC(
        .clk(~clk),//下降沿更新PC
        .en(PCEn),
        .rst(rst),
        .datain(nextPC),
        .dataout(PC)
    );  
    alu ALUPCPlus(PC,4,5&#39;d01,PCPlus_IF);
    assign IMemaddr = PC &gt;&gt; 2;//&gt;&gt;2是因为这里IMem是每个地址存储4字节，和实际上的（一地址一字节）不一样
    IMem IMem(clk,1&#39;b0,IMemaddr,32&#39;b0,IMemout);//上升沿读指令
    //======================IFID========================
    IFID IFID(
        .clk(~clk),
        .en(IF_ID_En),
        .flush(IF_ID_Flush || rst),
        .PCPlus_in(PCPlus_IF),
        .IMemout_in(IMemout),
        .PCPlus_out(PCPlus_ID),
        .IMemout_out(Instr)
    );
    //=======================ID==========================
    assign JumpIMM = Instr[25:0];
    assign Funct = Instr[5:0];
    assign Shamt = Instr[10:6];
    assign IMM16 = Instr[15:0];
    assign Rd = Instr[15:11];
    assign Rt = Instr[20:16];
    assign Rs = Instr[25:21];
    assign Op = Instr[31:26];
    //*******Control*******
    control control(
        //in
        .clk(clk),
        .rst(rst),
        .Op(Op),
        .Rt(Rt),
        .Funct(Funct),
        .RsCMPRt(RsCMPRt),
        .RsCMPZero(RsCMPZero),
        //out
        .PCSrc(PCSrc_ID), 
        //ID
        .RegDst(RegDst_ID),
        //EX
        .ALUSrcASel(ALUSrcASel_ID),
        .ALUSrcBSel(ALUSrcBSel_ID), 
        .ALUControl(ALUControl_ID),
        //MEM
        .DMemRead(DMemRead_ID),
        .DMemWrite(DMemWrite_ID),
        //WB
        .DMemtoReg(DMemtoReg_ID),
        .RegWrite(RegWrite_ID)
    );
    //*******Control*******
    assign RegRdaddr1_ID = Rs;
    assign RegRdaddr2_ID = Rt;
    mux #(5) MUXRegWtaddr(RegDst_ID,Rt,Rd,RegWtaddr_ID);
    assign ShamtZeroExtended_ID = {{27{1'b0}},Shamt};
    assign IMMSignExtended_ID = {{16{IMM16[15]}},IMM16};
    assign IMMZeroExtended_ID = {{16{1'b0}},IMM16};
    assign IMMSignExtendedShiftLeft2 = IMMSignExtended_ID &lt;&lt; 2;
    alu BranchALU(PCPlus_ID,IMMSignExtendedShiftLeft2,5&#39;d01,PCBranch_ID);
    assign PCJump_ID = {{PCPlus_ID[31:28]},{{2'b00,JumpIMM}<<2}}; assign="" pcjr_id="RegRdout1_ID;" if_id_flush="(PCSrc_ID" !="2&#39;b00);//有跳转则清空IF_ID寄存器" regfile="" regfile(clk,~rst,regrdaddr1_id,regrdout1_id,regrdaddr2_id,regrdout2_id,regwtaddr_wb,regwtin_wb,regwrite_wb);="" compare="" compare1(regrdout1_id,regrdout2_id,rscmprt);="" for="" beq,bne="" compare2(regrdout1_id,0,rscmpzero);="" movz,movn,blez,bgtz,bltz,bgez="" hazard="" hazard(rs,rt,regwtaddr_ex,dmemread_ex,pcen,if_id_en,id_ex_flush);="" =="====================IDEX=========================" idex="" idex(="" .clk(~clk),="" .en(1&#39;b1),="" .flush(id_ex_flush="" ||="" rst),="" data="" in="" .pcplus_in(pcplus_id),="" .regrdout1_in(regrdout1_id),="" .regrdout2_in(regrdout2_id),="" .immsignextended_in(immsignextended_id),="" .immzeroextended_in(immzeroextended_id),="" .shamtzeroextended_in(shamtzeroextended_id),="" .rs_in(rs),="" .rt_in(rt),="" .regwtaddr_in(regwtaddr_id),="" out="" .pcplus_out(pcplus_ex),="" .regrdout1_out(regrdout1_ex),="" .regrdout2_out(regrdout2_ex),="" .immsignextended_out(immsignextended_ex),="" .immzeroextended_out(immzeroextended_ex),="" .shamtzeroextended_out(shamtzeroextended_ex),="" .rs_out(rs_ex),="" .rt_out(rt_ex),="" .regwtaddr_out(regwtaddr_ex),="" control="" sign="" .regdst_in(regdst_id),="" .alusrcasel_in(alusrcasel_id),="" .alusrcbsel_in(alusrcbsel_id),="" .alucontrol_in(alucontrol_id),="" .dmemread_in(dmemread_id),="" .dmemwrite_in(dmemwrite_id),="" .dmemtoreg_in(dmemtoreg_id),="" .regwrite_in(regwrite_id),="" .regdst_out(regdst_ex),="" .alusrcasel_out(alusrcasel_ex),="" .alusrcbsel_out(alusrcbsel_ex),="" .alucontrol_out(alucontrol_ex),="" .dmemread_out(dmemread_ex),="" .dmemwrite_out(dmemwrite_ex),="" .dmemtoreg_out(dmemtoreg_ex),="" .regwrite_out(regwrite_ex)="" );="" forward="" forward(rs_ex,rt_ex,regwrite_mem,regwrite_wb,regwtaddr_mem,regwtaddr_wb,regrdout1sel_forward_ex,regrdout2sel_forward_ex);="" mux4="" muxregrdout1fw(regrdout1sel_forward_ex,regrdout1_ex,regwtin_wb,aluresult_mem,0,regrdout1_forward_ex);="" muxregrdout2fw(regrdout2sel_forward_ex,regrdout2_ex,regwtin_wb,aluresult_mem,0,regrdout2_forward_ex);="" mux="" muxalusrca(alusrcasel_ex,regrdout1_forward_ex,shamtzeroextended_ex,alusrca_ex);="" muxalusrcb(alusrcbsel_ex,regrdout2_forward_ex,immsignextended_ex,immzeroextended_ex,0,alusrcb_ex);="" alu="" alu(alusrca_ex,alusrcb_ex,alucontrol_ex,aluresult_ex);="" exmem="" exmem(="" .flush(rst),="" .aluresult_in(aluresult_ex),="" .dmemin_in(regrdout2_forward_ex),="" .regwtaddr_in(regwtaddr_ex),="" .aluresult_out(aluresult_mem),="" .dmemin_out(dmemin_mem),="" .regwtaddr_out(regwtaddr_mem),="" .dmemread_in(dmemread_ex),="" .dmemwrite_in(dmemwrite_ex),="" .dmemtoreg_in(dmemtoreg_ex),="" .regwrite_in(regwrite_ex),="" .dmemread_out(dmemread_mem),="" .dmemwrite_out(dmemwrite_mem),="" .dmemtoreg_out(dmemtoreg_mem),="" .regwrite_out(regwrite_mem)="" dmemaddr_mem="ALUResult_MEM;" dmem="" dmem(clk,dmemwrite_mem,dmemaddr_mem="" &gt;&gt;="" 2,dmemin_mem,dmemout_mem);="" memwb="" memwb(="" .aluresult_in(aluresult_mem),="" .dmemout_in(dmemout_mem),="" .regwtaddr_in(regwtaddr_mem),="" .aluresult_out(aluresult_wb),="" .dmemout_out(dmemout_wb),="" .regwtaddr_out(regwtaddr_wb),="" .dmemtoreg_in(dmemtoreg_mem),="" .regwrite_in(regwrite_mem),="" .dmemtoreg_out(dmemtoreg_wb),="" .regwrite_out(regwrite_wb)="" muxdmemtoreg(dmemtoreg_wb,aluresult_wb,dmemout_wb,regwtin_wb);="" endmodule="" <="" code=""></2}};></code></pre>
<h4 id="alu-v"><a href="#alu-v" class="headerlink" title="alu.v"></a>alu.v</h4><pre><code class="verilog">`define A_NOP 5&#39;d00 //nop
`define A_ADD 5&#39;d01 //signed_add
`define A_SUB 5&#39;d02 //signed_sub
`define A_AND 5&#39;d03 //and
`define A_OR  5&#39;d04 //or
`define A_XOR 5&#39;d05 //xor
`define A_NOR 5&#39;d06 //nor
`define A_ADDU 5&#39;d07 //unsigned_add
`define A_SUBU 5&#39;d08 //unsigned_sub
`define A_SLT 5&#39;d09 //slt
`define A_SLTU 5&#39;d10 //unsigned_slt
`define A_SLL 5&#39;d11 //sll
`define A_SRL 5&#39;d12 //srl
`define A_SRA 5&#39;d13 //sra
`define A_MOV 5&#39;d14 //movz,movn
`define A_LUI 5&#39;d15 //lui
module alu(
    input [31:0] alu_a,//无符号型的，如果有负数，是以补码存储
    input [31:0] alu_b,
    input [4:0] alu_op,
    output reg [31:0] alu_out

    );
    always@(*)
        case (alu_op)
            `A_NOP: alu_out = 0;
            `A_ADD: alu_out = alu_a + alu_b;
            `A_SUB: alu_out = alu_a - alu_b;
            `A_AND: alu_out = alu_a &amp; alu_b;
            `A_OR : alu_out = alu_a | alu_b;
            `A_XOR: alu_out = alu_a ^ alu_b;
            `A_NOR: alu_out = ~(alu_a | alu_b);
            `A_ADDU: alu_out = alu_a + alu_b;
            `A_SUBU: alu_out = alu_a - alu_b;
            `A_SLT: //a&lt;b(signed) return 1 else return 0;
                begin
                    if(alu_a[31] == alu_b[31]) alu_out = (alu_a &lt; alu_b) ? 32&#39;b1 : 32&#39;b0;
//对于不加signed的变量类型，运算和比较视为无符号，但依然可以存储有符号数，这里相当于自行根据首位判断
//首位相等，即同号情况，直接比较，如果同正，后面31位大的，原数就大，如果同负，后面31位（补码）大的，依然是原数大
                    else alu_out = (alu_a[31] &lt; alu_b[31]) ? 32&#39;b0 : 32&#39;b1;
//异号情况，直接比较符号
                end
            `A_SLTU: alu_out = (alu_a &lt; alu_b) ? 32&#39;b1 : 32&#39;b0;
            `A_SLL: alu_out = alu_b &lt;&lt; alu_a;
            `A_SRL: alu_out = alu_b &gt;&gt; alu_a;
            `A_SRA: alu_out = $signed(alu_b) &gt;&gt;&gt; alu_a;
//使用&gt;&gt;&gt;为算术右移，高位补符号，应该注意，如果是无符号数，&gt;&gt;&gt;仍是逻辑右移，故应该$signed
            `A_MOV: alu_out = alu_b;
//原样输出，相当于reg[rt],mov本不需要通过alu，但因为是RType格式，故统一
            `A_LUI: alu_out = alu_b &lt;&lt; 16;
            default: ;
        endcase
endmodule
</code></pre>
<h4 id="regfile-v"><a href="#regfile-v" class="headerlink" title="regfile.v"></a>regfile.v</h4><pre><code class="verilog">module regfile(
    input clk,
    input rst_n,
    input [4:0] rAddr1,//读地址1
    output [31:0] rDout1,//读数据1
    input [4:0] rAddr2,//读地址2
    output [31:0] rDout2,//读数据2
    input [4:0] wAddr,//写地址
    input [31:0] wDin,//写数据
    input wEna//写使能

);
    reg [31:0] data [0:31];
    integer i;
    assign rDout1=data[rAddr1];//读1
    assign rDout2=data[rAddr2];//读2
    always@(posedge clk or negedge rst_n)//写和复位
        if(~rst_n)
        begin
            for(i=0; i&lt;32; i=i+1) data[i]&lt;=0;
        end
        else
        begin
            if(wEna)
                data[wAddr]&lt;=wDin;
        end
endmodule
</code></pre>
<h4 id="dff-v"><a href="#dff-v" class="headerlink" title="dff.v"></a>dff.v</h4><pre><code class="verilog">module dff #(parameter WIDTH = 32) ( //Data Flip-Flop 
    input clk,
    input en,
    input rst,
    input [WIDTH-1:0] datain,
    output reg [WIDTH-1:0] dataout
    );
    always@(posedge clk)
    begin
        if(rst)
            dataout &lt;= 0;
        else if(en)
            dataout &lt;= datain;
    end
endmodule
</code></pre>
<h4 id="mux-v"><a href="#mux-v" class="headerlink" title="mux.v"></a>mux.v</h4><pre><code class="verilog">module mux #(parameter WIDTH = 32)( //2路选择器
    input sel,
    input [WIDTH-1:0] d0,
    input [WIDTH-1:0] d1,
    output [WIDTH-1:0] out
    );
    assign out = (sel == 1&#39;b1 ? d1 : d0);
endmodule
</code></pre>
<h4 id="mux4-v"><a href="#mux4-v" class="headerlink" title="mux4.v"></a>mux4.v</h4><pre><code class="verilog">module mux4 #(parameter WIDTH = 32)( //4路选择器
    input [1:0] sel,
    input [WIDTH-1:0] d0,
    input [WIDTH-1:0] d1,
     input [WIDTH-1:0] d2,
     input [WIDTH-1:0] d3,
    output reg [WIDTH-1:0] out
    );
    always@(*)
        case(sel)
            2&#39;b00: out=d0;
            2&#39;b01: out=d1;
            2&#39;b10: out=d2;
            2&#39;b11: out=d3;
            default:;
        endcase
endmodule
</code></pre>
<h4 id="IFID-v"><a href="#IFID-v" class="headerlink" title="IFID.v"></a>IFID.v</h4><pre><code class="verilog">module IFID(
    input clk,
    input en,
    input flush,
    input [31:0] PCPlus_in,
    input [31:0] IMemout_in,
    output [31:0] PCPlus_out,
    output [31:0] IMemout_out
    );
     dff dff1(clk,en,flush,PCPlus_in,PCPlus_out);
     dff dff2(clk,en,flush,IMemout_in,IMemout_out);
endmodule
</code></pre>
<h4 id="IDEX-v"><a href="#IDEX-v" class="headerlink" title="IDEX.v"></a>IDEX.v</h4><pre><code class="verilog">module IDEX(
    input clk,
    input en,
    input flush,//flush for stall or start
    input [31:0] PCPlus_in,
    input [31:0] RegRdout1_in,
    input [31:0] RegRdout2_in,
    input [31:0] IMMSignExtended_in,
    input [31:0] IMMZeroExtended_in,
    input [31:0] ShamtZeroExtended_in,
    input [4:0] Rs_in,
    input [4:0] Rt_in,
    input [4:0] RegWtaddr_in,
    output [31:0] PCPlus_out,
    output [31:0] RegRdout1_out,
    output [31:0] RegRdout2_out,
    output [31:0] IMMSignExtended_out,
    output [31:0] IMMZeroExtended_out,
    output [31:0] ShamtZeroExtended_out,
    output [4:0] Rs_out,
    output [4:0] Rt_out,
    output [4:0] RegWtaddr_out,
    //control
    input RegDst_in,
    input ALUSrcASel_in,
    input [1:0] ALUSrcBSel_in, 
    input [4:0] ALUControl_in,
    input DMemRead_in,
    input DMemWrite_in,
    input DMemtoReg_in,
    input RegWrite_in,
    output RegDst_out,
    output ALUSrcASel_out,
    output [1:0] ALUSrcBSel_out, 
    output [4:0] ALUControl_out,
    output DMemRead_out,
    output DMemWrite_out,
    output DMemtoReg_out,
    output RegWrite_out
    );
    dff dff1(clk,en,flush,PCPlus_in,PCPlus_out);
    dff dff2(clk,en,flush,RegRdout1_in,RegRdout1_out);
    dff dff3(clk,en,flush,RegRdout2_in,RegRdout2_out);
    dff dff4(clk,en,flush,IMMSignExtended_in,IMMSignExtended_out);
    dff dff5(clk,en,flush,IMMZeroExtended_in,IMMZeroExtended_out);
    dff dff6(clk,en,flush,ShamtZeroExtended_in,ShamtZeroExtended_out);
    dff #(5) dff7(clk,en,flush,Rs_in,Rs_out);
    dff #(5) dff8(clk,en,flush,Rt_in,Rt_out);
    dff #(5) dff9(clk,en,flush,RegWtaddr_in,RegWtaddr_out);

    dff #(1) dff10(clk,en,flush,RegDst_in,RegDst_out);
    dff #(1) dff11(clk,en,flush,ALUSrcASel_in,ALUSrcASel_out);
    dff #(2) dff12(clk,en,flush,ALUSrcBSel_in,ALUSrcBSel_out);  
    dff #(5) dff13(clk,en,flush,ALUControl_in,ALUControl_out);  
    dff #(1) dff14(clk,en,flush,DMemRead_in,DMemRead_out);
    dff #(1) dff15(clk,en,flush,DMemWrite_in,DMemWrite_out);
    dff #(1) dff16(clk,en,flush,DMemtoReg_in,DMemtoReg_out);
    dff #(1) dff17(clk,en,flush,RegWrite_in,RegWrite_out);  
endmodule
</code></pre>
<h4 id="EXMEM-v"><a href="#EXMEM-v" class="headerlink" title="EXMEM.v"></a>EXMEM.v</h4><pre><code class="verilog">module EXMEM(
    input clk,
     input en,
     input flush,
     input [31:0] ALUResult_in,
     input [31:0] DMemin_in,
     input [4:0] RegWtaddr_in,
     output [31:0] ALUResult_out,
     output [31:0] DMemin_out,
     output [4:0] RegWtaddr_out,
     //control
     input DMemRead_in,
     input DMemWrite_in,
     input DMemtoReg_in,
     input RegWrite_in,
     output DMemRead_out,
     output DMemWrite_out,
     output DMemtoReg_out,
     output RegWrite_out
    );
     dff dff1(clk,en,flush,ALUResult_in,ALUResult_out);
     dff dff2(clk,en,flush,DMemin_in,DMemin_out);
     dff #(5) dff3(clk,en,flush,RegWtaddr_in,RegWtaddr_out);

     dff #(1) dff14(clk,en,flush,DMemRead_in,DMemRead_out);
     dff #(1) dff15(clk,en,flush,DMemWrite_in,DMemWrite_out);
     dff #(1) dff16(clk,en,flush,DMemtoReg_in,DMemtoReg_out);
     dff #(1) dff17(clk,en,flush,RegWrite_in,RegWrite_out);

endmodule
</code></pre>
<h4 id="MEMWB-v"><a href="#MEMWB-v" class="headerlink" title="MEMWB.v"></a>MEMWB.v</h4><pre><code class="verilog">module MEMWB(
     input clk,
     input en,
     input flush,
     input [31:0] ALUResult_in,
     input [31:0] DMemout_in,
     input [4:0] RegWtaddr_in,
     output [31:0] ALUResult_out,
     output [31:0] DMemout_out,
     output [4:0] RegWtaddr_out,
     //control
     input DMemtoReg_in,
     input RegWrite_in,
     output DMemtoReg_out,
     output RegWrite_out
    );
     dff dff1(clk,en,flush,ALUResult_in,ALUResult_out);
     dff dff2(clk,en,flush,DMemout_in,DMemout_out);
     dff #(5) dff3(clk,en,flush,RegWtaddr_in,RegWtaddr_out);
     dff #(1) dff16(clk,en,flush,DMemtoReg_in,DMemtoReg_out);
     dff #(1) dff17(clk,en,flush,RegWrite_in,RegWrite_out);
endmodule
</code></pre>
<h4 id="compare-v"><a href="#compare-v" class="headerlink" title="compare.v"></a>compare.v</h4><pre><code class="verilog">`define LESS 2&#39;b00
`define EQUAL 2&#39;b01
`define GREATER 2&#39;b10
module compare(//为了判断分支
     input signed [31:0] a,
     input signed [31:0] b,
     output reg [1:0] res
    );
     always @(*)
        if(a == b) res = 2&#39;b01;
        else if(a &lt; b) res = 2&#39;b00;
        else if(a &gt; b) res = 2&#39;b10;
endmodule
</code></pre>
<h4 id="forward-v"><a href="#forward-v" class="headerlink" title="forward.v"></a>forward.v</h4><pre><code class="verilog">module forward(//前推
    input [4:0] Rs_EX,
    input [4:0] Rt_EX,
    input RegWrite_MEM,
    input RegWrite_WB,
    input [4:0] RegWtaddr_MEM,
    input [4:0] RegWtaddr_WB,
    output reg [1:0] RegRdout1Sel_Forward_EX,
    output reg [1:0] RegRdout2Sel_Forward_EX
    );
    always @(*) begin
        RegRdout1Sel_Forward_EX[0] = RegWrite_WB &amp;&amp; (RegWtaddr_WB != 0) &amp;&amp; (RegWtaddr_MEM != Rs_EX) &amp;&amp; (RegWtaddr_WB == Rs_EX);
        RegRdout1Sel_Forward_EX[1] = RegWrite_MEM &amp;&amp; (RegWtaddr_MEM != 0) &amp;&amp; (RegWtaddr_MEM == Rs_EX);
        RegRdout2Sel_Forward_EX[0] = RegWrite_WB &amp;&amp; (RegWtaddr_WB != 0) &amp;&amp; (RegWtaddr_MEM != Rt_EX) &amp;&amp; (RegWtaddr_WB == Rt_EX);
        RegRdout2Sel_Forward_EX[1] = RegWrite_MEM &amp;&amp; (RegWtaddr_MEM != 0) &amp;&amp; (RegWtaddr_MEM == Rt_EX);  
    end
endmodule
</code></pre>
<h4 id="hazard-v"><a href="#hazard-v" class="headerlink" title="hazard.v"></a>hazard.v</h4><pre><code class="verilog">module hazard(//上一条指令是LW指令且当前指令ID级读的是同一个寄存器,则插入bubble
     input [4:0] Rs_ID,
     input [4:0] Rt_ID, 
     input [4:0] RegWtaddr_EX,
     input DMemRead_EX,
     output PCEn,
     output IF_ID_En,
     output ID_EX_Flush
    );
    assign ID_EX_Flush = ((RegWtaddr_EX == Rs_ID) || (RegWtaddr_EX == Rt_ID)) &amp;&amp; DMemRead_EX;//条件成立则为1，清空
    assign IF_ID_En = ~ID_EX_Flush;//条件成立则为0，保持
    assign PCEn = ~ID_EX_Flush;//条件成立则为0，保持
endmodule
</code></pre>
<h4 id="control-v"><a href="#control-v" class="headerlink" title="control.v"></a>control.v</h4><pre><code class="verilog">module control(
    input clk,rst,
    input [5:0] Op, //instr[31:26]
    input [4:0] Rt, //instr[20:16]

    input [5:0] Funct,//instr[5:0]
    input [1:0] RsCMPRt,
    input [1:0] RsCMPZero,
    output reg [1:0] PCSrc, //0:+4,1:Branch,2:J,3:JR
    //ID
    output reg RegDst,//0:RegWtaddr=rt,1:RegWtaddr=rd
    //EX
    output reg ALUSrcASel,//0:RegRdout1,1:ShamtZeroExtended
    output reg [1:0] ALUSrcBSel, //0:RegRdout2,1:IMMSignExtended,2:IMMZeroExtended
    output reg [4:0] ALUControl,
    //MEM
    output reg DMemRead,//1:En
    output reg DMemWrite,//1:En
    //WB
    output reg DMemtoReg,//0:Aluout,1:DMemout
    output reg RegWrite//1:En
    );

    reg [1:0] tmpsrc;

    always @(*)
    begin
    if(rst) 
        begin
            {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_00},{`A_NOP},{4'b0001}};
        end
    else
        case(Op)
            6&#39;b000000: //R-Type
                case(Funct)
                    //SLL的rs rt rd shamt全0时是nop，本来nop没有对应的
                    6&#39;b000000: //SLL,注意Alu_a来自Shamt的无符号拓展,即ALUSrcASel=1，下面两个同理
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_1_00},{`A_SLL},{4'b0001}};
                    //6&#39;b000001: //MOVCI
                    6&#39;b000010: //SRL
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_1_00},{`A_SRL},{4'b0001}};
                    6&#39;b000011: //SRA
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_1_00},{`A_SRA},{4'b0001}};
                    6&#39;b000100: //SLLV，注意Alu_a来自reg[rs],即ALUSrcASel=0，下面两个同理
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_SLL},{4'b0001}};
                    //6&#39;b000101: //*
                    6&#39;b000110: //SRLV
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_SRL},{4'b0001}};
                    6&#39;b000111: //SRAV
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_SRA},{4'b0001}};
                    6&#39;b001000: //JR
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b11_z_z_zz},{`A_NOP},{4'b00z0}};
                    //6&#39;b001001: //JALR

                    6&#39;b001010: //MOVZ,如果 reg[rs]=0 则 reg[rd]=reg[rt],此时RsCMPZero=01,所以 RegWrite=RsCMPZero[0]
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_MOV},{3'b000},{RsCMPZero[0]}};
                    6&#39;b001011: //MOVN,如果 reg[rs]!=0 则 reg[rd]=reg[rt],此时RsCMPZero=00或10,所以 RegWrite=~RsCMPZero[0]
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_MOV},{3'b000},{~RsCMPZero[0]}};

                    6&#39;b100000: //ADD
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_ADD},{4'b0001}};
                    6&#39;b100001: //ADDU
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_ADDU},{4'b0001}};
                    6&#39;b100010: //SUB
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_SUB},{4'b0001}};
                    6&#39;b100011: //SUBU
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_SUB},{4'b0001}};
                    6&#39;b100100: //AND
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_AND},{4'b0001}};
                    6&#39;b100101: //OR
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_OR},{4'b0001}};
                    6&#39;b100110: //XOR
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_XOR},{4'b0001}};
                    6&#39;b100111: //NOR
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_NOR},{4'b0001}};

                    6&#39;b101010: //SLT
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_SLT},{4'b0001}};
                    6&#39;b101011: //SLTU
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_1_0_00},{`A_SLTU},{4'b0001}};
                endcase
            6&#39;b000001: 
                case(Rt)
                    6&#39;b00000: //BLTZ,Reg[rs]&lt;0则跳转
                    begin
                        if(RsCMPZero == `LESS) tmpsrc = 2&#39;b01; else tmpsrc = 2&#39;b00;
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{tmpsrc},{4'bz_z_zz},{`A_NOP},{4'b00z0}};
                    end
                    6&#39;b00001: //BGEZ,Reg[rs]&gt;=0则跳转
                    begin
                        if(RsCMPZero == `GREATER || RsCMPZero == `EQUAL) tmpsrc = 2&#39;b01; else tmpsrc = 2&#39;b00;
                        {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{tmpsrc},{4'bz_z_zz},{`A_NOP},{4'b00z0}};
                    end
                endcase
            6&#39;b000010: //J,无条件跳转
                {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b10_z_z_zz},{`A_NOP},{4'b00z0}};
            //6&#39;b000011: //JAL
            6&#39;b000100: //BEQ,Reg[rs]==Reg[rt]则跳转,RsCMPRt=01(==),则PCSrc=01，否则PCSrc=00(不跳转)
                {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{{1'b0},{RsCMPRt[0]}},{4&#39;bz_z_zz},{`A_NOP},{4&#39;b00z0}};
            6&#39;b000101: //BNE,Reg[rs]!=Reg[rt]则跳转,RsCMPRt=00(&lt;)或10(&gt;),则PCSrc=01，否则PCSrc=00(不跳转)
                {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{{1'b0},{~RsCMPRt[0]}},{4&#39;bz_z_zz},{`A_NOP},{4&#39;b00z0}};
            6&#39;b000110: //BLEZ,Reg[rs]&lt;=0则跳转
                begin
                if(RsCMPZero == `LESS || RsCMPZero == `EQUAL) tmpsrc = 2&#39;b01; else tmpsrc = 2&#39;b00;
                {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{tmpsrc},{4'bz_z_zz},{`A_NOP},{4'b00z0}};
                end
            6&#39;b000111: //BGTZ,Reg[rs]&gt;0则跳转
                begin
                if(RsCMPZero == `GREATER) tmpsrc = 2&#39;b01; else tmpsrc = 2&#39;b00;
                {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{tmpsrc},{4'bz_z_zz},{`A_NOP},{4'b00z0}};
                end
            6&#39;b001000: //ADDI,注意RegDst=0,AluBSrcSel=01(IMMSignExtended),下面三个同理
                {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_01},{`A_ADD},{4'b0001}};
            6&#39;b001001: //ADDIU
                {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_01},{`A_ADDU},{4'b0001}};
            6&#39;b001010: //SLTI
                {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_01},{`A_SLT},{4'b0001}};
            6&#39;b001011: //SLTIU
                {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_01},{`A_SLTU},{4'b0001}};
            6&#39;b001100: //ANDI,注意RegDst=0,AluBSrcSel=10(IMMZeroExtended),下面三个同理
                {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_10},{`A_AND},{4'b0001}};
            6&#39;b001101: //ORI
                {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_10},{`A_OR},{4'b0001}};
            6&#39;b001110: //XORI
                {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_10},{`A_XOR},{4'b0001}};
            6&#39;b001111: //LUI
                {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_10},{`A_LUI},{4'b0001}};

            6&#39;b100011: //LW,注意RegDst=0(写到Reg[rt]),AluBSrcSel=01(IMMSignExtended),DMemtoReg=1(来自DMem),
                {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_0_0_01},{`A_ADD},{4'b1011}};

            6&#39;b101011: //SW,注意RegDst=x(不写Reg),AluBSrcSel=01(IMMSignExtended)
                {{PCSrc},{RegDst},{ALUSrcASel},{ALUSrcBSel},{ALUControl},{DMemRead},{DMemWrite},{DMemtoReg},{RegWrite}}={{6'b00_z_0_01},{`A_ADD},{4'b01z0}};

            default: ;
        endcase     
    end
endmodule
</code></pre>
<h4 id="debounce-v"><a href="#debounce-v" class="headerlink" title="debounce.v"></a>debounce.v</h4><pre><code class="verilog">module debounce(//去抖动
     input clk,
    input in,
    output reg out=0

    );
    reg [31:0] cnt=0;
    always@(posedge clk)
        begin
            if(in!=out)
                begin
                    cnt=cnt+1;

                    if(cnt==100000)
                    begin
                        out=~out;
                        cnt=0;
                    end

                end
            else cnt=0;

        end
endmodule
</code></pre>
<h4 id="seg-v"><a href="#seg-v" class="headerlink" title="seg.v"></a>seg.v</h4><pre><code class="verilog">module seg(
    input clk,
    input rst_n,
    input [31:0] data32,
    output reg [3:0] sel,
    output reg [6:0] segments
    );
    integer clk_25=0;//4位数码管循环显示用
    integer clk_50000000=0;//2hz，移动显示用
    reg [1:0] cnt;
    reg [3:0] cnt2;
    reg [15:0] data16;//data32的16bit
    reg [3:0] data4;//data16的4bit
    reg [3:0] empty;//空白位
    always@(*)//组合逻辑，控制七段数码管
        begin
            if(!rst_n)
                segments = 7&#39;b000_0000;
            else
                case(data4)
                    0: segments =       ~7&#39;b011_1111;//0
                    1: segments =       ~7&#39;b000_0110;//1
                    2: segments =       ~7&#39;b101_1011;//2
                    3: segments =       ~7&#39;b100_1111;//3
                    4: segments =       ~7&#39;b110_0110;//4
                    5: segments =       ~7&#39;b110_1101;//5
                    6: segments =       ~7&#39;b111_1101;//6
                    7: segments =       ~7&#39;b000_0111;//7
                    8: segments =       ~7&#39;b111_1111;//8
                    9: segments =       ~7&#39;b110_1111;//9
                    10:segments =       ~7&#39;b111_0111;//A
                    11:segments =       ~7&#39;b111_1100;//b
                    12:segments =       ~7&#39;b011_1001;//C
                    13:segments =       ~7&#39;b101_1110;//d
                    14:segments =       ~7&#39;b111_1001;//E
                    15:segments =       ~7&#39;b111_0001;//F
                    default: segments = 7&#39;b000_0000; // required
                endcase
        end

    always@(posedge clk)//时序逻辑，产生位选择信号段选择信号
        begin
            //if(!rst_n)
                //cnt = 2&#39;b00;
            //else 
                if(clk_25==400000)
                    begin
                        clk_25=0;
                        cnt = cnt + 2&#39;b01;
                    end
                else
                    clk_25=clk_25+1;

                if(clk_50000000==50000000)//
                    begin
                        clk_50000000=0;
                        cnt2=cnt2+1;
                        if(cnt2==4&#39;b1010) cnt2=4&#39;b0000;
                    end
                else
                    clk_50000000=clk_50000000+1;
            end

    always@(*)//组合逻辑，选择当前显示段
        begin
            case(cnt2)
                4&#39;b0000:begin data16={8&#39;bzzzzzzzz,data32[31:24]}; empty=4&#39;b1100; end
                4&#39;b0001:begin data16={4&#39;bzzzz,data32[31:20]}; empty=4&#39;b1000; end
                4&#39;b0010:begin data16=data32[31:16]; empty=4&#39;b0000; end
                4&#39;b0011:begin data16=data32[27:12]; empty=4&#39;b0000; end
                4&#39;b0100:begin data16=data32[23:8]; empty=4&#39;b0000; end
                4&#39;b0101:begin data16=data32[19:4]; empty=4&#39;b0000; end
                4&#39;b0110:begin data16=data32[15:0]; empty=4&#39;b0000; end
                4&#39;b0111:begin data16={data32[11:0],4&#39;bzzzz}; empty=4&#39;b0001; end
                4&#39;b1000:begin data16={data32[7:0],8&#39;bzzzzzzzz}; empty=4&#39;b0011; end
                4&#39;b1001:begin data16={data32[3:0],8&#39;bzzzzzzzz,data32[31:28]}; empty=4&#39;b0110; end
                default:;
            endcase
        end

    always@(*)//组合逻辑，选择当前显示位
        begin
            case(cnt)
                2&#39;b00:sel=4&#39;b1110 | empty;
                2&#39;b01:sel=4&#39;b1101 | empty;
                2&#39;b10:sel=4&#39;b1011 | empty;
                2&#39;b11:sel=4&#39;b0111 | empty;
                default:sel=4&#39;b1110;
            endcase
        end

    always@(*)//组合逻辑，选择当前显示位的数据
        begin
            case(cnt)
                2&#39;b00:data4=data16[3:0];
                2&#39;b01:data4=data16[7:4];
                2&#39;b10:data4=data16[11:8];
                2&#39;b11:data4=data16[15:12];
                default:data4=16&#39;b0;
            endcase
        end 
endmodule
</code></pre>
<h4 id="test-v"><a href="#test-v" class="headerlink" title="test.v"></a>test.v</h4><pre><code class="verilog">module test;
    // Inputs
    reg clk;
    reg rst;
    // Instantiate the Unit Under Test (UUT)
    top uut (
        .clk(clk), 
        .rst(rst),
    );

    initial begin
        // Initialize Inputs
        clk = 1;

        rst = 0;
        #100;

        rst = 1;

        // Wait 100 ns for global reset to finish
        #100;
        clk=~clk;
        #10;
        clk=~clk;
      rst = 0;

        forever begin
            #10;
            clk=~clk;
        end

        // Add stimulus here
    end

endmodule
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/COD/">COD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Verilog/">Verilog</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-article/verilog_signed_and_unsigned" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/13/article/verilog_signed_and_unsigned/" class="article-date">
      <time datetime="2018-06-12T16:00:00.000Z" itemprop="datePublished">2018-06-13</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/13/article/verilog_signed_and_unsigned/">Verilog中的有符号数与无符号数</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Verilog中的有符号数与无符号数"><a href="#Verilog中的有符号数与无符号数" class="headerlink" title="Verilog中的有符号数与无符号数"></a>Verilog中的有符号数与无符号数</h1><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><ul>
<li><p>在用Verilog编写流水线CPU时，ALU需要实现add、addu、sub、subu、slt、sltu功能，分别是加、减、小于则置位的有符号和无符号版本，不过之前使用Verilog编写代码的时候从来没有考虑过符号问题，基本都是按无符号处理，除了在立即数符号拓展部分涉及到了符号</p>
<pre><code>  `assign SignExtented = {{16{IMM16[15]}},IMM16};`
</code></pre><p>  这里相当于是手动按符号拓展。</p>
</li>
<li>那么，现在要实现的addu和add的区别在哪呢？还有溢出如何判断？</li>
</ul>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><ul>
<li><p>马上回想了下原码和补码的问题，但是这只是在有符号情况下对正负数表示的统一，现在的问题是Verilog中“+”这个运算符是认为操作数是有符号还是无符号呢？（当然，正数的情况没有区别）。马上测试了一下：<br> ​    </p>
<pre><code class="verilog"> reg [3:0] a；
 reg [3:0] b；
 reg [3:0] out；
 initial begin
     a = -1;
     b = -2;
     out = a + b;
 end
</code></pre>
<p> 结果out=-3，我以为“+”是计算有符号的情况的。<br> 以二进制查看了一下波形，是<code>a=4&#39;b1111,b=4&#39;1110,out=4&#39;b1101</code><br> 看来如果赋值为负数，是以补码的形式存储的</p>
<p> 那么如果操作数是两个无符号数，且足够大，首位是1，不就也被“+”当成有符号负数了吗？这就不能实现无符号的加法了。</p>
</li>
</ul>
<h2 id="初步理解"><a href="#初步理解" class="headerlink" title="初步理解"></a>初步理解</h2><ul>
<li><p>查看一本编写cpu的参考书，里面是这样写的</p>
<p>  <img src="//l-x.me/2018/06/13/article/verilog_signed_and_unsigned/alupic1.png" alt=""><br>  <img src="//l-x.me/2018/06/13/article/verilog_signed_and_unsigned/alupic2.png" alt=""><br>  <img src="//l-x.me/2018/06/13/article/verilog_signed_and_unsigned/alupic3.png" alt=""><br>  <img src="//l-x.me/2018/06/13/article/verilog_signed_and_unsigned/alupic4.png" alt=""><br>  <img src="//l-x.me/2018/06/13/article/verilog_signed_and_unsigned/alupic5.png" alt=""></p>
</li>
<li><p>这有符号和无符号有什么区别！！！</p>
</li>
<li><p>发现wire后面带着signed，马上查了下，这是Verilog2001新增的关键字，目的是为了方便处理有符号数，如果不加signed，就是按无符号处理。</p>
<ul>
<li>signed类型的变量，在位数增加要拓展高位的时候，是按符号拓展，也就是说，前面的我们手动实现的符号拓展，这里自动实现了。</li>
</ul>
</li>
<li>那么为什么它的有符号计算和无符号计算都还是同样用无符号数int_0,int_1处理，而溢出的判断是专门增加一个signed型的变量s_out，用$signed()把out转成有符号存在s_out，然后判断？</li>
<li><p>花了一点时间遍访了博客后，发现了这张图</p>
<p>  <img src="//l-x.me/2018/06/13/article/verilog_signed_and_unsigned/ss.png" alt=""></p>
<p>  这不就是在模2^n意义下的加法吗？<br>  等等，我再去看一下a,b，a=4’b1111,b=4’1110,直接相加，舍弃最高进位（mod 2^4），这不就是out=4’b1101吗？可是刚刚明明是解释为负数啊。。<br>  思考了许久，啊，突然意识到，这个“+”确实是无符号的加，也就是电路中最基本的加法器的功能，这也是为什么负数要表示成补码的原因了（符号直接参与运算），看来之前没有真正理解补码的优越性。</p>
</li>
<li><p>这样一来，只要有符号时负数按补码存储，那么有符号和无符号的计算就是一样的</p>
</li>
<li>那么signed类型和unsigned类型的区别在哪呢？即使使用$signed()转换后，二进制代码并没有变，也就是，一串二进制代码，是有符号还是无符号，完全取决于你如何解释，不同解释就导致转换为十进制的时候得到不同的值，比较大小的时候也得到不同的结果。</li>
</ul>
<p>##进阶</p>
<ul>
<li>那么溢出是如何判断的？<ul>
<li>Mars的指令解释里add和addu的唯一区别在于addu不考虑溢出</li>
<li>我就想，无符号为什么就不会溢出了？最高位如果进位不就是溢出了吗？</li>
</ul>
</li>
<li>又是一番思索后，翻出了数电课本（啊，当时没认真学的后果），再参考博客后，得到判断溢出的方法<blockquote>
<p>补码加法运算溢出判断三种方法：</p>
<p>［方法一］<br>Xf、Yf分别两个数的符号位,Zf为运算结果符号位。<br>当Xf =Yf =0（两数同为正）,而Zf=1(结果为负)时,负溢出；<br>当出现Xf =Yf =1（两数同为负）,而Zf=0（结果为正），正溢出.</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>［方法二］<br>Cs表示符号位的进位，Cp表示最高数值位进位，⊕表示异或。<br>若 Cs⊕Cp =0 ，无溢出；<br>若 Cs⊕Cp =1 ，有溢出。</p>
</blockquote>
<blockquote>
<p>［方法三］<br>用变形补码进行双符号位运算（正数符为00,负数符号以11）<br>若运算结果的符号位为”01”,则正溢；<br>若结果双符号为10,则负溢出；<br>若结果的双符号位为00或11，无溢出。</p>
</blockquote>
<ul>
<li>从方法一，我才意识到之前理解的溢出是错误的，溢出并不是最高位有进位，而是有符号情况下同号相加时得到结果符合相反（也就是超过了可表示范围，当然，异号相加的时候不可能超过表示范围），而无符号的时候是没有溢出的，因为它满足模n加法。</li>
<li>搞清楚了溢出后，上面参考书的写法也就不难理解了，就是判断两个源操作数的符号和结果符号。<ul>
<li>不过有一点值得注意，s_out是signed型，那么”&lt;”和”&gt;”就是针对有符号的运算了（相当于C++中运算符的“重载”）。有符号的变量有可能“&lt;0”，而一个不加signed的变量”&gt;0”是恒成立的。所以，在比较两个无符号数大小时，应该写成if(a&gt;b)而不能写成if(a-b&gt;0)，a-b得到还是无符号数，这个判断恒成立。</li>
</ul>
</li>
</ul>
<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><ul>
<li>Verilog中有符号和无符号混合运算：两个有符号数运算、两个无符号数运算、有符号数运算和无符号数运算。 只有两个操作数都是有符号数，才会把两个操作数都看作有符号数计算，否则无论是有符号数还是无符号数都会按照无符号数计算。 </li>
</ul>
<h2 id="ALU中SLT的实现"><a href="#ALU中SLT的实现" class="headerlink" title="ALU中SLT的实现"></a>ALU中SLT的实现</h2><ul>
<li><p>明白了上面的知识，slt的实现也就非常简单了，可以两种写法：</p>
<ul>
<li><p>一是无符号变量存储，自行判断符号</p>
<pre><code class="verilog"> if(alu_a[31] == alu_b[31]) alu_out = (alu_a &lt; alu_b) ? 32&#39;b1 : 32&#39;b0;
     //对于不加signed的变量类型，运算和比较视为无符号，但依然可以存储有符号数，这里相当于自行根据首位判断
     //首位相等，即同号情况，直接比较，如果同正，后面31位大的，原数就大，如果同负，后面31位（补码）大的，依然是原数大
     else alu_out = (alu_a[31] &lt; alu_b[31]) ? 32&#39;b0 : 32&#39;b1;//异号情况，直接比较符号
</code></pre>
</li>
<li><p>二是转为有符号，直接用“&lt;”比较</p>
<p> <code>alu_out = ($signed(alu_a) &lt; $signed(alu_b)) ? 32&#39;b1 : 32&#39;b0;</code></p>
</li>
<li><p>测试一下，两种方法结果一样<br><img src="//l-x.me/2018/06/13/article/verilog_signed_and_unsigned/sltpic1.png" alt=""> </p>
</li>
</ul>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Verilog/">Verilog</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-os/File_System/File System" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/23/os/File_System/File System/" class="article-date">
      <time datetime="2018-05-22T16:00:00.000Z" itemprop="datePublished">2018-05-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/23/os/File_System/File System/">操作系统阅读报告：大容量存储器与文件系统</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="大容量存储器与文件系统"><a href="#大容量存储器与文件系统" class="headerlink" title="大容量存储器与文件系统"></a>大容量存储器与文件系统</h1><h2 id="大容量存储器简介"><a href="#大容量存储器简介" class="headerlink" title="大容量存储器简介"></a>大容量存储器简介</h2><ul>
<li>我们知道，程序执行时主要将信息存储在内存中，但由于内存太小，且具有易失性，并不适合长久保存数据。因此，计算机需要一些大容量外部存储器来备份信息，比如磁盘、磁带、光盘和固态硬盘等等，其中磁盘和固态硬盘是目前主要的外部存储器。速度、可靠性和价格是衡量大容量存储器性能的三个重要指标。</li>
</ul>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p><strong>（1）磁盘的结构</strong></p>
<ul>
<li><p><strong>磁盘（Magnetic Disk）</strong>由许多扁圆盘片堆叠而成，每个盘片两面涂有磁性材料，旁边是机械臂杆及其磁臂，磁臂上的磁头在盘片上移动并进行磁记录来实现信息的读取和写入。磁盘片的表面被逻辑地划分为多个<strong>磁道（Track）</strong>，磁道再被划分为<strong>扇区（Secto）</strong>，位于同一磁臂位置的磁道集合组成<strong>柱面（Cylinder）</strong>。</p>
<p>  <img src="//l-x.me/2018/05/23/os/File_System/File System/20180526055814104-1.jpg" alt="">图1</p>
</li>
<li><p>磁盘使用时会被驱动器高速旋转，磁头飞行于盘片的空气层上，定位到数据所在位置所需的时间由两部分组成：<strong>寻道时间</strong>（移动磁臂到所在的柱面）和<strong>旋转等待时间</strong>（等待某扇区旋转至磁头下）。定位时间越小，数据传输速率越高。磁盘旋转的角速度可以是匀速的或者变速的，由于扇区按角度划分，则前者的传输速率是内侧磁道高而外侧低，后者的传输速率是不变的，现在的磁盘主要采用前一方案。</p>
</li>
</ul>
<p><strong>（2）磁盘的管理</strong></p>
<ul>
<li>良好的管理可以更高效地使用磁盘。磁盘在低级格式化后被划分为许多扇区（带有特殊数据结构的逻辑块），一般并不直接使用（当成巨大的顺序数组），而是进一步分为一个或多个柱面组成的分区，然后进行逻辑格式化，创建某种<strong>文件系统（File System）</strong>对磁盘进行管理。其中一个重要的方面是对坏块的管理，当某些逻辑块损坏时，一种方法是跳过坏块，顺序后移后续块，另一种方法是每条磁道预留一些块作为备用。</li>
</ul>
<p><strong>（3）磁盘的调度</strong></p>
<ul>
<li>由于磁盘具有特殊结构，在转速一定时，需要对磁盘的访问队列进行<strong>调度</strong>才能避免过长的寻道时间。<ul>
<li><strong>FCFS</strong>（先来先服务）调度是一种公平的调度算法，但一般性能不高。</li>
<li><strong>SSTF</strong>（最短寻道时间优先）调度优先处理靠近当前磁头位置的请求，性能有了很大提高，但可能导致一些请求长时间得不到满足。</li>
<li><strong>SCAN</strong>（扫描）调度将磁臂从一端移到另一端，顺序处理所到之处的请求，到达一端后反向扫描，如此循环，这种算法的问题在于，当一个请求在磁头从请求位置移动走后才被加入队列，则必须等待磁头到达一端并反向移动回来后才能处理。</li>
<li><strong>C-SCAN</strong>调度是前者的一种改进，磁头到达一端后并不反向扫描，而是直接返回起始端重新开始扫描，这就解决了前一个问题，但实际上，如果在到达一端之前剩余的位置都没有请求，则磁头可以立刻返回，这就是<strong>C-LOOK</strong>调度，磁头只移动到一个方向上最远的请求。</li>
</ul>
</li>
</ul>
<p><img src="//l-x.me/2018/05/23/os/File_System/File System/20180526055814104-3.jpg" alt=""><br>FCFS<br><img src="//l-x.me/2018/05/23/os/File_System/File System/20180526055814104-4.jpg" alt=""><br>SSTF<br><img src="//l-x.me/2018/05/23/os/File_System/File System/20180526055814104-5.jpg" alt=""><br>SCAN<br><img src="//l-x.me/2018/05/23/os/File_System/File System/20180526055814104-6.jpg" alt=""><br>C-SCAN<br><img src="//l-x.me/2018/05/23/os/File_System/File System/20180526055814104-7.jpg" alt=""><br>C-LOOK</p>
<p>图2</p>
<h2 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h2><ul>
<li><strong>固态硬盘（SSD，Solid-State Drives）</strong>主要由控制器和 <strong>闪存（Flash）</strong> 芯片组成，它具有速度快、质量轻、能耗小等优点，近来被广泛使用，但容量小，价格昂贵。闪存芯片被划分为不同的层次（Package&gt;Die/Chip&gt;Plane&gt;Block&gt;Page），最基本的存储单元是晶体管，每个单元可以存储一个bit（<strong>SLC</strong>），也可以存储多个bit（<strong>MLC</strong>）。固态硬盘的读写以Page（4KB）为单位，当一个Page的信息需要被删除时，它只是被标记为无效，而且不支持对一个Page进行修改，只有在适当的时候以Block为单位进行擦除，而一个Block可以擦除的次数是 <strong>有限</strong> 的，因此固态硬盘需要地址映射机制和垃圾回收机制，以此延长使用寿命。</li>
</ul>
<h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><ul>
<li><p>单个磁盘读写性能并不高，而且一旦损坏，将导致数据丢失。随着单位存储价格的降低，人们通过增加大量磁盘形成<strong>磁盘冗余阵列（RAID）</strong>，以此提高<strong>性能</strong>和<strong>可靠性</strong>。一方面，通过<strong>冗余</strong>提高可靠性，最简单也最昂贵的方法是<strong>镜像</strong>，即复制每个磁盘。另一方面，通过<strong>分散和并行</strong>改善性能，最简单的方式是<strong>位级分散</strong>，即一个字节的8个位分散到8个磁盘上，则并行读取时可以提高为8倍传输速率，也可以用<strong>块级分散</strong>的方式，一个文件的块分散在多个磁盘上。</p>
</li>
<li><p>RAID具有不同的<strong>级别</strong>，体现对价格和效果的不同<strong>权衡</strong>，以下以4个盘为例介绍各级别。</p>
<ul>
<li><p>RAID0：使用块级分散，但没有任何冗余，因此没有提高可靠性。</p>
</li>
<li><p>RAID1：即磁盘镜像，大大提高了可靠性，但花费巨大。</p>
</li>
<li><p>RAID01：即RAID0+1，先将数据分散到两块磁盘，再整体做镜像，这种方案同时提高了性能和可靠性，然而只要任意一块磁盘损坏，都只剩下一份镜像可用。</p>
</li>
<li><p>RAID10：即RAID1+0，先做镜像，再整体将数据分散到两块磁盘，这种方案比RAID01更优，当一个磁盘损坏时，RAID10的两份分散皆可用，而RAID01只有一份可用。这两种方案都存在开销过大的问题。</p>
</li>
<li><p>RAID2：以<strong>汉明码（Hamming Code）</strong>的方式将数据进行编码后按位级分散到各个磁盘上，汉明码方式是在原有数据中插入若干校验码，并且支持一位数据的纠错，如果某个磁盘损坏，可以通过其他磁盘重新计算以恢复数据。4位数据的存储需要额外增加3位校验码，这比RAID1节省了一个磁盘，但读写时需要对数据即时地进行校验，因此效率较低。</p>
</li>
<li><p>RAID3：以<strong>奇偶校验（Parity Check）</strong>的方式在多位数据后增加一位校验位，表示前面数据位中1的个数是奇数或偶数。这种方案使用位级分散，只需要一个额外的校验磁盘，但是当读写较频繁时，校验盘将会负载过大，成为系统性能的瓶颈。</p>
</li>
<li><p>RAID4：和RAID3类似，但使用块级分散。</p>
</li>
<li><p>RAID5：是对RAID4的改进，将奇偶校验信息分散存储到各个磁盘上而不是单个校验磁盘，这就避免了校验盘负载过大的情况，是目前应用较广泛的方案。</p>
</li>
<li><p>RAID6：在RAID5基础上增加了一位校验码（不再是奇偶校验），这样就可以容忍两个磁盘出错。</p>
</li>
</ul>
</li>
</ul>
<h2 id="文件系统概述"><a href="#文件系统概述" class="headerlink" title="文件系统概述"></a>文件系统概述</h2><ul>
<li><p>如前文所述，磁盘只是纯粹的存储介质，一般磁盘格式化并不直接顺序存储数据，而是建立特定的<strong>文件系统（File System）</strong>来更好地管理磁盘。文件系统本身并不是磁盘也不是操作系统，而是存储在磁盘上，一个磁盘通常可以支持不同的文件系统。</p>
</li>
<li><p>文件系统通常具有<strong>文件</strong>和<strong>目录</strong>两种抽象的对象。</p>
<ul>
<li><p><strong>文件（File）</strong>是创建者定义的相关信息的集合，操作系统将其映射到存储器中，对用户而言，文件是最小的逻辑分配单元。文件的内容可以是文本、数字或二进制数据，其组织形式可以是自由的，也可以具有严格的格式，这通常由创建者定义。</p>
</li>
<li><p>为了能识别和引用不同的文件，文件通常具有各种<strong>属性（Attributes）</strong>。文件名是一个字符串，它独立于进程、用户甚至操作系统，这个字符串是否区分大小写取决于具体的操作系统。标识符是在文件系统中识别文件的唯一标签，通常为数字。类型则指明了这是特定类型的文件系统的文件。位置是文件在存储设备上的位置指针。大小记录了文件的当前大小或者最大允许容量。时间日期包括文件创建或者上次修改的相关时间信息。保护和权限则指明了不同用户能否对文件进行相关操作（读、写、执行等）。通常文件都具有以上这些属性，还有一些其他属性，但个别文件系统可能并不支持某些属性。值得注意的是，文件内容并不包括属性，所有的文件属性信息都存储在目录结构中。</p>
<p><img src="//l-x.me/2018/05/23/os/File_System/File System/20180526055814104-9.jpg" alt=""><br>图3</p>
</li>
<li><p><strong>目录（Directory）</strong>是用来管理和组织文件的结构，其本质也是一个文件，如右图。一个目录文件包含许多目录项，每一个<strong>目录项（Entry）</strong> 保存一个文件的属性信息（名称、位置等），表示这个文件属于这个目录。一个目录下的允许再包含目录文件，这就形成了以根目录”/”为根的多层次的树状结构，其叶结点为文件。一个文件的名称前面加上各级父目录名称，用”/”分隔，这就形成了文件的路径名称。文件路径通常用于定位一个文件在文件系统中的层次和位置，因为它在整个文件系统中是独一无二的。如果以根目录为起点，称为<strong>绝对路径</strong>，如果以某个目录为起点，则称为<strong>相对路径</strong>。</p>
</li>
</ul>
</li>
</ul>
<h2 id="文件系统的布局与操作"><a href="#文件系统的布局与操作" class="headerlink" title="文件系统的布局与操作"></a>文件系统的布局与操作</h2><ul>
<li><p>各种文件系统的本质区别在于采用不同的存储<strong>布局结构（Layout）</strong>，以及对文件的<strong>操作（Operations）</strong>的不同实现方式。</p>
</li>
<li><p>用户或进程通过操作系统的调用接口对文件进行操作，而操作系统为了能支持不同的文件系统，通常先实现一个<strong>虚拟文件系统（VFS）</strong>，在这个层面上隐藏了实现的细节，定义了抽象的操作集合，在它之下才是各个文件系统具体操作的实现。</p>
<ul>
<li><p><strong>（1）</strong>操作系统对文件进行的<strong>操作</strong>主要有：</p>
<ul>
<li><strong>①创建：</strong>在磁盘中申请一块空间，然后在文件所在的目录增加一个目录项，记录新文件的相关属性。值得注意的是，创建一个文件并不同时打开文件。</li>
<li><strong>②打开：</strong>对文件进行操作时，需要通过路径逐级搜索和定位文件，为了避免频繁地进行这个过程，在首次使用文件时，需要显式（或隐式）地调用open()来“打开”文件，这将在内存中创建一个FILE类型结构体来存储文件的位置信息和其他属性，操作系统则维护一个包括所有打开文件的FILE结构体的列表，称为<strong>打开文件表（Open-files table）</strong>。进程需要对文件进行操作时，提供<strong>文件标识符（File Descriptor）</strong>即打开文件表的索引，而不再是路径。由于多个进程可以同时打开一个文件，为了避免相互影响，每个进程还需要单独维护一个进程的打开文件表，用于存储与进程相关的信息，比如对文件读写的偏移指针。</li>
<li><strong>③读：</strong>首先进程向操作系统提供文件标识符，操作系统在打开文件表中查找到对应的FILE结构，从中获取文件位置和属性，在磁盘中定位和读取相应的数据后存储在内核空间中，最后写入进程指定的用户内存空间中。</li>
<li><strong>④写：</strong>与读相反，先从用户内存空间读取数据到内核空间，然后操作系统将根据不同的策略适时地将数据写回磁盘。若采用<strong>写直达法（Write-through mode）</strong>，内核中的数据立刻被写入磁盘；若采用<strong>写回法（Write-back mode）</strong>，只有当内核空间中的数据需要进行更新时，这些数据才被写入磁盘。</li>
<li><strong>⑤文件内重定位：</strong>直接修改文件偏移指针为指定值。</li>
<li><strong>⑥关闭：</strong>当一个文件不再被使用时，关闭这个文件，打开文件表将移除对应的项。</li>
<li><strong>⑦删除：</strong>将文件在磁盘中的空间释放，并删除目录文件中的对应项。</li>
<li><strong>⑧截短：</strong>删除文件的内容但保留其属性，文件长度变为0。</li>
<li>以上①③④⑤⑦⑧构成了对文件操作的最小集合，由它们可以组合出其他的文件操作。</li>
</ul>
</li>
<li><p><strong>（2）文件系统的布局实例</strong></p>
<ul>
<li><p>对于连续的磁盘空间，不同的文件系统对其进行不同的<strong>划分和组织</strong>，这就形成了不同的布局。文件系统的实现至少应该满足以下几条要求：</p>
<p>  ①被写入的数据能够被重新检索出并读取。</p>
<p>  ②对文件的操作应该是高效的。</p>
<p>  ③当删除一个文件时，文件系统能清除对应的空间。</p>
<p>  更详细的要求就是对上面各种文件操作的具体实现以及空间的具体分配和对空闲空间的管理，下面介绍几种布局的实现并逐步进行改进。</p>
<p><strong>①连续分配方式</strong></p>
</li>
<li><p>这是最直接最朴素的想法，在磁盘连续空间的头部存放根目录，目录中记录各个文件的起始位置和结束位置，文件紧跟着存放在目录的后续空间中（如图4）。这种策略使得删除操作十分简单，只需要在目录文件中删除对应项就可以了。但是，在经过长时间使用后，磁盘的空闲空间将<strong>碎片化</strong>地分散在各个位置，文件系统无法迅速统计空闲空间大小。最大的问题是，如果需要存储一个大文件，有可能无法找到一个足够大的空闲片段来存放，即使存在并且使用了最优策略分配后，在需要增加文件内容时将面临两端皆有其他文件而无法<strong>扩展</strong>的窘境。一种解决方法是移动现有的文件使空闲空间连续，但是这将开销巨大。</p>
<p>  <img src="//l-x.me/2018/05/23/os/File_System/File System/20180526055814104-10.jpg" alt=""> 图4</p>
<p><strong>②链式分配方式</strong></p>
</li>
<li><p>既然大文件可能没有足够大的空闲片段来存放，一个自然的想法是将磁盘划分为<strong>相等大小的块/簇（Cluster）</strong>，文件按块进行存储（如图5）。这些块可以不在连续的空间里，只需要在目录文件中记录每个文件占用的块的序号即可。但是，由于目录文件是目录项的数组，每一项的长度是固定的，因而对于分散的块序号的记录是比较困难的。</p>
<p>  <img src="//l-x.me/2018/05/23/os/File_System/File System/20180526055814104-11.png" alt=""> 图5</p>
</li>
<li><p>一种改进的方法是，目录项只记录文件起始块的序号，而在每个块中留出部分空间存放指向下一个块的指针（如图6），这种情况下，目录项中还需要记录文件的大小，因为文件的最后一块可能并没有填满。另外，还需要在磁盘最前端留出一块空间指向空闲空间的链表。这种策略带来的问题是随机访问性差，访问一个文件需要从头部开始。还有一个问题是关于块大小的选择，如果块太小，则块的指针占用了太多空间，如果块太大，则每个文件最后一个块的浪费将是巨大的。</p>
<p>  <img src="//l-x.me/2018/05/23/os/File_System/File System/20180526055814104-14.jpg" alt="">图6</p>
<p><strong>③链式分配方式的改进——FAT</strong></p>
</li>
<li><p>为了改善随机读写性能，可以将下一个块的位置信息以数组形式统一存放在磁盘头部（如图7），称为<strong>文件分配表（FAT，File Allocation Table）</strong>。数组中每一项存放着当前下标对应的块的下一个块的序号（地址），根据地址长度的不同，可以分为不同版本<strong>（FAT12/16/32）</strong>。这种策略下寻找文件的方式为先从根目录中读取文件的第一个块的地址，然后到FAT中依次获得下一个块的地址并读取每个块。写入文件时，则先从空闲空间信息获取下一个空闲块的位置，然后写入数据并更新FAT和空闲块信息。删除文件时，相关的FAT置为0，更新空闲空间信息并删除目录中相关项。</p>
<p>  <img src="//l-x.me/2018/05/23/os/File_System/File System/20180526055814104-16.jpg" alt=""> 图7</p>
</li>
<li><p>以FAT32为例，磁盘空间分配如图8 所示，头部是引导扇区（存储扇区大小等信息）、文件系统的相关信息（包括空闲空间信息）和预留的空间，其后是两个文件分配表，接下来就是根目录和存储的文件。</p>
<p>  <img src="//l-x.me/2018/05/23/os/File_System/File System/20180526055814104-19.jpg" alt=""> 图8</p>
<p><strong>④索引分配方式</strong></p>
</li>
<li><p>如果对FAT进行分割，每个文件对应的FAT单独存放在一个<strong>索引节点（Index Node）</strong>中，而目录项中指向每个文件对应的索引节点，这就是索引分配方式（如图9）。由于每个文件的FAT大小不同，则索引节点将是变长的，这对于管理十分不便。事实上的做法是，维护一个索引数组，每个索引节点长度固定，索引节点内部有12个指针指向<strong>直接块（Direct Block）</strong>，即数据块，还有一个指针指向<strong>一级间接块（Indirect Block）</strong>，间接块中的每一项才指向数据块，另外还各有一个指针指向二级间接块和三级间接块。假设一个块的大小为<img src="//l-x.me/2018/05/23/os/File_System/File System/20180526055814104-23.png" alt="">byte，块地址32位（4byte），则这种方式下单个文件最大可存储<img src="//l-x.me/2018/05/23/os/File_System/File System/20180526055814104-24.png" alt="">。</p>
<p>  <img src="//l-x.me/2018/05/23/os/File_System/File System/20180526055814104-20.jpg" alt=""> 图9</p>
</li>
<li><p>UNIX和Linux使用类似的索引方式的文件系统，称为<strong>Ext2/Ext3/Ext4</strong>。以Ext2为例，磁盘被划分为许多组（如图11）。每个组的头部都是一个<strong>超级块（Superblock）</strong>，其中包括全部索引节点数、全部空闲块数等信息。其后是<strong>组描述符表（GDT，Group Descriptor Table）</strong>，包括之后各部分的起始位置信息。然后是<strong>块位图（Block Bitmap）</strong>和<strong>索引位图（Inode Bitmap）</strong>，它们的每一位表示一个块/索引是否已经被使用（1表示已使用），最后就是索引节点数组和数据块了。</p>
<p>  <img src="//l-x.me/2018/05/23/os/File_System/File System/20180526055814104-22.jpg" alt=""> 图10</p>
<p>  <img src="//l-x.me/2018/05/23/os/File_System/File System/20180526055814104-25.jpg" alt="">图11 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]  Abraham Silberschatz. 操作系统概念. 高等教育出版社, 2010.1.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/">OS</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-cod/lab6_Multi-CycleCPU" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/10/cod/lab6_Multi-CycleCPU/" class="article-date">
      <time datetime="2018-05-09T16:00:00.000Z" itemprop="datePublished">2018-05-10</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/10/cod/lab6_Multi-CycleCPU/">计算机组成原理上机实验6 多周期CPU</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ol>
<li>实现一个多周期MIPS指令集的CPU，支持包括lw、sw、R-type、addi、beq、bgtz、j等指令。</li>
<li>运行一个计算斐波那契数列的程序，初始为3，3。</li>
</ol>
<h2 id="实验平台"><a href="#实验平台" class="headerlink" title="实验平台"></a>实验平台</h2><ul>
<li>ISE 14.7</li>
</ul>
<h2 id="实验过程（分析）"><a href="#实验过程（分析）" class="headerlink" title="实验过程（分析）"></a>实验过程（分析）</h2><ol>
<li><p>模块化设计，主要有以下几个模块</p>
<p> a) alu模块——算术逻辑单元</p>
<p> b) regfile模块——寄存器文件</p>
<p> c)    mux模块和mux4模块——2路和4路选择器</p>
<p> d)    IP核生成的Mem模块——存放数据段和代码段</p>
<p> e)    nextpclogic模块——计算下一个PC</p>
<p> f)    dff模块——D触发器，用于多周期各段寄存</p>
<p> g)    control模块——FSM控制regfile、IMem、DMem、nextpclogic和alu</p>
<p> h)    top模块——实例化前几个模块，连接各个信号</p>
</li>
<li><p>alu模块使用case语句判断8种操作类型。</p>
</li>
<li><p>regfile模块用组合逻辑读，时序逻辑写。</p>
</li>
<li><p>Mem是同步读，同步写，且由指定coe文件初始化，coe文件的内容是16进制文本，由Mars编译一个汇编代码生成。</p>
</li>
<li><p>nextpclogic模块通过组合逻辑计算出nextPC的值。</p>
</li>
<li><p>dff模块用一个always在时钟沿触发实现非阻塞赋值。</p>
</li>
<li><p>control模块内实现一个有限状态机，三段式实现：</p>
<p> （1）时钟上升沿，改变当前状态，cstate&lt;=nstate</p>
<p> （2）组合逻辑根据当前状态和指令计算次态nstate</p>
<p> （3）时钟下降沿，根据次态nstate，更新各控制信号（将在下一个上升沿起作用），下一周期需要使用的信号置为对应值，不使用的选择信号置x，不使用的使能置0。</p>
<p> 控制信号如下表：</p>
<p> | 状态 | S15 | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7 | S8 | S9 | S10 | S11 |<br> | — | — | — | — | — | — | — | — | — | — | — | — | — | — |<br> |   功能信号 | Rst | Start | Instr decode | MM addr | MM read | read WB | MM write | R-type EXE | R-type WB | Beq | Addi EXE | Addi WB | Jump |<br> | LorD | 0 | 0 | x | x | 1 | x | 1 | x | x | x | x | x | x |<br> | MemRead |  | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |<br> | MemWrite |  | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |<br> | IRWrite |  | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |<br> | RegDst |  | x | x | x | x | 0 | x | x | 1 | x | x | 0 | x |<br> | MemtoReg |  | x | x | x | x | 1 | x | x | 0 | x | x | 0 | x |<br> | RegWrite |  | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 1 | 0 |<br> | ALUSrcASel |  | 0 | 0 | 1 | x | x | x | 1 | x | 1 | 1 | x | x |<br> | ALUSrcBSel |  | 01 | 11 | 10 | xx | xx | xx | 00 | xx | 00 | 10 | xx | xx |<br> | ALUControl |  | 001 | 001 | 001 | xxx | xxx | xxx | ② | xxx | 010 | 001 | xxx | xxx |<br> | Branch |  | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 |<br> | PCWrite | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |<br> | PCSrc | 11① | 00 | xx | xx | xx | xx | xx | xx | xx | 01 | xx | xx | 10 |<br> 注：①rst状态下PCSrc=11，利用4路选择器的剩余1路，置初始nextPC=0.</p>
<p> ②根据Funct具体设置不同的ALUControl<br> ​<br> 状态机如下：</p>
</li>
</ol>
<p><img src="//l-x.me/2018/05/10/cod/lab6_Multi-CycleCPU/pic1.png" alt=""> </p>
<ol start="8">
<li><p>top模块实例化其他所有模块，连接各个信号。</p>
</li>
<li><p>bgtz的实现：bgtz是伪指令（类似地有la和li），不是MIPS指令集的指令，编译时会进行处理，转换为几条指令实现。</p>
<p> 这里我用以下三条指令</p>
<pre><code> slt $t6,$zero,$t1     # if $t1 &gt; 0, that $t6 = 1, else $t6 = 0
 addi $t7,$zero,1      # set $t7 = 1
 beq $t6,$t7,loop      # jump if $t6 = 1, that is to say, $t1 &gt; 0
</code></pre><p> 实现</p>
<pre><code> bgtz $t1, loop        # repeat if not finished yet.
</code></pre></li>
</ol>
<ol start="10">
<li><p>ram模块的初始化</p>
<p>IP核选择Block Memory，设置为Single Port RAM，</p>
<p><img src="//l-x.me/2018/05/10/cod/lab6_Multi-CycleCPU/pic2.png" alt=""> </p>
<p>宽度为32，深度为256</p>
<p><img src="//l-x.me/2018/05/10/cod/lab6_Multi-CycleCPU/pic3.png" alt=""> </p>
<p>选中Load Init File设置，选择初始化coe文件的路径，</p>
<p><img src="//l-x.me/2018/05/10/cod/lab6_Multi-CycleCPU/pic4.png" alt=""> </p>
<p>其中coe文件内容为（Text段为0-63，Data段为64-255）</p>
<pre><code>MEMORY_INITIALIZATION_RADIX=16;
MEMORY_INITIALIZATION_VECTOR=
20080100
200d0150
8dad0000
200b0154
8d6b0000
200c0154
8d8c0004
ad0b0000
ad0c0004
21a9fffe
8d0b0000
8d0c0004
016c5020
ad0a0008
21080004
2129ffff
0009702a
200f0001
11cffff7
08000013
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000014
00000003
00000003
…
</code></pre></li>
<li><p>完整的数据通路</p>
<p><img src="//l-x.me/2018/05/10/cod/lab6_Multi-CycleCPU/pic5.png" alt=""> </p>
</li>
<li><p>分析结果</p>
<pre><code>.data
fibs: .word   0 : 20        # &quot;array&quot; of  20 words to contain fib values
size: .word  20             # size of &quot;array&quot; 
temp: .word 3 3
.text
      la   $t0, fibs        # load address of array
      la   $t5, size        # load address of size variable
      lw   $t5, 0($t5)      # load array size
      la   $t3, temp        # load 
      lw   $t3, 0($t3)
      la   $t4, temp
      lw   $t4, 4($t4)

      sw   $t3, 0($t0)      # F[0] = $t3
      sw   $t4, 4($t0)      # F[1] = $t4
      addi $t1, $t5, -2     # Counter for loop, will execute (size-2) times
loop: lw   $t3, 0($t0)      # Get value from array F[n] 
      lw   $t4, 4($t0)      # Get value from array F[n+1]
      add  $t2, $t3, $t4    # $t2 = F[n] + F[n+1]
      sw   $t2, 8($t0)      # Store F[n+2] = F[n] + F[n+1] in array
      addi $t0, $t0, 4      # increment address of Fib. number source
      addi $t1, $t1, -1     # decrement loop counter
      slt $t6,$zero,$t1     # if $t1 &gt; 0, that $t6 = 1, else $t6 = 0
      addi $t7,$zero,1      # set $t7 = 1
      beq $t6,$t7,loop      # jump if $t6 = 1, that is to say, $t1 &gt; 0
out:  
    j out
</code></pre><p>完整汇编代码如上，可知程序先向内存数据段读取数组首地址（<code>$t0</code>）和大小（<code>$t5</code>，循环次数），读取并写入f[0]=3, f[1]=3，然后循环18次，执行f[i]=f[i-1]+f[i-2]计算斐波那契数列。</p>
<p>如果CPU编写正确，Mem [0-19]（由于Data和Text在同一个Ram，故实际上是在64-83）内容将是3、3、6、9、15、24、39、63、102、165、267、432、699、1131、1830、2961、4791、7752、12543、20295</p>
<p>Reg内容将是：</p>
<p>$t0：最后一次循环后数组基址——256+4*18=328</p>
<p>$t1：剩余循环次数——0</p>
<p>$t2：最后一次的计算结果——20295</p>
<p>$t3：最后一次的计算数1——7752</p>
<p>$t4：最后一次的计算数2——12543</p>
<p>$t5：数组大小——20</p>
<p>$t6：最后一次不跳转——0</p>
<p>$t7：1</p>
</li>
</ol>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><ul>
<li><p>仿真结果：</p>
<p>  仿真得Mem和reg数据为</p>
<p>  <img src="//l-x.me/2018/05/10/cod/lab6_Multi-CycleCPU/pic6.png" alt=""> </p>
<p>  Mem              </p>
<p>  <img src="//l-x.me/2018/05/10/cod/lab6_Multi-CycleCPU/pic7.png" alt=""> </p>
<p>  Regfile</p>
<p>  可见运行结果符合分析。</p>
</li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h2><ul>
<li><p>编写过程中遇到问题和一些发现</p>
<ol>
<li><p>如果位拼接作为左值，单个变量也要花括号，如</p>
<pre><code> `{{RegDst},{ALUSrc},{MemtoReg},{RegWrite},{MemWrite},{Branch},{ALUOp[1:0]},{Jump}}=9&#39;b100100100;`
</code></pre><p> 当然，本次实验中，我没有用位拼接赋值，这样写一行太长了，也不够清晰。</p>
</li>
<li>“==”会严格匹配每一位，比如module内5位数字比较（一个常量，一个input），但外部传入的是3位的，高位自动拓展好像是x，就导致“==”不成立，这是一个不好发现的问题。</li>
<li>仿真遇到高阻态，多半是这个信号不存在，经常是拼写错了，有时候ise检查不出来。</li>
<li>发现如果Mars的memory configuration设置为默认，则编译后导出代码里面的所有la（给某个寄存器赋值一个32位地址）被翻译为连续两句lui和ori；若memory configuration设置为text at address 0则编译后导出代码里面的所有la被翻译为一句addi。我觉得原因是text地址从0 开始的话，如果text部分较短，地址非0部分未超过16位，那么la只需要给低16位赋值就行了，就可以直接用addi实现（addi指令末16位为立即数）。如果地址是实打实的32位那addi就无能为力了，这时候需要lui给高16位赋值，低16位用ori（ori的rs取$0，作用就和addi一样）。</li>
<li>在top里的wire信号，如果通过control模块（或其他模块）进行控制，那么这个信号不能直接在top里赋初值，要到仿真模块里赋值，不然control里改变这个信号的值时，会变成不确定。</li>
<li>在clk边缘用&lt;=对某信号（如state）进行赋值时，如果同时刻需要对该信号进行判断（如状态机，根据状态以完成对应操作），则判断时信号的值是本次改变前的。（非阻塞赋值的特性体现）</li>
</ol>
</li>
</ul>
<ul>
<li><p>模块源代码</p>
<ul>
<li>top.v</li>
</ul>
<pre><code class="verilog">module top( //顶层模块
    input clk,
    input rst_n,
    );

    wire ALUSrcASel;
    wire [1:0] ALUSrcBSel;
    wire [31:0] ALUSrcA;
    wire [31:0] ALUSrcB;
    wire [2:0] ALUControl;
    wire [31:0] ALUResult;
    wire [31:0] ALUResult_DFF; //加_DFF表示对应D触发器的输出，下同
    wire Zero;

    wire [31:0] SignExtented;

    wire [5:0] RegRdaddr1;
    wire [31:0] RegRdout1;
    wire [31:0] RegRdout1_DFF;
    wire [5:0] RegRdaddr2;
    wire [31:0] RegRdout2;
    wire [31:0] RegRdout2_DFF;
    wire [5:0] RegWdaddr;   
    wire [31:0] RegWdin;
    wire RegWrite;
    wire RegDst;

    wire [31:0] Memaddr_src; //这是计算出来的访存地址
    wire [31:0] Memaddr; //这是计算出来的访存地址右移了两位，原因见下面
    wire [31:0] Memout;
    wire [31:0] Memin;
    wire MemRead;
    wire MemWrite;
    wire MemtoReg;

    wire [31:0] Instr;
    wire [31:0] Data;

    wire [31:0] PC;
    wire [31:0] nextPC;

    wire PCEn;
    wire PCWrite;
    wire LorD;
    wire IRWrite;

    wire [5:0] Funct;
    wire [15:0] IMM16;
    wire [4:0] Rd;
    wire [4:0] Rt;
    wire [4:0] Rs;
    wire [5:0] Op;

    wire [25:0] JumpIMM;
    wire [1:0] PCSrc;

    wire Branch;
    //以上信号基本按数据通路图的命名，意义很明显，不多做注释了

    //=======================PC========================

    nextpclogic nextpclogic(PC,PCWrite,PCSrc,JumpIMM,Branch,Zero,ALUResult,ALUResult_DFF,nextPC,PCEn);  
    dff DFFPC(~clk,nextPC,PC,PCEn);

    mux MUXPCALUout(LorD,PC,ALUResult_DFF,Memaddr_src);

    //=======================Memory========================
    assign Memaddr = Memaddr_src &gt;&gt; 2;//&gt;&gt;2是因为这里Mem是每个地址存储4字节，和实际上的（一地址一字节）不一样
    Mem Mem(clk,MemWrite,Memaddr,Memin,Memout); 

    dff DFFInstr(~clk,Memout,Instr,IRWrite);
    dff DFFData(~clk,Memout,Data,1&#39;b1);

    assign JumpIMM = Instr[25:0];
    assign Funct = Instr[5:0];
    assign IMM16 = Instr[15:0];
    assign Rd = Instr[15:11];
    assign Rt = Instr[20:16];
    assign Rs = Instr[25:21];
    assign Op = Instr[31:26];

    assign Memin = RegRdout2_DFF;

    //=======================Regfile========================
    assign RegRdaddr1 = Rs;
    assign RegRdaddr2 = Rt;
    mux #(6) MUXRegWdaddr(RegDst,{1&#39;b0,Rt},{1&#39;b0,Rd},RegWdaddr);
    mux MUXMemtoReg(MemtoReg,ALUResult_DFF,Data,RegWdin);
    regfile regfile(clk,rst_n,RegRdaddr1,RegRdout1,RegRdaddr2,RegRdout2,RegWdaddr,RegWdin,RegWrite);
    dff DFFRegRdout1(~clk,RegRdout1,RegRdout1_DFF,1&#39;b1);
    dff DFFRegRdout2(~clk,RegRdout2,RegRdout2_DFF,1&#39;b1);

    //=========================ALU==========================
    assign SignExtented = {{16{IMM16[15]}},IMM16};
    mux MUXALUSrcA(ALUSrcASel,PC,RegRdout1_DFF,ALUSrcA);
    mux4 MUXALUSrcB(ALUSrcBSel,RegRdout2_DFF,4,SignExtented,SignExtented &lt;&lt; 2,ALUSrcB);
    alu alu(ALUSrcA,ALUSrcB,{2&#39;b00,{ALUControl}},ALUResult,Zero,Sign);
    dff DFFALUResult(~clk,ALUResult,ALUResult_DFF,1&#39;b1);

    //=======================Control========================
    control control(clk,rst_n,Op,Funct,LorD,MemRead,MemWrite,IRWrite,RegDst,MemtoReg,RegWrite,ALUSrcASel,ALUSrcBSel,ALUControl,Branch,PCWrite,PCSrc,tcstate);   
endmodule 
</code></pre>
<ul>
<li>alu.v</li>
</ul>
<pre><code class="verilog">parameter A_NOP =5&#39;h00; //nop
parameter A_ADD =5&#39;h01; //sign_add
parameter A_SUB =5&#39;h02; //sign_sub
parameter A_AND =5&#39;h03; //and
parameter A_OR  =5&#39;h04; //or
parameter A_XOR =5&#39;h05; //xor
parameter A_NOR =5&#39;h06; //nor
parameter A_SLT =5&#39;h07; //slt

module alu(
      input [31:0] alu_a,
      input [31:0] alu_b,
      input [4:0] alu_op,
      output reg [31:0] alu_out,
       output zero
      );
      assign zero = (alu_out == 32&#39;b0)?1:0;
      always@(*)
          case (alu_op)
              A_NOP: alu_out = 0;
              A_ADD: alu_out = alu_a + alu_b;
              A_SUB: alu_out = alu_a - alu_b;
              A_AND: alu_out = alu_a &amp; alu_b;
              A_OR : alu_out = alu_a | alu_b;
              A_XOR: alu_out = alu_a ^ alu_b;
              A_NOR: alu_out = ~(alu_a | alu_b);
              A_SLT: //if a&lt;b(signed) return 1 else return 0;
                  begin
                      if(alu_a[31] == alu_b[31]) alu_out = (alu_a &lt; alu_b) ? 32&#39;b1 : 32&#39;b0;
                      //同号情况，后面的小于是视为无符号的比较
                      else alu_out = (alu_a[31] &lt; alu_b[31]) ? 32&#39;b0 : 32&#39;b1;
  //有符号比较符号
                  end         
              default: ;
          endcase
endmodule
</code></pre>
<ul>
<li>regfile.v</li>
</ul>
<pre><code class="verilog">module regfile( //寄存器文件
      input   clk,
      input rst_n,
      input [5:0] rAddr1,//读地址1
      output [31:0] rDout1,//读数据1
      input [5:0] rAddr2,//读地址2
      output [31:0] rDout2,//读数据2
      input [5:0] wAddr,//写地址
      input [31:0] wDin,//写数据
      input wEna//写使能

  );
      reg [31:0] data [0:63];
      integer i;
      assign rDout1=data[rAddr1];//读1
      assign rDout2=data[rAddr2];//读2
      always@(posedge clk or negedge rst_n)//写和复位
          if(~rst_n)
          begin
              for(i=0; i&lt;64; i=i+1) data[i]&lt;=0;
          end
          else
          begin
              if(wEna)
                  data[wAddr]&lt;=wDin;
          end
endmodule
</code></pre>
<ul>
<li>nextpclogic.v</li>
</ul>
<pre><code class="verilog">module nextpclogic( //生成下一个PC
      input [31:0] PC,
      input PCWrite,
      input [1:0] PCSrc,
      input [25:0] JumpIMM,
      input Branch,
      input Zero,
      input [31:0] ALUResult,
      input [31:0] ALUResult_DFF,
      output [31:0] nextPC,
      output PCEn
     );

      wire [31:0] ShiftLeft2;
      wire [31:0] PCJump;
      wire tmp;
      assign ShiftLeft2 = JumpIMM &lt;&lt; 2;
      assign PCJump = {{PC[31:28]},{{2'b00,JumpIMM}<<2}}; mux4="" muxpc(pcsrc,aluresult,aluresult_dff,pcjump,0,nextpc);="" and(tmp,branch,zero);="" or(pcen,tmp,pcwrite);="" endmodule="" <="" code=""></2}};></code></pre>
<ul>
<li>dff.v</li>
</ul>
<pre><code class="verilog">module dff #(parameter WIDTH = 32) ( //Data Flip-Flop 
      input clk,
      input [WIDTH-1:0] datain,
      output reg [WIDTH-1:0] dataout,
      input en
      );
      always@(posedge clk)
      begin
          if(en)
              dataout &lt;= datain;
      end
endmodule
</code></pre>
<ul>
<li>mux.v</li>
</ul>
<pre><code class="verilog">module mux #(parameter WIDTH = 32)( //2路选择器
    input sel,
      input [WIDTH-1:0] d0,
      input [WIDTH-1:0] d1,
      output [WIDTH-1:0] out
      );
      assign out = (sel == 1&#39;b1 ? d1 : d0);
endmodule
</code></pre>
<ul>
<li>mux4.v<pre><code class="verilog">module mux4 #(parameter WIDTH = 32)( //4路选择器
  input [1:0] sel,
  input [WIDTH-1:0] d0,
  input [WIDTH-1:0] d1,
   input [WIDTH-1:0] d2,
   input [WIDTH-1:0] d3,
  output reg [WIDTH-1:0] out
  );
  always@(*)
      case(sel)
          2&#39;b00: out=d0;
          2&#39;b01: out=d1;
          2&#39;b10: out=d2;
          2&#39;b11: out=d3;
          default:;
      endcase
endmodule
</code></pre>
</li>
<li><p>control.v<br><code>`</code>verilog<br>module control( //控制模块，各信号的控制<br>  input clk,rst_n,<br>  input [5:0] Op, //instr[31:26]<br>  input [5:0] Funct,//instr[5:0]<br>  output reg LorD,<br>  output reg MemRead,<br>  output reg MemWrite,<br>  output reg IRWrite,<br>  output reg RegDst,<br>  output reg MemtoReg,<br>  output reg RegWrite,<br>  output reg ALUSrcASel,<br>  output reg [1:0] ALUSrcBSel,<br>  output reg [2:0] ALUControl,<br>  output reg Branch,<br>  output reg PCWrite,<br>  output reg [1:0] PCSrc,<br>  output [3:0] tcstate<br>  );<br>  reg [3:0] cstate;<br>  reg [3:0] nstate;</p>
<p>  assign tcstate=cstate;<br>  always @(posedge clk or negedge rst_n)//上升沿改变状态</p>
<pre><code>  if(~rst_n) cstate &lt;= 4&#39;d15;//reset状态
  else cstate &lt;= nstate;
</code></pre><p>  always @(*)//计算次态</p>
<pre><code>  case(cstate)
      4&#39;d15://reset
          nstate = 4&#39;d0;
      4&#39;d0://fetch 
          nstate = 4&#39;d1;
      4&#39;d1://decode
          case(Op)
              6&#39;b000000: nstate = 4&#39;d6;//R type
              6&#39;b100011: nstate = 4&#39;d2;//lw
              6&#39;b101011: nstate = 4&#39;d2;//sw
              6&#39;b000100: nstate = 4&#39;d8;//beq  
              6&#39;b000010: nstate = 4&#39;d9;//jump
              6&#39;b001000: nstate = 4&#39;d10;//addi
          endcase
      4&#39;d2: //memaddr
          case(Op)
              6&#39;b100011: nstate = 4&#39;d3;//lw
              6&#39;b101011: nstate = 4&#39;d5;//sw
          endcase
      4&#39;d3: //memread
          nstate = 4&#39;d4;
      4&#39;d4: //memwriteback
          nstate = 4&#39;d0;
      4&#39;d5: //memwrite
          nstate = 4&#39;d0;
      4&#39;d6: //execute
          nstate = 4&#39;d7;
      4&#39;d7: //aluwriteback
          nstate = 4&#39;d0;
      4&#39;d8: //branch
          nstate = 4&#39;d0;
      4&#39;d9: //jump
          nstate = 4&#39;d0;
      4&#39;d10: //addi execute
          nstate = 4&#39;d11;
      4&#39;d11: //addi writeback
          nstate = 4&#39;d0;
  endcase 
</code></pre><p>  //根据下一状态更改控制信号（有使用的信号将更改并做注释，不使用的选择信号置x,不使用的使能置0）<br>  //这里虽然在下降沿更改，但信号将在下一周期（上升沿）起作用(也就是同在这个下降沿的操作读取到的信号是改变前的)<br>  always @(negedge clk or negedge rst_n)//下降沿时，根据次态，更改信号<br>  begin<br>  if(~rst_n) </p>
<pre><code>  begin
      LorD = 1&#39;b0;
      PCSrc = 2&#39;b11; //nextPC=0; 利用4路选择器的剩余1路
      PCWrite = 1&#39;b1;
  end
</code></pre><p>  else</p>
<pre><code>  case(nstate)
      4&#39;d0://fetch 
          begin
              LorD = 1&#39;b0; //------Memaddr: PC
              MemRead = 1&#39;b1; //------enable Mem read
              MemWrite = 1&#39;b0; 
              IRWrite = 1&#39;b1; //------enable save Instr
              RegDst = 1&#39;bx; 
              MemtoReg = 1&#39;bx;
              RegWrite = 1&#39;b0;
              ALUSrcASel = 1&#39;b0; //------srcA: PC
              ALUSrcBSel = 2&#39;b01; //------srcB: 4
              ALUControl = 3&#39;b001; //------ALU&#39;s func: add
              Branch = 1&#39;b0;
              PCWrite = 1&#39;b1; //------enable update PC
              PCSrc = 2&#39;b00; //------select nextPC=PC+4

          end
      4&#39;d1://decode
          begin
              LorD = 1&#39;bx; 
              MemRead = 1&#39;b0; 
              MemWrite = 1&#39;b0; 
              IRWrite = 1&#39;b0; 
              RegDst = 1&#39;bx; 
              MemtoReg = 1&#39;bx; 
              RegWrite = 1&#39;b0; 
              ALUSrcASel = 1&#39;b0; //------srcA: PC
              ALUSrcBSel = 2&#39;b11; //------srcB: SignExtended&lt;&lt;2
              ALUControl = 3&#39;b001; //------ALU&#39;s func: add
              Branch = 1&#39;b0; 
              PCWrite = 1&#39;b0; 
              PCSrc = 2&#39;bxx;  
          end
      4&#39;d2: //memaddr
          begin
              LorD = 1&#39;bx; 
              MemRead = 1&#39;b0; 
              MemWrite = 1&#39;b0; 
              IRWrite = 1&#39;b0; 
              RegDst = 1&#39;bx; 
              MemtoReg = 1&#39;bx; 
              RegWrite = 1&#39;b0; 
              ALUSrcASel = 1&#39;b1; //------srcA: RegRdout1_DFF
              ALUSrcBSel = 2&#39;b10; //------srcB: SignExtended
              ALUControl = 3&#39;b001; //------ALU&#39;s func: add
              Branch = 1&#39;b0; 
              PCWrite = 1&#39;b0; 
              PCSrc = 2&#39;bxx; 
          end
      4&#39;d3: //memread
          begin
              LorD = 1&#39;b1; //------Memaddr: ALUResult_DFF
              MemRead = 1&#39;b1; //------enable Mem read
              MemWrite = 1&#39;b0; 
              IRWrite = 1&#39;b0; 
              RegDst = 1&#39;bx; 
              MemtoReg = 1&#39;bx; 
              RegWrite = 1&#39;b0; 
              ALUSrcASel = 1&#39;bx; 
              ALUSrcBSel = 2&#39;bxx; 
              ALUControl = 3&#39;bxxx; 
              Branch = 1&#39;b0; 
              PCWrite = 1&#39;b0; 
              PCSrc = 2&#39;bxx;  
          end
      4&#39;d4: //memwriteback
          begin
              LorD = 1&#39;bx; 
              MemRead = 1&#39;b0; 
              MemWrite = 1&#39;b0; 
              IRWrite = 1&#39;b0; 
              RegDst = 1&#39;b0; //------RegWdaddr: Rt
              MemtoReg = 1&#39;b1; //------RegWdin: Memout
              RegWrite = 1&#39;b1; //------enable Reg write
              ALUSrcASel = 1&#39;bx; 
              ALUSrcBSel = 2&#39;bxx; 
              ALUControl = 3&#39;bxxx; 
              Branch = 1&#39;b0; 
              PCWrite = 1&#39;b0; 
              PCSrc = 2&#39;bxx; 
          end
      4&#39;d5: //memwrite
          begin
              LorD = 1&#39;b1; //------Memaddr: ALUResult_DFF
              MemRead = 1&#39;b0; 
              MemWrite = 1&#39;b1; //------enable Mem write
              IRWrite = 1&#39;b0; 
              RegDst = 1&#39;bx; 
              MemtoReg = 1&#39;bx; 
              RegWrite = 1&#39;b0; 
              ALUSrcASel = 1&#39;bx; 
              ALUSrcBSel = 2&#39;bxx; 
              ALUControl = 3&#39;bxxx; 
              Branch = 1&#39;b0; 
              PCWrite = 1&#39;b0; 
              PCSrc = 2&#39;bxx; 
          end
      4&#39;d6: //R type execute
          begin
              LorD = 1&#39;bx; 
              MemRead = 1&#39;b0; 
              MemWrite = 1&#39;b0; 
              IRWrite = 1&#39;b0; 
              RegDst = 1&#39;bx; 
              MemtoReg = 1&#39;bx; 
              RegWrite = 1&#39;b0; 
              ALUSrcASel = 1&#39;b1; //------srcA: RegRdout1_DFF
              ALUSrcBSel = 2&#39;b00; //------srcB: RegRdout2_DFF
              case(Funct) //------ALU&#39;s func: decided by &#39;Funct&#39;
                  6&#39;b100000: ALUControl = 5&#39;h01;//add
                  6&#39;b100010: ALUControl = 5&#39;h02;//sub
                  6&#39;b100100: ALUControl = 5&#39;h03;//and
                  6&#39;b100101: ALUControl = 5&#39;h04;//or
                  6&#39;b100110: ALUControl = 5&#39;h05;//xor
                  6&#39;b100111: ALUControl = 5&#39;h06;//nor     
                  6&#39;b101010: ALUControl = 5&#39;h07;//slt
              endcase
              Branch = 1&#39;b0; 
              PCWrite = 1&#39;b0; 
              PCSrc = 2&#39;bxx; 
          end
      4&#39;d7: //aluwriteback
          begin
              LorD = 1&#39;bx; 
              MemRead = 1&#39;b0; 
              MemWrite = 1&#39;b0; 
              IRWrite = 1&#39;b0; 
              RegDst = 1&#39;b1; //------RegWdaddr: Rd
              MemtoReg = 1&#39;b0; //------RegWdin: ALUResult_DFF
              RegWrite = 1&#39;b1; //------enable Reg write
              ALUSrcASel = 1&#39;bx; 
              ALUSrcBSel = 2&#39;bxx; 
              ALUControl = 3&#39;bxxx; 
              Branch = 1&#39;b0; 
              PCWrite = 1&#39;b0; 
              PCSrc = 2&#39;bxx; 
          end
      4&#39;d8: //branch
          begin
              LorD = 1&#39;bx; 
              MemRead = 1&#39;b0; 
              MemWrite = 1&#39;b0; 
              IRWrite = 1&#39;b0; 
              RegDst = 1&#39;bx; 
              MemtoReg = 1&#39;bx; 
              RegWrite = 1&#39;b0; 
              ALUSrcASel = 1&#39;b1; //------srcA: RegRdout1_DFF
              ALUSrcBSel = 2&#39;b00; //------srcB: RegRdout2_DFF 
              ALUControl = 3&#39;b010; //------ALU&#39;s func: sub
              Branch = 1&#39;b1; //------enable update PC if beq 
              PCWrite = 1&#39;b0; 
              PCSrc = 2&#39;b01;  //------select nextPC = ALUResult_DFF(PCBeq)
          end
      4&#39;d9: //jump
          begin
              LorD = 1&#39;bx; 
              MemRead = 1&#39;b0; 
              MemWrite = 1&#39;b0; 
              IRWrite = 1&#39;b0; 
              RegDst = 1&#39;bx; 
              MemtoReg = 1&#39;bx; 
              RegWrite = 1&#39;b0; 
              ALUSrcASel = 1&#39;bx;
              ALUSrcBSel = 2&#39;bxx; 
              ALUControl = 3&#39;bxxx; 
              Branch = 1&#39;b0; 
              PCWrite = 1&#39;b1; //------enable update PC 
              PCSrc = 2&#39;b10;  //------select nextPC = PCJump
          end
      4&#39;d10: //addi execute
          begin
              LorD = 1&#39;bx; 
              MemRead = 1&#39;b0; 
              MemWrite = 1&#39;b0; 
              IRWrite = 1&#39;b0; 
              RegDst = 1&#39;bx; 
              MemtoReg = 1&#39;bx; 
              RegWrite = 1&#39;b0; 
              ALUSrcASel = 1&#39;b1; //------srcA: RegRdout1_DFF
              ALUSrcBSel = 2&#39;b10; //------srcB: SignExtended
              ALUControl = 3&#39;b001; //------ALU&#39;s func: add
              Branch = 1&#39;b0; 
              PCWrite = 1&#39;b0; 
              PCSrc = 2&#39;bxx; 
          end
      4&#39;d11: //addi regwriteback
          begin
              LorD = 1&#39;bx; 
              MemRead = 1&#39;b0; 
              MemWrite = 1&#39;b0; 
              IRWrite = 1&#39;b0; 
              RegDst = 1&#39;b0; //------RegWdaddr: Rt
              MemtoReg = 1&#39;b0; //------RegWdin: ALUResult_DFF
              RegWrite = 1&#39;b1; //------enable Reg write
              ALUSrcASel = 1&#39;bx; 
              ALUSrcBSel = 2&#39;bxx; 
              ALUControl = 3&#39;bxxx; 
              Branch = 1&#39;b0; 
              PCWrite = 1&#39;b0; 
              PCSrc = 2&#39;bxx; 
          end
  endcase         
</code></pre><p>  end</p>
</li>
</ul>
<p>endmodule</p>
<pre><code>- test.v
```verilog
module test;

    // Inputs
    reg clk;
    reg rst_n;

    // Instantiate the Unit Under Test (UUT)
    top uut (
        .clk(clk), 
        .rst_n(rst_n),

    );
    initial begin
        // Initialize Inputs
        clk = 1;

        //
        rst_n = 1;
        #100;

        //
        rst_n = 0;

        // Wait 100 ns for global reset to finish
        #100;
        rst_n = 1;

        forever begin
            #10;
            clk=~clk;
        end
        // Add stimulus here
    end
endmodule
</code></pre></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/COD/">COD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Verilog/">Verilog</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2019 Lyncien
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>